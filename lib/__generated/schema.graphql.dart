class Input$AccessibilityOperationFilterInput {
  factory Input$AccessibilityOperationFilterInput({
    Enum$Accessibility? eq,
    List<Enum$Accessibility>? $in,
    Enum$Accessibility? neq,
    List<Enum$Accessibility>? nin,
  }) =>
      Input$AccessibilityOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
      });

  Input$AccessibilityOperationFilterInput._(this._$data);

  factory Input$AccessibilityOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$Accessibility((l$eq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$Accessibility((e as String)))
          .toList();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : fromJson$Enum$Accessibility((l$neq as String));
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$Accessibility((e as String)))
          .toList();
    }
    return Input$AccessibilityOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$Accessibility? get eq => (_$data['eq'] as Enum$Accessibility?);
  List<Enum$Accessibility>? get $in =>
      (_$data['in'] as List<Enum$Accessibility>?);
  Enum$Accessibility? get neq => (_$data['neq'] as Enum$Accessibility?);
  List<Enum$Accessibility>? get nin =>
      (_$data['nin'] as List<Enum$Accessibility>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$Accessibility(l$eq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$Accessibility(e)).toList();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] =
          l$neq == null ? null : toJson$Enum$Accessibility(l$neq);
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] =
          l$nin?.map((e) => toJson$Enum$Accessibility(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AccessibilityOperationFilterInput<
          Input$AccessibilityOperationFilterInput>
      get copyWith => CopyWith$Input$AccessibilityOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccessibilityOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$neq = neq;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccessibilityOperationFilterInput<TRes> {
  factory CopyWith$Input$AccessibilityOperationFilterInput(
    Input$AccessibilityOperationFilterInput instance,
    TRes Function(Input$AccessibilityOperationFilterInput) then,
  ) = _CopyWithImpl$Input$AccessibilityOperationFilterInput;

  factory CopyWith$Input$AccessibilityOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccessibilityOperationFilterInput;

  TRes call({
    Enum$Accessibility? eq,
    List<Enum$Accessibility>? $in,
    Enum$Accessibility? neq,
    List<Enum$Accessibility>? nin,
  });
}

class _CopyWithImpl$Input$AccessibilityOperationFilterInput<TRes>
    implements CopyWith$Input$AccessibilityOperationFilterInput<TRes> {
  _CopyWithImpl$Input$AccessibilityOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$AccessibilityOperationFilterInput _instance;

  final TRes Function(Input$AccessibilityOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
  }) =>
      _then(Input$AccessibilityOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$Accessibility?),
        if ($in != _undefined) 'in': ($in as List<Enum$Accessibility>?),
        if (neq != _undefined) 'neq': (neq as Enum$Accessibility?),
        if (nin != _undefined) 'nin': (nin as List<Enum$Accessibility>?),
      }));
}

class _CopyWithStubImpl$Input$AccessibilityOperationFilterInput<TRes>
    implements CopyWith$Input$AccessibilityOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$AccessibilityOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$Accessibility? eq,
    List<Enum$Accessibility>? $in,
    Enum$Accessibility? neq,
    List<Enum$Accessibility>? nin,
  }) =>
      _res;
}

class Input$ApplicationFilterInput {
  factory Input$ApplicationFilterInput({
    Input$StringOperationFilterInput? aPIKey,
    Input$BooleanOperationFilterInput? active,
    List<Input$ApplicationFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? applicationVariables,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? minimumVersion,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$ApplicationFilterInput>? or,
    Input$ListFilterInputTypeOfApplicationRoleFilterInput? roles,
    Input$StringOperationFilterInput? siglas,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      Input$ApplicationFilterInput._({
        if (aPIKey != null) r'aPIKey': aPIKey,
        if (active != null) r'active': active,
        if (and != null) r'and': and,
        if (applicationID != null) r'applicationID': applicationID,
        if (applicationVariables != null)
          r'applicationVariables': applicationVariables,
        if (description != null) r'description': description,
        if (minimumVersion != null) r'minimumVersion': minimumVersion,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (nombre != null) r'nombre': nombre,
        if (or != null) r'or': or,
        if (roles != null) r'roles': roles,
        if (siglas != null) r'siglas': siglas,
        if (userPersonMarkers != null) r'userPersonMarkers': userPersonMarkers,
      });

  Input$ApplicationFilterInput._(this._$data);

  factory Input$ApplicationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('aPIKey')) {
      final l$aPIKey = data['aPIKey'];
      result$data['aPIKey'] = l$aPIKey == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$aPIKey as Map<String, dynamic>));
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = l$active == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$active as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$applicationID as Map<String, dynamic>));
    }
    if (data.containsKey('applicationVariables')) {
      final l$applicationVariables = data['applicationVariables'];
      result$data['applicationVariables'] = l$applicationVariables == null
          ? null
          : Input$ListFilterInputTypeOfVariableTypeFilterInput.fromJson(
              (l$applicationVariables as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('minimumVersion')) {
      final l$minimumVersion = data['minimumVersion'];
      result$data['minimumVersion'] = l$minimumVersion == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$minimumVersion as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('nombre')) {
      final l$nombre = data['nombre'];
      result$data['nombre'] = l$nombre == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nombre as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('roles')) {
      final l$roles = data['roles'];
      result$data['roles'] = l$roles == null
          ? null
          : Input$ListFilterInputTypeOfApplicationRoleFilterInput.fromJson(
              (l$roles as Map<String, dynamic>));
    }
    if (data.containsKey('siglas')) {
      final l$siglas = data['siglas'];
      result$data['siglas'] = l$siglas == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$siglas as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = data['userPersonMarkers'];
      result$data['userPersonMarkers'] = l$userPersonMarkers == null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
              (l$userPersonMarkers as Map<String, dynamic>));
    }
    return Input$ApplicationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringOperationFilterInput? get aPIKey =>
      (_$data['aPIKey'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get active =>
      (_$data['active'] as Input$BooleanOperationFilterInput?);
  List<Input$ApplicationFilterInput>? get and =>
      (_$data['and'] as List<Input$ApplicationFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get applicationID =>
      (_$data['applicationID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfVariableTypeFilterInput?
      get applicationVariables => (_$data['applicationVariables']
          as Input$ListFilterInputTypeOfVariableTypeFilterInput?);
  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get minimumVersion =>
      (_$data['minimumVersion'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get nombre =>
      (_$data['nombre'] as Input$StringOperationFilterInput?);
  List<Input$ApplicationFilterInput>? get or =>
      (_$data['or'] as List<Input$ApplicationFilterInput>?);
  Input$ListFilterInputTypeOfApplicationRoleFilterInput? get roles =>
      (_$data['roles']
          as Input$ListFilterInputTypeOfApplicationRoleFilterInput?);
  Input$StringOperationFilterInput? get siglas =>
      (_$data['siglas'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
      get userPersonMarkers => (_$data['userPersonMarkers']
          as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('aPIKey')) {
      final l$aPIKey = aPIKey;
      result$data['aPIKey'] = l$aPIKey?.toJson();
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID?.toJson();
    }
    if (_$data.containsKey('applicationVariables')) {
      final l$applicationVariables = applicationVariables;
      result$data['applicationVariables'] = l$applicationVariables?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('minimumVersion')) {
      final l$minimumVersion = minimumVersion;
      result$data['minimumVersion'] = l$minimumVersion?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('nombre')) {
      final l$nombre = nombre;
      result$data['nombre'] = l$nombre?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('roles')) {
      final l$roles = roles;
      result$data['roles'] = l$roles?.toJson();
    }
    if (_$data.containsKey('siglas')) {
      final l$siglas = siglas;
      result$data['siglas'] = l$siglas?.toJson();
    }
    if (_$data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = userPersonMarkers;
      result$data['userPersonMarkers'] = l$userPersonMarkers?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationFilterInput<Input$ApplicationFilterInput>
      get copyWith => CopyWith$Input$ApplicationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$aPIKey = aPIKey;
    final lOther$aPIKey = other.aPIKey;
    if (_$data.containsKey('aPIKey') != other._$data.containsKey('aPIKey')) {
      return false;
    }
    if (l$aPIKey != lOther$aPIKey) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$applicationVariables = applicationVariables;
    final lOther$applicationVariables = other.applicationVariables;
    if (_$data.containsKey('applicationVariables') !=
        other._$data.containsKey('applicationVariables')) {
      return false;
    }
    if (l$applicationVariables != lOther$applicationVariables) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$minimumVersion = minimumVersion;
    final lOther$minimumVersion = other.minimumVersion;
    if (_$data.containsKey('minimumVersion') !=
        other._$data.containsKey('minimumVersion')) {
      return false;
    }
    if (l$minimumVersion != lOther$minimumVersion) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (_$data.containsKey('nombre') != other._$data.containsKey('nombre')) {
      return false;
    }
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (_$data.containsKey('roles') != other._$data.containsKey('roles')) {
      return false;
    }
    if (l$roles != lOther$roles) {
      return false;
    }
    final l$siglas = siglas;
    final lOther$siglas = other.siglas;
    if (_$data.containsKey('siglas') != other._$data.containsKey('siglas')) {
      return false;
    }
    if (l$siglas != lOther$siglas) {
      return false;
    }
    final l$userPersonMarkers = userPersonMarkers;
    final lOther$userPersonMarkers = other.userPersonMarkers;
    if (_$data.containsKey('userPersonMarkers') !=
        other._$data.containsKey('userPersonMarkers')) {
      return false;
    }
    if (l$userPersonMarkers != lOther$userPersonMarkers) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$aPIKey = aPIKey;
    final l$active = active;
    final l$and = and;
    final l$applicationID = applicationID;
    final l$applicationVariables = applicationVariables;
    final l$description = description;
    final l$minimumVersion = minimumVersion;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$nombre = nombre;
    final l$or = or;
    final l$roles = roles;
    final l$siglas = siglas;
    final l$userPersonMarkers = userPersonMarkers;
    return Object.hashAll([
      _$data.containsKey('aPIKey') ? l$aPIKey : const {},
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('applicationVariables')
          ? l$applicationVariables
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('minimumVersion') ? l$minimumVersion : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('nombre') ? l$nombre : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('roles') ? l$roles : const {},
      _$data.containsKey('siglas') ? l$siglas : const {},
      _$data.containsKey('userPersonMarkers') ? l$userPersonMarkers : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationFilterInput<TRes> {
  factory CopyWith$Input$ApplicationFilterInput(
    Input$ApplicationFilterInput instance,
    TRes Function(Input$ApplicationFilterInput) then,
  ) = _CopyWithImpl$Input$ApplicationFilterInput;

  factory CopyWith$Input$ApplicationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationFilterInput;

  TRes call({
    Input$StringOperationFilterInput? aPIKey,
    Input$BooleanOperationFilterInput? active,
    List<Input$ApplicationFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? applicationVariables,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? minimumVersion,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$ApplicationFilterInput>? or,
    Input$ListFilterInputTypeOfApplicationRoleFilterInput? roles,
    Input$StringOperationFilterInput? siglas,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  });
  CopyWith$Input$StringOperationFilterInput<TRes> get aPIKey;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get active;
  TRes and(
      Iterable<Input$ApplicationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationFilterInput<
                      Input$ApplicationFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID;
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get applicationVariables;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$StringOperationFilterInput<TRes> get minimumVersion;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get nombre;
  TRes or(
      Iterable<Input$ApplicationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationFilterInput<
                      Input$ApplicationFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes>
      get roles;
  CopyWith$Input$StringOperationFilterInput<TRes> get siglas;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers;
}

class _CopyWithImpl$Input$ApplicationFilterInput<TRes>
    implements CopyWith$Input$ApplicationFilterInput<TRes> {
  _CopyWithImpl$Input$ApplicationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationFilterInput _instance;

  final TRes Function(Input$ApplicationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? aPIKey = _undefined,
    Object? active = _undefined,
    Object? and = _undefined,
    Object? applicationID = _undefined,
    Object? applicationVariables = _undefined,
    Object? description = _undefined,
    Object? minimumVersion = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? nombre = _undefined,
    Object? or = _undefined,
    Object? roles = _undefined,
    Object? siglas = _undefined,
    Object? userPersonMarkers = _undefined,
  }) =>
      _then(Input$ApplicationFilterInput._({
        ..._instance._$data,
        if (aPIKey != _undefined)
          'aPIKey': (aPIKey as Input$StringOperationFilterInput?),
        if (active != _undefined)
          'active': (active as Input$BooleanOperationFilterInput?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationFilterInput>?),
        if (applicationID != _undefined)
          'applicationID':
              (applicationID as Input$ComparableInt64OperationFilterInput?),
        if (applicationVariables != _undefined)
          'applicationVariables': (applicationVariables
              as Input$ListFilterInputTypeOfVariableTypeFilterInput?),
        if (description != _undefined)
          'description': (description as Input$StringOperationFilterInput?),
        if (minimumVersion != _undefined)
          'minimumVersion':
              (minimumVersion as Input$StringOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (nombre != _undefined)
          'nombre': (nombre as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$ApplicationFilterInput>?),
        if (roles != _undefined)
          'roles':
              (roles as Input$ListFilterInputTypeOfApplicationRoleFilterInput?),
        if (siglas != _undefined)
          'siglas': (siglas as Input$StringOperationFilterInput?),
        if (userPersonMarkers != _undefined)
          'userPersonMarkers': (userPersonMarkers
              as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?),
      }));
  CopyWith$Input$StringOperationFilterInput<TRes> get aPIKey {
    final local$aPIKey = _instance.aPIKey;
    return local$aPIKey == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$aPIKey, (e) => call(aPIKey: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get active {
    final local$active = _instance.active;
    return local$active == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$active, (e) => call(active: e));
  }

  TRes and(
          Iterable<Input$ApplicationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationFilterInput<
                          Input$ApplicationFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$ApplicationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID {
    final local$applicationID = _instance.applicationID;
    return local$applicationID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$applicationID, (e) => call(applicationID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get applicationVariables {
    final local$applicationVariables = _instance.applicationVariables;
    return local$applicationVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput(
            local$applicationVariables, (e) => call(applicationVariables: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get minimumVersion {
    final local$minimumVersion = _instance.minimumVersion;
    return local$minimumVersion == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$minimumVersion, (e) => call(minimumVersion: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nombre {
    final local$nombre = _instance.nombre;
    return local$nombre == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nombre, (e) => call(nombre: e));
  }

  TRes or(
          Iterable<Input$ApplicationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationFilterInput<
                          Input$ApplicationFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$ApplicationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes>
      get roles {
    final local$roles = _instance.roles;
    return local$roles == null
        ? CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput(
            local$roles, (e) => call(roles: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get siglas {
    final local$siglas = _instance.siglas;
    return local$siglas == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$siglas, (e) => call(siglas: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers {
    final local$userPersonMarkers = _instance.userPersonMarkers;
    return local$userPersonMarkers == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            local$userPersonMarkers, (e) => call(userPersonMarkers: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationFilterInput<TRes>
    implements CopyWith$Input$ApplicationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationFilterInput(this._res);

  TRes _res;

  call({
    Input$StringOperationFilterInput? aPIKey,
    Input$BooleanOperationFilterInput? active,
    List<Input$ApplicationFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? applicationVariables,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? minimumVersion,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$ApplicationFilterInput>? or,
    Input$ListFilterInputTypeOfApplicationRoleFilterInput? roles,
    Input$StringOperationFilterInput? siglas,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      _res;
  CopyWith$Input$StringOperationFilterInput<TRes> get aPIKey =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get active =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  and(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get applicationVariables =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get minimumVersion =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get nombre =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes>
      get roles =>
          CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get siglas =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
              _res);
}

class Input$ApplicationRoleFilterInput {
  factory Input$ApplicationRoleFilterInput({
    List<Input$ApplicationRoleFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationId,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? id,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? normalizedName,
    List<Input$ApplicationRoleFilterInput>? or,
    Input$ListFilterInputTypeOfRolePermissionFilterInput? permissions,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRoles,
  }) =>
      Input$ApplicationRoleFilterInput._({
        if (and != null) r'and': and,
        if (application != null) r'application': application,
        if (applicationId != null) r'applicationId': applicationId,
        if (concurrencyStamp != null) r'concurrencyStamp': concurrencyStamp,
        if (id != null) r'id': id,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (normalizedName != null) r'normalizedName': normalizedName,
        if (or != null) r'or': or,
        if (permissions != null) r'permissions': permissions,
        if (territoryGroupRoles != null)
          r'territoryGroupRoles': territoryGroupRoles,
        if (territoryRoles != null) r'territoryRoles': territoryRoles,
      });

  Input$ApplicationRoleFilterInput._(this._$data);

  factory Input$ApplicationRoleFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$applicationId as Map<String, dynamic>));
    }
    if (data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = data['concurrencyStamp'];
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$concurrencyStamp as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('normalizedName')) {
      final l$normalizedName = data['normalizedName'];
      result$data['normalizedName'] = l$normalizedName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$normalizedName as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('permissions')) {
      final l$permissions = data['permissions'];
      result$data['permissions'] = l$permissions == null
          ? null
          : Input$ListFilterInputTypeOfRolePermissionFilterInput.fromJson(
              (l$permissions as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupRoles')) {
      final l$territoryGroupRoles = data['territoryGroupRoles'];
      result$data['territoryGroupRoles'] = l$territoryGroupRoles == null
          ? null
          : Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput.fromJson(
              (l$territoryGroupRoles as Map<String, dynamic>));
    }
    if (data.containsKey('territoryRoles')) {
      final l$territoryRoles = data['territoryRoles'];
      result$data['territoryRoles'] = l$territoryRoles == null
          ? null
          : Input$ListFilterInputTypeOfTerritoryRoleFilterInput.fromJson(
              (l$territoryRoles as Map<String, dynamic>));
    }
    return Input$ApplicationRoleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ApplicationRoleFilterInput>? get and =>
      (_$data['and'] as List<Input$ApplicationRoleFilterInput>?);
  Input$ApplicationFilterInput? get application =>
      (_$data['application'] as Input$ApplicationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get applicationId =>
      (_$data['applicationId'] as Input$ComparableInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get concurrencyStamp =>
      (_$data['concurrencyStamp'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get normalizedName =>
      (_$data['normalizedName'] as Input$StringOperationFilterInput?);
  List<Input$ApplicationRoleFilterInput>? get or =>
      (_$data['or'] as List<Input$ApplicationRoleFilterInput>?);
  Input$ListFilterInputTypeOfRolePermissionFilterInput? get permissions =>
      (_$data['permissions']
          as Input$ListFilterInputTypeOfRolePermissionFilterInput?);
  Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
      get territoryGroupRoles => (_$data['territoryGroupRoles']
          as Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?);
  Input$ListFilterInputTypeOfTerritoryRoleFilterInput? get territoryRoles =>
      (_$data['territoryRoles']
          as Input$ListFilterInputTypeOfTerritoryRoleFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId?.toJson();
    }
    if (_$data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = concurrencyStamp;
      result$data['concurrencyStamp'] = l$concurrencyStamp?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('normalizedName')) {
      final l$normalizedName = normalizedName;
      result$data['normalizedName'] = l$normalizedName?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('permissions')) {
      final l$permissions = permissions;
      result$data['permissions'] = l$permissions?.toJson();
    }
    if (_$data.containsKey('territoryGroupRoles')) {
      final l$territoryGroupRoles = territoryGroupRoles;
      result$data['territoryGroupRoles'] = l$territoryGroupRoles?.toJson();
    }
    if (_$data.containsKey('territoryRoles')) {
      final l$territoryRoles = territoryRoles;
      result$data['territoryRoles'] = l$territoryRoles?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationRoleFilterInput<Input$ApplicationRoleFilterInput>
      get copyWith => CopyWith$Input$ApplicationRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$concurrencyStamp = concurrencyStamp;
    final lOther$concurrencyStamp = other.concurrencyStamp;
    if (_$data.containsKey('concurrencyStamp') !=
        other._$data.containsKey('concurrencyStamp')) {
      return false;
    }
    if (l$concurrencyStamp != lOther$concurrencyStamp) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$normalizedName = normalizedName;
    final lOther$normalizedName = other.normalizedName;
    if (_$data.containsKey('normalizedName') !=
        other._$data.containsKey('normalizedName')) {
      return false;
    }
    if (l$normalizedName != lOther$normalizedName) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$permissions = permissions;
    final lOther$permissions = other.permissions;
    if (_$data.containsKey('permissions') !=
        other._$data.containsKey('permissions')) {
      return false;
    }
    if (l$permissions != lOther$permissions) {
      return false;
    }
    final l$territoryGroupRoles = territoryGroupRoles;
    final lOther$territoryGroupRoles = other.territoryGroupRoles;
    if (_$data.containsKey('territoryGroupRoles') !=
        other._$data.containsKey('territoryGroupRoles')) {
      return false;
    }
    if (l$territoryGroupRoles != lOther$territoryGroupRoles) {
      return false;
    }
    final l$territoryRoles = territoryRoles;
    final lOther$territoryRoles = other.territoryRoles;
    if (_$data.containsKey('territoryRoles') !=
        other._$data.containsKey('territoryRoles')) {
      return false;
    }
    if (l$territoryRoles != lOther$territoryRoles) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$application = application;
    final l$applicationId = applicationId;
    final l$concurrencyStamp = concurrencyStamp;
    final l$id = id;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$normalizedName = normalizedName;
    final l$or = or;
    final l$permissions = permissions;
    final l$territoryGroupRoles = territoryGroupRoles;
    final l$territoryRoles = territoryRoles;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('concurrencyStamp') ? l$concurrencyStamp : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('normalizedName') ? l$normalizedName : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('permissions') ? l$permissions : const {},
      _$data.containsKey('territoryGroupRoles')
          ? l$territoryGroupRoles
          : const {},
      _$data.containsKey('territoryRoles') ? l$territoryRoles : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationRoleFilterInput<TRes> {
  factory CopyWith$Input$ApplicationRoleFilterInput(
    Input$ApplicationRoleFilterInput instance,
    TRes Function(Input$ApplicationRoleFilterInput) then,
  ) = _CopyWithImpl$Input$ApplicationRoleFilterInput;

  factory CopyWith$Input$ApplicationRoleFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationRoleFilterInput;

  TRes call({
    List<Input$ApplicationRoleFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationId,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? id,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? normalizedName,
    List<Input$ApplicationRoleFilterInput>? or,
    Input$ListFilterInputTypeOfRolePermissionFilterInput? permissions,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRoles,
  });
  TRes and(
      Iterable<Input$ApplicationRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationRoleFilterInput<
                      Input$ApplicationRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ApplicationFilterInput<TRes> get application;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationId;
  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp;
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedName;
  TRes or(
      Iterable<Input$ApplicationRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationRoleFilterInput<
                      Input$ApplicationRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes>
      get permissions;
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles;
  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRoles;
}

class _CopyWithImpl$Input$ApplicationRoleFilterInput<TRes>
    implements CopyWith$Input$ApplicationRoleFilterInput<TRes> {
  _CopyWithImpl$Input$ApplicationRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationRoleFilterInput _instance;

  final TRes Function(Input$ApplicationRoleFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? application = _undefined,
    Object? applicationId = _undefined,
    Object? concurrencyStamp = _undefined,
    Object? id = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? normalizedName = _undefined,
    Object? or = _undefined,
    Object? permissions = _undefined,
    Object? territoryGroupRoles = _undefined,
    Object? territoryRoles = _undefined,
  }) =>
      _then(Input$ApplicationRoleFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$ApplicationRoleFilterInput>?),
        if (application != _undefined)
          'application': (application as Input$ApplicationFilterInput?),
        if (applicationId != _undefined)
          'applicationId':
              (applicationId as Input$ComparableInt64OperationFilterInput?),
        if (concurrencyStamp != _undefined)
          'concurrencyStamp':
              (concurrencyStamp as Input$StringOperationFilterInput?),
        if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (normalizedName != _undefined)
          'normalizedName':
              (normalizedName as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$ApplicationRoleFilterInput>?),
        if (permissions != _undefined)
          'permissions': (permissions
              as Input$ListFilterInputTypeOfRolePermissionFilterInput?),
        if (territoryGroupRoles != _undefined)
          'territoryGroupRoles': (territoryGroupRoles
              as Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?),
        if (territoryRoles != _undefined)
          'territoryRoles': (territoryRoles
              as Input$ListFilterInputTypeOfTerritoryRoleFilterInput?),
      }));
  TRes and(
          Iterable<Input$ApplicationRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationRoleFilterInput<
                          Input$ApplicationRoleFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ApplicationRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ApplicationFilterInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationId {
    final local$applicationId = _instance.applicationId;
    return local$applicationId == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$applicationId, (e) => call(applicationId: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp {
    final local$concurrencyStamp = _instance.concurrencyStamp;
    return local$concurrencyStamp == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$concurrencyStamp, (e) => call(concurrencyStamp: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedName {
    final local$normalizedName = _instance.normalizedName;
    return local$normalizedName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$normalizedName, (e) => call(normalizedName: e));
  }

  TRes or(
          Iterable<Input$ApplicationRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationRoleFilterInput<
                          Input$ApplicationRoleFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$ApplicationRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes>
      get permissions {
    final local$permissions = _instance.permissions;
    return local$permissions == null
        ? CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput(
            local$permissions, (e) => call(permissions: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles {
    final local$territoryGroupRoles = _instance.territoryGroupRoles;
    return local$territoryGroupRoles == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
            local$territoryGroupRoles, (e) => call(territoryGroupRoles: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRoles {
    final local$territoryRoles = _instance.territoryRoles;
    return local$territoryRoles == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
            local$territoryRoles, (e) => call(territoryRoles: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationRoleFilterInput<TRes>
    implements CopyWith$Input$ApplicationRoleFilterInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationRoleFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ApplicationRoleFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationId,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? id,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? normalizedName,
    List<Input$ApplicationRoleFilterInput>? or,
    Input$ListFilterInputTypeOfRolePermissionFilterInput? permissions,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRoles,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ApplicationFilterInput<TRes> get application =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationId =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes>
      get permissions =>
          CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput.stub(
              _res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput
              .stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRoles =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput.stub(
              _res);
}

class Input$ApplicationRoleSortInput {
  factory Input$ApplicationRoleSortInput({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationId,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? id,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? normalizedName,
  }) =>
      Input$ApplicationRoleSortInput._({
        if (application != null) r'application': application,
        if (applicationId != null) r'applicationId': applicationId,
        if (concurrencyStamp != null) r'concurrencyStamp': concurrencyStamp,
        if (id != null) r'id': id,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (normalizedName != null) r'normalizedName': normalizedName,
      });

  Input$ApplicationRoleSortInput._(this._$data);

  factory Input$ApplicationRoleSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationSortInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationId')) {
      final l$applicationId = data['applicationId'];
      result$data['applicationId'] = l$applicationId == null
          ? null
          : fromJson$Enum$SortEnumType((l$applicationId as String));
    }
    if (data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = data['concurrencyStamp'];
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : fromJson$Enum$SortEnumType((l$concurrencyStamp as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('normalizedName')) {
      final l$normalizedName = data['normalizedName'];
      result$data['normalizedName'] = l$normalizedName == null
          ? null
          : fromJson$Enum$SortEnumType((l$normalizedName as String));
    }
    return Input$ApplicationRoleSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ApplicationSortInput? get application =>
      (_$data['application'] as Input$ApplicationSortInput?);
  Enum$SortEnumType? get applicationId =>
      (_$data['applicationId'] as Enum$SortEnumType?);
  Enum$SortEnumType? get concurrencyStamp =>
      (_$data['concurrencyStamp'] as Enum$SortEnumType?);
  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Enum$SortEnumType? get normalizedName =>
      (_$data['normalizedName'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationId')) {
      final l$applicationId = applicationId;
      result$data['applicationId'] = l$applicationId == null
          ? null
          : toJson$Enum$SortEnumType(l$applicationId);
    }
    if (_$data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = concurrencyStamp;
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : toJson$Enum$SortEnumType(l$concurrencyStamp);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('normalizedName')) {
      final l$normalizedName = normalizedName;
      result$data['normalizedName'] = l$normalizedName == null
          ? null
          : toJson$Enum$SortEnumType(l$normalizedName);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationRoleSortInput<Input$ApplicationRoleSortInput>
      get copyWith => CopyWith$Input$ApplicationRoleSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationRoleSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationId = applicationId;
    final lOther$applicationId = other.applicationId;
    if (_$data.containsKey('applicationId') !=
        other._$data.containsKey('applicationId')) {
      return false;
    }
    if (l$applicationId != lOther$applicationId) {
      return false;
    }
    final l$concurrencyStamp = concurrencyStamp;
    final lOther$concurrencyStamp = other.concurrencyStamp;
    if (_$data.containsKey('concurrencyStamp') !=
        other._$data.containsKey('concurrencyStamp')) {
      return false;
    }
    if (l$concurrencyStamp != lOther$concurrencyStamp) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$normalizedName = normalizedName;
    final lOther$normalizedName = other.normalizedName;
    if (_$data.containsKey('normalizedName') !=
        other._$data.containsKey('normalizedName')) {
      return false;
    }
    if (l$normalizedName != lOther$normalizedName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$application = application;
    final l$applicationId = applicationId;
    final l$concurrencyStamp = concurrencyStamp;
    final l$id = id;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$normalizedName = normalizedName;
    return Object.hashAll([
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationId') ? l$applicationId : const {},
      _$data.containsKey('concurrencyStamp') ? l$concurrencyStamp : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('normalizedName') ? l$normalizedName : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationRoleSortInput<TRes> {
  factory CopyWith$Input$ApplicationRoleSortInput(
    Input$ApplicationRoleSortInput instance,
    TRes Function(Input$ApplicationRoleSortInput) then,
  ) = _CopyWithImpl$Input$ApplicationRoleSortInput;

  factory CopyWith$Input$ApplicationRoleSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationRoleSortInput;

  TRes call({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationId,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? id,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? normalizedName,
  });
  CopyWith$Input$ApplicationSortInput<TRes> get application;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
}

class _CopyWithImpl$Input$ApplicationRoleSortInput<TRes>
    implements CopyWith$Input$ApplicationRoleSortInput<TRes> {
  _CopyWithImpl$Input$ApplicationRoleSortInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationRoleSortInput _instance;

  final TRes Function(Input$ApplicationRoleSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? application = _undefined,
    Object? applicationId = _undefined,
    Object? concurrencyStamp = _undefined,
    Object? id = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? normalizedName = _undefined,
  }) =>
      _then(Input$ApplicationRoleSortInput._({
        ..._instance._$data,
        if (application != _undefined)
          'application': (application as Input$ApplicationSortInput?),
        if (applicationId != _undefined)
          'applicationId': (applicationId as Enum$SortEnumType?),
        if (concurrencyStamp != _undefined)
          'concurrencyStamp': (concurrencyStamp as Enum$SortEnumType?),
        if (id != _undefined) 'id': (id as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (normalizedName != _undefined)
          'normalizedName': (normalizedName as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationSortInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationSortInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationRoleSortInput<TRes>
    implements CopyWith$Input$ApplicationRoleSortInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationRoleSortInput(this._res);

  TRes _res;

  call({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationId,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? id,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? normalizedName,
  }) =>
      _res;
  CopyWith$Input$ApplicationSortInput<TRes> get application =>
      CopyWith$Input$ApplicationSortInput.stub(_res);
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
}

class Input$ApplicationSortInput {
  factory Input$ApplicationSortInput({
    Enum$SortEnumType? aPIKey,
    Enum$SortEnumType? active,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? description,
    Enum$SortEnumType? minimumVersion,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? siglas,
  }) =>
      Input$ApplicationSortInput._({
        if (aPIKey != null) r'aPIKey': aPIKey,
        if (active != null) r'active': active,
        if (applicationID != null) r'applicationID': applicationID,
        if (description != null) r'description': description,
        if (minimumVersion != null) r'minimumVersion': minimumVersion,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (nombre != null) r'nombre': nombre,
        if (siglas != null) r'siglas': siglas,
      });

  Input$ApplicationSortInput._(this._$data);

  factory Input$ApplicationSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('aPIKey')) {
      final l$aPIKey = data['aPIKey'];
      result$data['aPIKey'] = l$aPIKey == null
          ? null
          : fromJson$Enum$SortEnumType((l$aPIKey as String));
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = l$active == null
          ? null
          : fromJson$Enum$SortEnumType((l$active as String));
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : fromJson$Enum$SortEnumType((l$applicationID as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('minimumVersion')) {
      final l$minimumVersion = data['minimumVersion'];
      result$data['minimumVersion'] = l$minimumVersion == null
          ? null
          : fromJson$Enum$SortEnumType((l$minimumVersion as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('nombre')) {
      final l$nombre = data['nombre'];
      result$data['nombre'] = l$nombre == null
          ? null
          : fromJson$Enum$SortEnumType((l$nombre as String));
    }
    if (data.containsKey('siglas')) {
      final l$siglas = data['siglas'];
      result$data['siglas'] = l$siglas == null
          ? null
          : fromJson$Enum$SortEnumType((l$siglas as String));
    }
    return Input$ApplicationSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get aPIKey => (_$data['aPIKey'] as Enum$SortEnumType?);
  Enum$SortEnumType? get active => (_$data['active'] as Enum$SortEnumType?);
  Enum$SortEnumType? get applicationID =>
      (_$data['applicationID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);
  Enum$SortEnumType? get minimumVersion =>
      (_$data['minimumVersion'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get nombre => (_$data['nombre'] as Enum$SortEnumType?);
  Enum$SortEnumType? get siglas => (_$data['siglas'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('aPIKey')) {
      final l$aPIKey = aPIKey;
      result$data['aPIKey'] =
          l$aPIKey == null ? null : toJson$Enum$SortEnumType(l$aPIKey);
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] =
          l$active == null ? null : toJson$Enum$SortEnumType(l$active);
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID == null
          ? null
          : toJson$Enum$SortEnumType(l$applicationID);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('minimumVersion')) {
      final l$minimumVersion = minimumVersion;
      result$data['minimumVersion'] = l$minimumVersion == null
          ? null
          : toJson$Enum$SortEnumType(l$minimumVersion);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('nombre')) {
      final l$nombre = nombre;
      result$data['nombre'] =
          l$nombre == null ? null : toJson$Enum$SortEnumType(l$nombre);
    }
    if (_$data.containsKey('siglas')) {
      final l$siglas = siglas;
      result$data['siglas'] =
          l$siglas == null ? null : toJson$Enum$SortEnumType(l$siglas);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationSortInput<Input$ApplicationSortInput>
      get copyWith => CopyWith$Input$ApplicationSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$aPIKey = aPIKey;
    final lOther$aPIKey = other.aPIKey;
    if (_$data.containsKey('aPIKey') != other._$data.containsKey('aPIKey')) {
      return false;
    }
    if (l$aPIKey != lOther$aPIKey) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$minimumVersion = minimumVersion;
    final lOther$minimumVersion = other.minimumVersion;
    if (_$data.containsKey('minimumVersion') !=
        other._$data.containsKey('minimumVersion')) {
      return false;
    }
    if (l$minimumVersion != lOther$minimumVersion) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (_$data.containsKey('nombre') != other._$data.containsKey('nombre')) {
      return false;
    }
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$siglas = siglas;
    final lOther$siglas = other.siglas;
    if (_$data.containsKey('siglas') != other._$data.containsKey('siglas')) {
      return false;
    }
    if (l$siglas != lOther$siglas) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$aPIKey = aPIKey;
    final l$active = active;
    final l$applicationID = applicationID;
    final l$description = description;
    final l$minimumVersion = minimumVersion;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$nombre = nombre;
    final l$siglas = siglas;
    return Object.hashAll([
      _$data.containsKey('aPIKey') ? l$aPIKey : const {},
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('minimumVersion') ? l$minimumVersion : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('nombre') ? l$nombre : const {},
      _$data.containsKey('siglas') ? l$siglas : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationSortInput<TRes> {
  factory CopyWith$Input$ApplicationSortInput(
    Input$ApplicationSortInput instance,
    TRes Function(Input$ApplicationSortInput) then,
  ) = _CopyWithImpl$Input$ApplicationSortInput;

  factory CopyWith$Input$ApplicationSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationSortInput;

  TRes call({
    Enum$SortEnumType? aPIKey,
    Enum$SortEnumType? active,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? description,
    Enum$SortEnumType? minimumVersion,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? siglas,
  });
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
}

class _CopyWithImpl$Input$ApplicationSortInput<TRes>
    implements CopyWith$Input$ApplicationSortInput<TRes> {
  _CopyWithImpl$Input$ApplicationSortInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationSortInput _instance;

  final TRes Function(Input$ApplicationSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? aPIKey = _undefined,
    Object? active = _undefined,
    Object? applicationID = _undefined,
    Object? description = _undefined,
    Object? minimumVersion = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? nombre = _undefined,
    Object? siglas = _undefined,
  }) =>
      _then(Input$ApplicationSortInput._({
        ..._instance._$data,
        if (aPIKey != _undefined) 'aPIKey': (aPIKey as Enum$SortEnumType?),
        if (active != _undefined) 'active': (active as Enum$SortEnumType?),
        if (applicationID != _undefined)
          'applicationID': (applicationID as Enum$SortEnumType?),
        if (description != _undefined)
          'description': (description as Enum$SortEnumType?),
        if (minimumVersion != _undefined)
          'minimumVersion': (minimumVersion as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (nombre != _undefined) 'nombre': (nombre as Enum$SortEnumType?),
        if (siglas != _undefined) 'siglas': (siglas as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationSortInput<TRes>
    implements CopyWith$Input$ApplicationSortInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? aPIKey,
    Enum$SortEnumType? active,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? description,
    Enum$SortEnumType? minimumVersion,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? siglas,
  }) =>
      _res;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
}

class Input$ApplicationUserFilterInput {
  factory Input$ApplicationUserFilterInput({
    Input$ComparableInt32OperationFilterInput? accessFailedCount,
    List<Input$ApplicationUserFilterInput>? and,
    Input$ListFilterInputTypeOfApplicationFilterInput? applications,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? email,
    Input$BooleanOperationFilterInput? emailConfirmed,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        endUserPersonMarkers,
    Input$StringOperationFilterInput? id,
    Input$BooleanOperationFilterInput? lockoutEnabled,
    Input$ComparableNullableOfDateTimeOffsetOperationFilterInput? lockoutEnd,
    Input$ListFilterInputTypeOfPersonFilterInput? menores,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? normalizedEmail,
    Input$StringOperationFilterInput? normalizedUserName,
    List<Input$ApplicationUserFilterInput>? or,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? phoneNumberConfirmed,
    Input$StringOperationFilterInput? securityStamp,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        startUserPersonMarkers,
    Input$BooleanOperationFilterInput? twoFactorEnabled,
    Input$StringOperationFilterInput? userName,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  }) =>
      Input$ApplicationUserFilterInput._({
        if (accessFailedCount != null) r'accessFailedCount': accessFailedCount,
        if (and != null) r'and': and,
        if (applications != null) r'applications': applications,
        if (concurrencyStamp != null) r'concurrencyStamp': concurrencyStamp,
        if (email != null) r'email': email,
        if (emailConfirmed != null) r'emailConfirmed': emailConfirmed,
        if (endUserPersonMarkers != null)
          r'endUserPersonMarkers': endUserPersonMarkers,
        if (id != null) r'id': id,
        if (lockoutEnabled != null) r'lockoutEnabled': lockoutEnabled,
        if (lockoutEnd != null) r'lockoutEnd': lockoutEnd,
        if (menores != null) r'menores': menores,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (normalizedEmail != null) r'normalizedEmail': normalizedEmail,
        if (normalizedUserName != null)
          r'normalizedUserName': normalizedUserName,
        if (or != null) r'or': or,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberConfirmed != null)
          r'phoneNumberConfirmed': phoneNumberConfirmed,
        if (securityStamp != null) r'securityStamp': securityStamp,
        if (startUserPersonMarkers != null)
          r'startUserPersonMarkers': startUserPersonMarkers,
        if (twoFactorEnabled != null) r'twoFactorEnabled': twoFactorEnabled,
        if (userName != null) r'userName': userName,
        if (userTerritories != null) r'userTerritories': userTerritories,
      });

  Input$ApplicationUserFilterInput._(this._$data);

  factory Input$ApplicationUserFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessFailedCount')) {
      final l$accessFailedCount = data['accessFailedCount'];
      result$data['accessFailedCount'] = l$accessFailedCount == null
          ? null
          : Input$ComparableInt32OperationFilterInput.fromJson(
              (l$accessFailedCount as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$ApplicationUserFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('applications')) {
      final l$applications = data['applications'];
      result$data['applications'] = l$applications == null
          ? null
          : Input$ListFilterInputTypeOfApplicationFilterInput.fromJson(
              (l$applications as Map<String, dynamic>));
    }
    if (data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = data['concurrencyStamp'];
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$concurrencyStamp as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('emailConfirmed')) {
      final l$emailConfirmed = data['emailConfirmed'];
      result$data['emailConfirmed'] = l$emailConfirmed == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$emailConfirmed as Map<String, dynamic>));
    }
    if (data.containsKey('endUserPersonMarkers')) {
      final l$endUserPersonMarkers = data['endUserPersonMarkers'];
      result$data['endUserPersonMarkers'] = l$endUserPersonMarkers == null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
              (l$endUserPersonMarkers as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('lockoutEnabled')) {
      final l$lockoutEnabled = data['lockoutEnabled'];
      result$data['lockoutEnabled'] = l$lockoutEnabled == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$lockoutEnabled as Map<String, dynamic>));
    }
    if (data.containsKey('lockoutEnd')) {
      final l$lockoutEnd = data['lockoutEnd'];
      result$data['lockoutEnd'] = l$lockoutEnd == null
          ? null
          : Input$ComparableNullableOfDateTimeOffsetOperationFilterInput
              .fromJson((l$lockoutEnd as Map<String, dynamic>));
    }
    if (data.containsKey('menores')) {
      final l$menores = data['menores'];
      result$data['menores'] = l$menores == null
          ? null
          : Input$ListFilterInputTypeOfPersonFilterInput.fromJson(
              (l$menores as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('normalizedEmail')) {
      final l$normalizedEmail = data['normalizedEmail'];
      result$data['normalizedEmail'] = l$normalizedEmail == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$normalizedEmail as Map<String, dynamic>));
    }
    if (data.containsKey('normalizedUserName')) {
      final l$normalizedUserName = data['normalizedUserName'];
      result$data['normalizedUserName'] = l$normalizedUserName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$normalizedUserName as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$ApplicationUserFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$passwordHash as Map<String, dynamic>));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$phoneNumber as Map<String, dynamic>));
    }
    if (data.containsKey('phoneNumberConfirmed')) {
      final l$phoneNumberConfirmed = data['phoneNumberConfirmed'];
      result$data['phoneNumberConfirmed'] = l$phoneNumberConfirmed == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$phoneNumberConfirmed as Map<String, dynamic>));
    }
    if (data.containsKey('securityStamp')) {
      final l$securityStamp = data['securityStamp'];
      result$data['securityStamp'] = l$securityStamp == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$securityStamp as Map<String, dynamic>));
    }
    if (data.containsKey('startUserPersonMarkers')) {
      final l$startUserPersonMarkers = data['startUserPersonMarkers'];
      result$data['startUserPersonMarkers'] = l$startUserPersonMarkers == null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
              (l$startUserPersonMarkers as Map<String, dynamic>));
    }
    if (data.containsKey('twoFactorEnabled')) {
      final l$twoFactorEnabled = data['twoFactorEnabled'];
      result$data['twoFactorEnabled'] = l$twoFactorEnabled == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$twoFactorEnabled as Map<String, dynamic>));
    }
    if (data.containsKey('userName')) {
      final l$userName = data['userName'];
      result$data['userName'] = l$userName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userName as Map<String, dynamic>));
    }
    if (data.containsKey('userTerritories')) {
      final l$userTerritories = data['userTerritories'];
      result$data['userTerritories'] = l$userTerritories == null
          ? null
          : Input$ListFilterInputTypeOfUserTerritoryFilterInput.fromJson(
              (l$userTerritories as Map<String, dynamic>));
    }
    return Input$ApplicationUserFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ComparableInt32OperationFilterInput? get accessFailedCount =>
      (_$data['accessFailedCount']
          as Input$ComparableInt32OperationFilterInput?);
  List<Input$ApplicationUserFilterInput>? get and =>
      (_$data['and'] as List<Input$ApplicationUserFilterInput>?);
  Input$ListFilterInputTypeOfApplicationFilterInput? get applications =>
      (_$data['applications']
          as Input$ListFilterInputTypeOfApplicationFilterInput?);
  Input$StringOperationFilterInput? get concurrencyStamp =>
      (_$data['concurrencyStamp'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get emailConfirmed =>
      (_$data['emailConfirmed'] as Input$BooleanOperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
      get endUserPersonMarkers => (_$data['endUserPersonMarkers']
          as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?);
  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get lockoutEnabled =>
      (_$data['lockoutEnabled'] as Input$BooleanOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOffsetOperationFilterInput?
      get lockoutEnd => (_$data['lockoutEnd']
          as Input$ComparableNullableOfDateTimeOffsetOperationFilterInput?);
  Input$ListFilterInputTypeOfPersonFilterInput? get menores =>
      (_$data['menores'] as Input$ListFilterInputTypeOfPersonFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get normalizedEmail =>
      (_$data['normalizedEmail'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get normalizedUserName =>
      (_$data['normalizedUserName'] as Input$StringOperationFilterInput?);
  List<Input$ApplicationUserFilterInput>? get or =>
      (_$data['or'] as List<Input$ApplicationUserFilterInput>?);
  Input$StringOperationFilterInput? get passwordHash =>
      (_$data['passwordHash'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get phoneNumber =>
      (_$data['phoneNumber'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get phoneNumberConfirmed =>
      (_$data['phoneNumberConfirmed'] as Input$BooleanOperationFilterInput?);
  Input$StringOperationFilterInput? get securityStamp =>
      (_$data['securityStamp'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
      get startUserPersonMarkers => (_$data['startUserPersonMarkers']
          as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?);
  Input$BooleanOperationFilterInput? get twoFactorEnabled =>
      (_$data['twoFactorEnabled'] as Input$BooleanOperationFilterInput?);
  Input$StringOperationFilterInput? get userName =>
      (_$data['userName'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfUserTerritoryFilterInput? get userTerritories =>
      (_$data['userTerritories']
          as Input$ListFilterInputTypeOfUserTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessFailedCount')) {
      final l$accessFailedCount = accessFailedCount;
      result$data['accessFailedCount'] = l$accessFailedCount?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('applications')) {
      final l$applications = applications;
      result$data['applications'] = l$applications?.toJson();
    }
    if (_$data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = concurrencyStamp;
      result$data['concurrencyStamp'] = l$concurrencyStamp?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('emailConfirmed')) {
      final l$emailConfirmed = emailConfirmed;
      result$data['emailConfirmed'] = l$emailConfirmed?.toJson();
    }
    if (_$data.containsKey('endUserPersonMarkers')) {
      final l$endUserPersonMarkers = endUserPersonMarkers;
      result$data['endUserPersonMarkers'] = l$endUserPersonMarkers?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('lockoutEnabled')) {
      final l$lockoutEnabled = lockoutEnabled;
      result$data['lockoutEnabled'] = l$lockoutEnabled?.toJson();
    }
    if (_$data.containsKey('lockoutEnd')) {
      final l$lockoutEnd = lockoutEnd;
      result$data['lockoutEnd'] = l$lockoutEnd?.toJson();
    }
    if (_$data.containsKey('menores')) {
      final l$menores = menores;
      result$data['menores'] = l$menores?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('normalizedEmail')) {
      final l$normalizedEmail = normalizedEmail;
      result$data['normalizedEmail'] = l$normalizedEmail?.toJson();
    }
    if (_$data.containsKey('normalizedUserName')) {
      final l$normalizedUserName = normalizedUserName;
      result$data['normalizedUserName'] = l$normalizedUserName?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash?.toJson();
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber?.toJson();
    }
    if (_$data.containsKey('phoneNumberConfirmed')) {
      final l$phoneNumberConfirmed = phoneNumberConfirmed;
      result$data['phoneNumberConfirmed'] = l$phoneNumberConfirmed?.toJson();
    }
    if (_$data.containsKey('securityStamp')) {
      final l$securityStamp = securityStamp;
      result$data['securityStamp'] = l$securityStamp?.toJson();
    }
    if (_$data.containsKey('startUserPersonMarkers')) {
      final l$startUserPersonMarkers = startUserPersonMarkers;
      result$data['startUserPersonMarkers'] =
          l$startUserPersonMarkers?.toJson();
    }
    if (_$data.containsKey('twoFactorEnabled')) {
      final l$twoFactorEnabled = twoFactorEnabled;
      result$data['twoFactorEnabled'] = l$twoFactorEnabled?.toJson();
    }
    if (_$data.containsKey('userName')) {
      final l$userName = userName;
      result$data['userName'] = l$userName?.toJson();
    }
    if (_$data.containsKey('userTerritories')) {
      final l$userTerritories = userTerritories;
      result$data['userTerritories'] = l$userTerritories?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserFilterInput<Input$ApplicationUserFilterInput>
      get copyWith => CopyWith$Input$ApplicationUserFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessFailedCount = accessFailedCount;
    final lOther$accessFailedCount = other.accessFailedCount;
    if (_$data.containsKey('accessFailedCount') !=
        other._$data.containsKey('accessFailedCount')) {
      return false;
    }
    if (l$accessFailedCount != lOther$accessFailedCount) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$applications = applications;
    final lOther$applications = other.applications;
    if (_$data.containsKey('applications') !=
        other._$data.containsKey('applications')) {
      return false;
    }
    if (l$applications != lOther$applications) {
      return false;
    }
    final l$concurrencyStamp = concurrencyStamp;
    final lOther$concurrencyStamp = other.concurrencyStamp;
    if (_$data.containsKey('concurrencyStamp') !=
        other._$data.containsKey('concurrencyStamp')) {
      return false;
    }
    if (l$concurrencyStamp != lOther$concurrencyStamp) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailConfirmed = emailConfirmed;
    final lOther$emailConfirmed = other.emailConfirmed;
    if (_$data.containsKey('emailConfirmed') !=
        other._$data.containsKey('emailConfirmed')) {
      return false;
    }
    if (l$emailConfirmed != lOther$emailConfirmed) {
      return false;
    }
    final l$endUserPersonMarkers = endUserPersonMarkers;
    final lOther$endUserPersonMarkers = other.endUserPersonMarkers;
    if (_$data.containsKey('endUserPersonMarkers') !=
        other._$data.containsKey('endUserPersonMarkers')) {
      return false;
    }
    if (l$endUserPersonMarkers != lOther$endUserPersonMarkers) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$lockoutEnabled = lockoutEnabled;
    final lOther$lockoutEnabled = other.lockoutEnabled;
    if (_$data.containsKey('lockoutEnabled') !=
        other._$data.containsKey('lockoutEnabled')) {
      return false;
    }
    if (l$lockoutEnabled != lOther$lockoutEnabled) {
      return false;
    }
    final l$lockoutEnd = lockoutEnd;
    final lOther$lockoutEnd = other.lockoutEnd;
    if (_$data.containsKey('lockoutEnd') !=
        other._$data.containsKey('lockoutEnd')) {
      return false;
    }
    if (l$lockoutEnd != lOther$lockoutEnd) {
      return false;
    }
    final l$menores = menores;
    final lOther$menores = other.menores;
    if (_$data.containsKey('menores') != other._$data.containsKey('menores')) {
      return false;
    }
    if (l$menores != lOther$menores) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$normalizedEmail = normalizedEmail;
    final lOther$normalizedEmail = other.normalizedEmail;
    if (_$data.containsKey('normalizedEmail') !=
        other._$data.containsKey('normalizedEmail')) {
      return false;
    }
    if (l$normalizedEmail != lOther$normalizedEmail) {
      return false;
    }
    final l$normalizedUserName = normalizedUserName;
    final lOther$normalizedUserName = other.normalizedUserName;
    if (_$data.containsKey('normalizedUserName') !=
        other._$data.containsKey('normalizedUserName')) {
      return false;
    }
    if (l$normalizedUserName != lOther$normalizedUserName) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberConfirmed = phoneNumberConfirmed;
    final lOther$phoneNumberConfirmed = other.phoneNumberConfirmed;
    if (_$data.containsKey('phoneNumberConfirmed') !=
        other._$data.containsKey('phoneNumberConfirmed')) {
      return false;
    }
    if (l$phoneNumberConfirmed != lOther$phoneNumberConfirmed) {
      return false;
    }
    final l$securityStamp = securityStamp;
    final lOther$securityStamp = other.securityStamp;
    if (_$data.containsKey('securityStamp') !=
        other._$data.containsKey('securityStamp')) {
      return false;
    }
    if (l$securityStamp != lOther$securityStamp) {
      return false;
    }
    final l$startUserPersonMarkers = startUserPersonMarkers;
    final lOther$startUserPersonMarkers = other.startUserPersonMarkers;
    if (_$data.containsKey('startUserPersonMarkers') !=
        other._$data.containsKey('startUserPersonMarkers')) {
      return false;
    }
    if (l$startUserPersonMarkers != lOther$startUserPersonMarkers) {
      return false;
    }
    final l$twoFactorEnabled = twoFactorEnabled;
    final lOther$twoFactorEnabled = other.twoFactorEnabled;
    if (_$data.containsKey('twoFactorEnabled') !=
        other._$data.containsKey('twoFactorEnabled')) {
      return false;
    }
    if (l$twoFactorEnabled != lOther$twoFactorEnabled) {
      return false;
    }
    final l$userName = userName;
    final lOther$userName = other.userName;
    if (_$data.containsKey('userName') !=
        other._$data.containsKey('userName')) {
      return false;
    }
    if (l$userName != lOther$userName) {
      return false;
    }
    final l$userTerritories = userTerritories;
    final lOther$userTerritories = other.userTerritories;
    if (_$data.containsKey('userTerritories') !=
        other._$data.containsKey('userTerritories')) {
      return false;
    }
    if (l$userTerritories != lOther$userTerritories) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessFailedCount = accessFailedCount;
    final l$and = and;
    final l$applications = applications;
    final l$concurrencyStamp = concurrencyStamp;
    final l$email = email;
    final l$emailConfirmed = emailConfirmed;
    final l$endUserPersonMarkers = endUserPersonMarkers;
    final l$id = id;
    final l$lockoutEnabled = lockoutEnabled;
    final l$lockoutEnd = lockoutEnd;
    final l$menores = menores;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$normalizedEmail = normalizedEmail;
    final l$normalizedUserName = normalizedUserName;
    final l$or = or;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberConfirmed = phoneNumberConfirmed;
    final l$securityStamp = securityStamp;
    final l$startUserPersonMarkers = startUserPersonMarkers;
    final l$twoFactorEnabled = twoFactorEnabled;
    final l$userName = userName;
    final l$userTerritories = userTerritories;
    return Object.hashAll([
      _$data.containsKey('accessFailedCount') ? l$accessFailedCount : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('applications') ? l$applications : const {},
      _$data.containsKey('concurrencyStamp') ? l$concurrencyStamp : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailConfirmed') ? l$emailConfirmed : const {},
      _$data.containsKey('endUserPersonMarkers')
          ? l$endUserPersonMarkers
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('lockoutEnabled') ? l$lockoutEnabled : const {},
      _$data.containsKey('lockoutEnd') ? l$lockoutEnd : const {},
      _$data.containsKey('menores') ? l$menores : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('normalizedEmail') ? l$normalizedEmail : const {},
      _$data.containsKey('normalizedUserName')
          ? l$normalizedUserName
          : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberConfirmed')
          ? l$phoneNumberConfirmed
          : const {},
      _$data.containsKey('securityStamp') ? l$securityStamp : const {},
      _$data.containsKey('startUserPersonMarkers')
          ? l$startUserPersonMarkers
          : const {},
      _$data.containsKey('twoFactorEnabled') ? l$twoFactorEnabled : const {},
      _$data.containsKey('userName') ? l$userName : const {},
      _$data.containsKey('userTerritories') ? l$userTerritories : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserFilterInput<TRes> {
  factory CopyWith$Input$ApplicationUserFilterInput(
    Input$ApplicationUserFilterInput instance,
    TRes Function(Input$ApplicationUserFilterInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserFilterInput;

  factory CopyWith$Input$ApplicationUserFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserFilterInput;

  TRes call({
    Input$ComparableInt32OperationFilterInput? accessFailedCount,
    List<Input$ApplicationUserFilterInput>? and,
    Input$ListFilterInputTypeOfApplicationFilterInput? applications,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? email,
    Input$BooleanOperationFilterInput? emailConfirmed,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        endUserPersonMarkers,
    Input$StringOperationFilterInput? id,
    Input$BooleanOperationFilterInput? lockoutEnabled,
    Input$ComparableNullableOfDateTimeOffsetOperationFilterInput? lockoutEnd,
    Input$ListFilterInputTypeOfPersonFilterInput? menores,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? normalizedEmail,
    Input$StringOperationFilterInput? normalizedUserName,
    List<Input$ApplicationUserFilterInput>? or,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? phoneNumberConfirmed,
    Input$StringOperationFilterInput? securityStamp,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        startUserPersonMarkers,
    Input$BooleanOperationFilterInput? twoFactorEnabled,
    Input$StringOperationFilterInput? userName,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  });
  CopyWith$Input$ComparableInt32OperationFilterInput<TRes>
      get accessFailedCount;
  TRes and(
      Iterable<Input$ApplicationUserFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserFilterInput<
                      Input$ApplicationUserFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<TRes>
      get applications;
  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get emailConfirmed;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get endUserPersonMarkers;
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get lockoutEnabled;
  CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<TRes>
      get lockoutEnd;
  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get menores;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedEmail;
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedUserName;
  TRes or(
      Iterable<Input$ApplicationUserFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ApplicationUserFilterInput<
                      Input$ApplicationUserFilterInput>>?)
          _fn);
  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash;
  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get phoneNumberConfirmed;
  CopyWith$Input$StringOperationFilterInput<TRes> get securityStamp;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get startUserPersonMarkers;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get twoFactorEnabled;
  CopyWith$Input$StringOperationFilterInput<TRes> get userName;
  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories;
}

class _CopyWithImpl$Input$ApplicationUserFilterInput<TRes>
    implements CopyWith$Input$ApplicationUserFilterInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserFilterInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserFilterInput _instance;

  final TRes Function(Input$ApplicationUserFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessFailedCount = _undefined,
    Object? and = _undefined,
    Object? applications = _undefined,
    Object? concurrencyStamp = _undefined,
    Object? email = _undefined,
    Object? emailConfirmed = _undefined,
    Object? endUserPersonMarkers = _undefined,
    Object? id = _undefined,
    Object? lockoutEnabled = _undefined,
    Object? lockoutEnd = _undefined,
    Object? menores = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? normalizedEmail = _undefined,
    Object? normalizedUserName = _undefined,
    Object? or = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberConfirmed = _undefined,
    Object? securityStamp = _undefined,
    Object? startUserPersonMarkers = _undefined,
    Object? twoFactorEnabled = _undefined,
    Object? userName = _undefined,
    Object? userTerritories = _undefined,
  }) =>
      _then(Input$ApplicationUserFilterInput._({
        ..._instance._$data,
        if (accessFailedCount != _undefined)
          'accessFailedCount':
              (accessFailedCount as Input$ComparableInt32OperationFilterInput?),
        if (and != _undefined)
          'and': (and as List<Input$ApplicationUserFilterInput>?),
        if (applications != _undefined)
          'applications': (applications
              as Input$ListFilterInputTypeOfApplicationFilterInput?),
        if (concurrencyStamp != _undefined)
          'concurrencyStamp':
              (concurrencyStamp as Input$StringOperationFilterInput?),
        if (email != _undefined)
          'email': (email as Input$StringOperationFilterInput?),
        if (emailConfirmed != _undefined)
          'emailConfirmed':
              (emailConfirmed as Input$BooleanOperationFilterInput?),
        if (endUserPersonMarkers != _undefined)
          'endUserPersonMarkers': (endUserPersonMarkers
              as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?),
        if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
        if (lockoutEnabled != _undefined)
          'lockoutEnabled':
              (lockoutEnabled as Input$BooleanOperationFilterInput?),
        if (lockoutEnd != _undefined)
          'lockoutEnd': (lockoutEnd
              as Input$ComparableNullableOfDateTimeOffsetOperationFilterInput?),
        if (menores != _undefined)
          'menores': (menores as Input$ListFilterInputTypeOfPersonFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (normalizedEmail != _undefined)
          'normalizedEmail':
              (normalizedEmail as Input$StringOperationFilterInput?),
        if (normalizedUserName != _undefined)
          'normalizedUserName':
              (normalizedUserName as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$ApplicationUserFilterInput>?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as Input$StringOperationFilterInput?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as Input$StringOperationFilterInput?),
        if (phoneNumberConfirmed != _undefined)
          'phoneNumberConfirmed':
              (phoneNumberConfirmed as Input$BooleanOperationFilterInput?),
        if (securityStamp != _undefined)
          'securityStamp': (securityStamp as Input$StringOperationFilterInput?),
        if (startUserPersonMarkers != _undefined)
          'startUserPersonMarkers': (startUserPersonMarkers
              as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?),
        if (twoFactorEnabled != _undefined)
          'twoFactorEnabled':
              (twoFactorEnabled as Input$BooleanOperationFilterInput?),
        if (userName != _undefined)
          'userName': (userName as Input$StringOperationFilterInput?),
        if (userTerritories != _undefined)
          'userTerritories': (userTerritories
              as Input$ListFilterInputTypeOfUserTerritoryFilterInput?),
      }));
  CopyWith$Input$ComparableInt32OperationFilterInput<TRes>
      get accessFailedCount {
    final local$accessFailedCount = _instance.accessFailedCount;
    return local$accessFailedCount == null
        ? CopyWith$Input$ComparableInt32OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt32OperationFilterInput(
            local$accessFailedCount, (e) => call(accessFailedCount: e));
  }

  TRes and(
          Iterable<Input$ApplicationUserFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserFilterInput<
                          Input$ApplicationUserFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$ApplicationUserFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<TRes>
      get applications {
    final local$applications = _instance.applications;
    return local$applications == null
        ? CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput(
            local$applications, (e) => call(applications: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp {
    final local$concurrencyStamp = _instance.concurrencyStamp;
    return local$concurrencyStamp == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$concurrencyStamp, (e) => call(concurrencyStamp: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get emailConfirmed {
    final local$emailConfirmed = _instance.emailConfirmed;
    return local$emailConfirmed == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$emailConfirmed, (e) => call(emailConfirmed: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get endUserPersonMarkers {
    final local$endUserPersonMarkers = _instance.endUserPersonMarkers;
    return local$endUserPersonMarkers == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            local$endUserPersonMarkers, (e) => call(endUserPersonMarkers: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get lockoutEnabled {
    final local$lockoutEnabled = _instance.lockoutEnabled;
    return local$lockoutEnabled == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$lockoutEnabled, (e) => call(lockoutEnabled: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<TRes>
      get lockoutEnd {
    final local$lockoutEnd = _instance.lockoutEnd;
    return local$lockoutEnd == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput(
            local$lockoutEnd, (e) => call(lockoutEnd: e));
  }

  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get menores {
    final local$menores = _instance.menores;
    return local$menores == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonFilterInput(
            local$menores, (e) => call(menores: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedEmail {
    final local$normalizedEmail = _instance.normalizedEmail;
    return local$normalizedEmail == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$normalizedEmail, (e) => call(normalizedEmail: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedUserName {
    final local$normalizedUserName = _instance.normalizedUserName;
    return local$normalizedUserName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$normalizedUserName, (e) => call(normalizedUserName: e));
  }

  TRes or(
          Iterable<Input$ApplicationUserFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ApplicationUserFilterInput<
                          Input$ApplicationUserFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$ApplicationUserFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash {
    final local$passwordHash = _instance.passwordHash;
    return local$passwordHash == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$passwordHash, (e) => call(passwordHash: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber {
    final local$phoneNumber = _instance.phoneNumber;
    return local$phoneNumber == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$phoneNumber, (e) => call(phoneNumber: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get phoneNumberConfirmed {
    final local$phoneNumberConfirmed = _instance.phoneNumberConfirmed;
    return local$phoneNumberConfirmed == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$phoneNumberConfirmed, (e) => call(phoneNumberConfirmed: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get securityStamp {
    final local$securityStamp = _instance.securityStamp;
    return local$securityStamp == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$securityStamp, (e) => call(securityStamp: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get startUserPersonMarkers {
    final local$startUserPersonMarkers = _instance.startUserPersonMarkers;
    return local$startUserPersonMarkers == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            local$startUserPersonMarkers,
            (e) => call(startUserPersonMarkers: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get twoFactorEnabled {
    final local$twoFactorEnabled = _instance.twoFactorEnabled;
    return local$twoFactorEnabled == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$twoFactorEnabled, (e) => call(twoFactorEnabled: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userName {
    final local$userName = _instance.userName;
    return local$userName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userName, (e) => call(userName: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories {
    final local$userTerritories = _instance.userTerritories;
    return local$userTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
            local$userTerritories, (e) => call(userTerritories: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationUserFilterInput<TRes>
    implements CopyWith$Input$ApplicationUserFilterInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserFilterInput(this._res);

  TRes _res;

  call({
    Input$ComparableInt32OperationFilterInput? accessFailedCount,
    List<Input$ApplicationUserFilterInput>? and,
    Input$ListFilterInputTypeOfApplicationFilterInput? applications,
    Input$StringOperationFilterInput? concurrencyStamp,
    Input$StringOperationFilterInput? email,
    Input$BooleanOperationFilterInput? emailConfirmed,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        endUserPersonMarkers,
    Input$StringOperationFilterInput? id,
    Input$BooleanOperationFilterInput? lockoutEnabled,
    Input$ComparableNullableOfDateTimeOffsetOperationFilterInput? lockoutEnd,
    Input$ListFilterInputTypeOfPersonFilterInput? menores,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? normalizedEmail,
    Input$StringOperationFilterInput? normalizedUserName,
    List<Input$ApplicationUserFilterInput>? or,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? phoneNumberConfirmed,
    Input$StringOperationFilterInput? securityStamp,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
        startUserPersonMarkers,
    Input$BooleanOperationFilterInput? twoFactorEnabled,
    Input$StringOperationFilterInput? userName,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  }) =>
      _res;
  CopyWith$Input$ComparableInt32OperationFilterInput<TRes>
      get accessFailedCount =>
          CopyWith$Input$ComparableInt32OperationFilterInput.stub(_res);
  and(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<TRes>
      get applications =>
          CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get concurrencyStamp =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get emailConfirmed =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get endUserPersonMarkers =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get lockoutEnabled =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<TRes>
      get lockoutEnd =>
          CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput
              .stub(_res);
  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get menores =>
      CopyWith$Input$ListFilterInputTypeOfPersonFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedEmail =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get normalizedUserName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get phoneNumberConfirmed =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get securityStamp =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get startUserPersonMarkers =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
              _res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get twoFactorEnabled =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get userName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories =>
          CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput.stub(
              _res);
}

class Input$ApplicationUserSortInput {
  factory Input$ApplicationUserSortInput({
    Enum$SortEnumType? accessFailedCount,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? email,
    Enum$SortEnumType? emailConfirmed,
    Enum$SortEnumType? id,
    Enum$SortEnumType? lockoutEnabled,
    Enum$SortEnumType? lockoutEnd,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? normalizedEmail,
    Enum$SortEnumType? normalizedUserName,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? phoneNumberConfirmed,
    Enum$SortEnumType? securityStamp,
    Enum$SortEnumType? twoFactorEnabled,
    Enum$SortEnumType? userName,
  }) =>
      Input$ApplicationUserSortInput._({
        if (accessFailedCount != null) r'accessFailedCount': accessFailedCount,
        if (concurrencyStamp != null) r'concurrencyStamp': concurrencyStamp,
        if (email != null) r'email': email,
        if (emailConfirmed != null) r'emailConfirmed': emailConfirmed,
        if (id != null) r'id': id,
        if (lockoutEnabled != null) r'lockoutEnabled': lockoutEnabled,
        if (lockoutEnd != null) r'lockoutEnd': lockoutEnd,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (normalizedEmail != null) r'normalizedEmail': normalizedEmail,
        if (normalizedUserName != null)
          r'normalizedUserName': normalizedUserName,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberConfirmed != null)
          r'phoneNumberConfirmed': phoneNumberConfirmed,
        if (securityStamp != null) r'securityStamp': securityStamp,
        if (twoFactorEnabled != null) r'twoFactorEnabled': twoFactorEnabled,
        if (userName != null) r'userName': userName,
      });

  Input$ApplicationUserSortInput._(this._$data);

  factory Input$ApplicationUserSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessFailedCount')) {
      final l$accessFailedCount = data['accessFailedCount'];
      result$data['accessFailedCount'] = l$accessFailedCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$accessFailedCount as String));
    }
    if (data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = data['concurrencyStamp'];
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : fromJson$Enum$SortEnumType((l$concurrencyStamp as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$SortEnumType((l$email as String));
    }
    if (data.containsKey('emailConfirmed')) {
      final l$emailConfirmed = data['emailConfirmed'];
      result$data['emailConfirmed'] = l$emailConfirmed == null
          ? null
          : fromJson$Enum$SortEnumType((l$emailConfirmed as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('lockoutEnabled')) {
      final l$lockoutEnabled = data['lockoutEnabled'];
      result$data['lockoutEnabled'] = l$lockoutEnabled == null
          ? null
          : fromJson$Enum$SortEnumType((l$lockoutEnabled as String));
    }
    if (data.containsKey('lockoutEnd')) {
      final l$lockoutEnd = data['lockoutEnd'];
      result$data['lockoutEnd'] = l$lockoutEnd == null
          ? null
          : fromJson$Enum$SortEnumType((l$lockoutEnd as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('normalizedEmail')) {
      final l$normalizedEmail = data['normalizedEmail'];
      result$data['normalizedEmail'] = l$normalizedEmail == null
          ? null
          : fromJson$Enum$SortEnumType((l$normalizedEmail as String));
    }
    if (data.containsKey('normalizedUserName')) {
      final l$normalizedUserName = data['normalizedUserName'];
      result$data['normalizedUserName'] = l$normalizedUserName == null
          ? null
          : fromJson$Enum$SortEnumType((l$normalizedUserName as String));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : fromJson$Enum$SortEnumType((l$passwordHash as String));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : fromJson$Enum$SortEnumType((l$phoneNumber as String));
    }
    if (data.containsKey('phoneNumberConfirmed')) {
      final l$phoneNumberConfirmed = data['phoneNumberConfirmed'];
      result$data['phoneNumberConfirmed'] = l$phoneNumberConfirmed == null
          ? null
          : fromJson$Enum$SortEnumType((l$phoneNumberConfirmed as String));
    }
    if (data.containsKey('securityStamp')) {
      final l$securityStamp = data['securityStamp'];
      result$data['securityStamp'] = l$securityStamp == null
          ? null
          : fromJson$Enum$SortEnumType((l$securityStamp as String));
    }
    if (data.containsKey('twoFactorEnabled')) {
      final l$twoFactorEnabled = data['twoFactorEnabled'];
      result$data['twoFactorEnabled'] = l$twoFactorEnabled == null
          ? null
          : fromJson$Enum$SortEnumType((l$twoFactorEnabled as String));
    }
    if (data.containsKey('userName')) {
      final l$userName = data['userName'];
      result$data['userName'] = l$userName == null
          ? null
          : fromJson$Enum$SortEnumType((l$userName as String));
    }
    return Input$ApplicationUserSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get accessFailedCount =>
      (_$data['accessFailedCount'] as Enum$SortEnumType?);
  Enum$SortEnumType? get concurrencyStamp =>
      (_$data['concurrencyStamp'] as Enum$SortEnumType?);
  Enum$SortEnumType? get email => (_$data['email'] as Enum$SortEnumType?);
  Enum$SortEnumType? get emailConfirmed =>
      (_$data['emailConfirmed'] as Enum$SortEnumType?);
  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);
  Enum$SortEnumType? get lockoutEnabled =>
      (_$data['lockoutEnabled'] as Enum$SortEnumType?);
  Enum$SortEnumType? get lockoutEnd =>
      (_$data['lockoutEnd'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get normalizedEmail =>
      (_$data['normalizedEmail'] as Enum$SortEnumType?);
  Enum$SortEnumType? get normalizedUserName =>
      (_$data['normalizedUserName'] as Enum$SortEnumType?);
  Enum$SortEnumType? get passwordHash =>
      (_$data['passwordHash'] as Enum$SortEnumType?);
  Enum$SortEnumType? get phoneNumber =>
      (_$data['phoneNumber'] as Enum$SortEnumType?);
  Enum$SortEnumType? get phoneNumberConfirmed =>
      (_$data['phoneNumberConfirmed'] as Enum$SortEnumType?);
  Enum$SortEnumType? get securityStamp =>
      (_$data['securityStamp'] as Enum$SortEnumType?);
  Enum$SortEnumType? get twoFactorEnabled =>
      (_$data['twoFactorEnabled'] as Enum$SortEnumType?);
  Enum$SortEnumType? get userName => (_$data['userName'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessFailedCount')) {
      final l$accessFailedCount = accessFailedCount;
      result$data['accessFailedCount'] = l$accessFailedCount == null
          ? null
          : toJson$Enum$SortEnumType(l$accessFailedCount);
    }
    if (_$data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = concurrencyStamp;
      result$data['concurrencyStamp'] = l$concurrencyStamp == null
          ? null
          : toJson$Enum$SortEnumType(l$concurrencyStamp);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] =
          l$email == null ? null : toJson$Enum$SortEnumType(l$email);
    }
    if (_$data.containsKey('emailConfirmed')) {
      final l$emailConfirmed = emailConfirmed;
      result$data['emailConfirmed'] = l$emailConfirmed == null
          ? null
          : toJson$Enum$SortEnumType(l$emailConfirmed);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('lockoutEnabled')) {
      final l$lockoutEnabled = lockoutEnabled;
      result$data['lockoutEnabled'] = l$lockoutEnabled == null
          ? null
          : toJson$Enum$SortEnumType(l$lockoutEnabled);
    }
    if (_$data.containsKey('lockoutEnd')) {
      final l$lockoutEnd = lockoutEnd;
      result$data['lockoutEnd'] =
          l$lockoutEnd == null ? null : toJson$Enum$SortEnumType(l$lockoutEnd);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('normalizedEmail')) {
      final l$normalizedEmail = normalizedEmail;
      result$data['normalizedEmail'] = l$normalizedEmail == null
          ? null
          : toJson$Enum$SortEnumType(l$normalizedEmail);
    }
    if (_$data.containsKey('normalizedUserName')) {
      final l$normalizedUserName = normalizedUserName;
      result$data['normalizedUserName'] = l$normalizedUserName == null
          ? null
          : toJson$Enum$SortEnumType(l$normalizedUserName);
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : toJson$Enum$SortEnumType(l$passwordHash);
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : toJson$Enum$SortEnumType(l$phoneNumber);
    }
    if (_$data.containsKey('phoneNumberConfirmed')) {
      final l$phoneNumberConfirmed = phoneNumberConfirmed;
      result$data['phoneNumberConfirmed'] = l$phoneNumberConfirmed == null
          ? null
          : toJson$Enum$SortEnumType(l$phoneNumberConfirmed);
    }
    if (_$data.containsKey('securityStamp')) {
      final l$securityStamp = securityStamp;
      result$data['securityStamp'] = l$securityStamp == null
          ? null
          : toJson$Enum$SortEnumType(l$securityStamp);
    }
    if (_$data.containsKey('twoFactorEnabled')) {
      final l$twoFactorEnabled = twoFactorEnabled;
      result$data['twoFactorEnabled'] = l$twoFactorEnabled == null
          ? null
          : toJson$Enum$SortEnumType(l$twoFactorEnabled);
    }
    if (_$data.containsKey('userName')) {
      final l$userName = userName;
      result$data['userName'] =
          l$userName == null ? null : toJson$Enum$SortEnumType(l$userName);
    }
    return result$data;
  }

  CopyWith$Input$ApplicationUserSortInput<Input$ApplicationUserSortInput>
      get copyWith => CopyWith$Input$ApplicationUserSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApplicationUserSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessFailedCount = accessFailedCount;
    final lOther$accessFailedCount = other.accessFailedCount;
    if (_$data.containsKey('accessFailedCount') !=
        other._$data.containsKey('accessFailedCount')) {
      return false;
    }
    if (l$accessFailedCount != lOther$accessFailedCount) {
      return false;
    }
    final l$concurrencyStamp = concurrencyStamp;
    final lOther$concurrencyStamp = other.concurrencyStamp;
    if (_$data.containsKey('concurrencyStamp') !=
        other._$data.containsKey('concurrencyStamp')) {
      return false;
    }
    if (l$concurrencyStamp != lOther$concurrencyStamp) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailConfirmed = emailConfirmed;
    final lOther$emailConfirmed = other.emailConfirmed;
    if (_$data.containsKey('emailConfirmed') !=
        other._$data.containsKey('emailConfirmed')) {
      return false;
    }
    if (l$emailConfirmed != lOther$emailConfirmed) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$lockoutEnabled = lockoutEnabled;
    final lOther$lockoutEnabled = other.lockoutEnabled;
    if (_$data.containsKey('lockoutEnabled') !=
        other._$data.containsKey('lockoutEnabled')) {
      return false;
    }
    if (l$lockoutEnabled != lOther$lockoutEnabled) {
      return false;
    }
    final l$lockoutEnd = lockoutEnd;
    final lOther$lockoutEnd = other.lockoutEnd;
    if (_$data.containsKey('lockoutEnd') !=
        other._$data.containsKey('lockoutEnd')) {
      return false;
    }
    if (l$lockoutEnd != lOther$lockoutEnd) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$normalizedEmail = normalizedEmail;
    final lOther$normalizedEmail = other.normalizedEmail;
    if (_$data.containsKey('normalizedEmail') !=
        other._$data.containsKey('normalizedEmail')) {
      return false;
    }
    if (l$normalizedEmail != lOther$normalizedEmail) {
      return false;
    }
    final l$normalizedUserName = normalizedUserName;
    final lOther$normalizedUserName = other.normalizedUserName;
    if (_$data.containsKey('normalizedUserName') !=
        other._$data.containsKey('normalizedUserName')) {
      return false;
    }
    if (l$normalizedUserName != lOther$normalizedUserName) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberConfirmed = phoneNumberConfirmed;
    final lOther$phoneNumberConfirmed = other.phoneNumberConfirmed;
    if (_$data.containsKey('phoneNumberConfirmed') !=
        other._$data.containsKey('phoneNumberConfirmed')) {
      return false;
    }
    if (l$phoneNumberConfirmed != lOther$phoneNumberConfirmed) {
      return false;
    }
    final l$securityStamp = securityStamp;
    final lOther$securityStamp = other.securityStamp;
    if (_$data.containsKey('securityStamp') !=
        other._$data.containsKey('securityStamp')) {
      return false;
    }
    if (l$securityStamp != lOther$securityStamp) {
      return false;
    }
    final l$twoFactorEnabled = twoFactorEnabled;
    final lOther$twoFactorEnabled = other.twoFactorEnabled;
    if (_$data.containsKey('twoFactorEnabled') !=
        other._$data.containsKey('twoFactorEnabled')) {
      return false;
    }
    if (l$twoFactorEnabled != lOther$twoFactorEnabled) {
      return false;
    }
    final l$userName = userName;
    final lOther$userName = other.userName;
    if (_$data.containsKey('userName') !=
        other._$data.containsKey('userName')) {
      return false;
    }
    if (l$userName != lOther$userName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessFailedCount = accessFailedCount;
    final l$concurrencyStamp = concurrencyStamp;
    final l$email = email;
    final l$emailConfirmed = emailConfirmed;
    final l$id = id;
    final l$lockoutEnabled = lockoutEnabled;
    final l$lockoutEnd = lockoutEnd;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$normalizedEmail = normalizedEmail;
    final l$normalizedUserName = normalizedUserName;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberConfirmed = phoneNumberConfirmed;
    final l$securityStamp = securityStamp;
    final l$twoFactorEnabled = twoFactorEnabled;
    final l$userName = userName;
    return Object.hashAll([
      _$data.containsKey('accessFailedCount') ? l$accessFailedCount : const {},
      _$data.containsKey('concurrencyStamp') ? l$concurrencyStamp : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailConfirmed') ? l$emailConfirmed : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('lockoutEnabled') ? l$lockoutEnabled : const {},
      _$data.containsKey('lockoutEnd') ? l$lockoutEnd : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('normalizedEmail') ? l$normalizedEmail : const {},
      _$data.containsKey('normalizedUserName')
          ? l$normalizedUserName
          : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberConfirmed')
          ? l$phoneNumberConfirmed
          : const {},
      _$data.containsKey('securityStamp') ? l$securityStamp : const {},
      _$data.containsKey('twoFactorEnabled') ? l$twoFactorEnabled : const {},
      _$data.containsKey('userName') ? l$userName : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApplicationUserSortInput<TRes> {
  factory CopyWith$Input$ApplicationUserSortInput(
    Input$ApplicationUserSortInput instance,
    TRes Function(Input$ApplicationUserSortInput) then,
  ) = _CopyWithImpl$Input$ApplicationUserSortInput;

  factory CopyWith$Input$ApplicationUserSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApplicationUserSortInput;

  TRes call({
    Enum$SortEnumType? accessFailedCount,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? email,
    Enum$SortEnumType? emailConfirmed,
    Enum$SortEnumType? id,
    Enum$SortEnumType? lockoutEnabled,
    Enum$SortEnumType? lockoutEnd,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? normalizedEmail,
    Enum$SortEnumType? normalizedUserName,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? phoneNumberConfirmed,
    Enum$SortEnumType? securityStamp,
    Enum$SortEnumType? twoFactorEnabled,
    Enum$SortEnumType? userName,
  });
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
}

class _CopyWithImpl$Input$ApplicationUserSortInput<TRes>
    implements CopyWith$Input$ApplicationUserSortInput<TRes> {
  _CopyWithImpl$Input$ApplicationUserSortInput(
    this._instance,
    this._then,
  );

  final Input$ApplicationUserSortInput _instance;

  final TRes Function(Input$ApplicationUserSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessFailedCount = _undefined,
    Object? concurrencyStamp = _undefined,
    Object? email = _undefined,
    Object? emailConfirmed = _undefined,
    Object? id = _undefined,
    Object? lockoutEnabled = _undefined,
    Object? lockoutEnd = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? normalizedEmail = _undefined,
    Object? normalizedUserName = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberConfirmed = _undefined,
    Object? securityStamp = _undefined,
    Object? twoFactorEnabled = _undefined,
    Object? userName = _undefined,
  }) =>
      _then(Input$ApplicationUserSortInput._({
        ..._instance._$data,
        if (accessFailedCount != _undefined)
          'accessFailedCount': (accessFailedCount as Enum$SortEnumType?),
        if (concurrencyStamp != _undefined)
          'concurrencyStamp': (concurrencyStamp as Enum$SortEnumType?),
        if (email != _undefined) 'email': (email as Enum$SortEnumType?),
        if (emailConfirmed != _undefined)
          'emailConfirmed': (emailConfirmed as Enum$SortEnumType?),
        if (id != _undefined) 'id': (id as Enum$SortEnumType?),
        if (lockoutEnabled != _undefined)
          'lockoutEnabled': (lockoutEnabled as Enum$SortEnumType?),
        if (lockoutEnd != _undefined)
          'lockoutEnd': (lockoutEnd as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (normalizedEmail != _undefined)
          'normalizedEmail': (normalizedEmail as Enum$SortEnumType?),
        if (normalizedUserName != _undefined)
          'normalizedUserName': (normalizedUserName as Enum$SortEnumType?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as Enum$SortEnumType?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as Enum$SortEnumType?),
        if (phoneNumberConfirmed != _undefined)
          'phoneNumberConfirmed': (phoneNumberConfirmed as Enum$SortEnumType?),
        if (securityStamp != _undefined)
          'securityStamp': (securityStamp as Enum$SortEnumType?),
        if (twoFactorEnabled != _undefined)
          'twoFactorEnabled': (twoFactorEnabled as Enum$SortEnumType?),
        if (userName != _undefined)
          'userName': (userName as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }
}

class _CopyWithStubImpl$Input$ApplicationUserSortInput<TRes>
    implements CopyWith$Input$ApplicationUserSortInput<TRes> {
  _CopyWithStubImpl$Input$ApplicationUserSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? accessFailedCount,
    Enum$SortEnumType? concurrencyStamp,
    Enum$SortEnumType? email,
    Enum$SortEnumType? emailConfirmed,
    Enum$SortEnumType? id,
    Enum$SortEnumType? lockoutEnabled,
    Enum$SortEnumType? lockoutEnd,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? normalizedEmail,
    Enum$SortEnumType? normalizedUserName,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? phoneNumberConfirmed,
    Enum$SortEnumType? securityStamp,
    Enum$SortEnumType? twoFactorEnabled,
    Enum$SortEnumType? userName,
  }) =>
      _res;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
}

class Input$AreaFilterInput {
  factory Input$AreaFilterInput({
    List<Input$AreaFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$MunicipalityFilterInput? municipality,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$AreaFilterInput>? or,
    Input$ListFilterInputTypeOfRelativeLocationFilterInput? relativeLocations,
  }) =>
      Input$AreaFilterInput._({
        if (and != null) r'and': and,
        if (areaID != null) r'areaID': areaID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (municipality != null) r'municipality': municipality,
        if (municipalityID != null) r'municipalityID': municipalityID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (relativeLocations != null) r'relativeLocations': relativeLocations,
      });

  Input$AreaFilterInput._(this._$data);

  factory Input$AreaFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$AreaFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('areaID')) {
      final l$areaID = data['areaID'];
      result$data['areaID'] = l$areaID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$areaID as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('municipality')) {
      final l$municipality = data['municipality'];
      result$data['municipality'] = l$municipality == null
          ? null
          : Input$MunicipalityFilterInput.fromJson(
              (l$municipality as Map<String, dynamic>));
    }
    if (data.containsKey('municipalityID')) {
      final l$municipalityID = data['municipalityID'];
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$municipalityID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$AreaFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('relativeLocations')) {
      final l$relativeLocations = data['relativeLocations'];
      result$data['relativeLocations'] = l$relativeLocations == null
          ? null
          : Input$ListFilterInputTypeOfRelativeLocationFilterInput.fromJson(
              (l$relativeLocations as Map<String, dynamic>));
    }
    return Input$AreaFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AreaFilterInput>? get and =>
      (_$data['and'] as List<Input$AreaFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get areaID =>
      (_$data['areaID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$MunicipalityFilterInput? get municipality =>
      (_$data['municipality'] as Input$MunicipalityFilterInput?);
  Input$ComparableInt64OperationFilterInput? get municipalityID =>
      (_$data['municipalityID'] as Input$ComparableInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$AreaFilterInput>? get or =>
      (_$data['or'] as List<Input$AreaFilterInput>?);
  Input$ListFilterInputTypeOfRelativeLocationFilterInput?
      get relativeLocations => (_$data['relativeLocations']
          as Input$ListFilterInputTypeOfRelativeLocationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('areaID')) {
      final l$areaID = areaID;
      result$data['areaID'] = l$areaID?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('municipality')) {
      final l$municipality = municipality;
      result$data['municipality'] = l$municipality?.toJson();
    }
    if (_$data.containsKey('municipalityID')) {
      final l$municipalityID = municipalityID;
      result$data['municipalityID'] = l$municipalityID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('relativeLocations')) {
      final l$relativeLocations = relativeLocations;
      result$data['relativeLocations'] = l$relativeLocations?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AreaFilterInput<Input$AreaFilterInput> get copyWith =>
      CopyWith$Input$AreaFilterInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AreaFilterInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$areaID = areaID;
    final lOther$areaID = other.areaID;
    if (_$data.containsKey('areaID') != other._$data.containsKey('areaID')) {
      return false;
    }
    if (l$areaID != lOther$areaID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$municipality = municipality;
    final lOther$municipality = other.municipality;
    if (_$data.containsKey('municipality') !=
        other._$data.containsKey('municipality')) {
      return false;
    }
    if (l$municipality != lOther$municipality) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (_$data.containsKey('municipalityID') !=
        other._$data.containsKey('municipalityID')) {
      return false;
    }
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$relativeLocations = relativeLocations;
    final lOther$relativeLocations = other.relativeLocations;
    if (_$data.containsKey('relativeLocations') !=
        other._$data.containsKey('relativeLocations')) {
      return false;
    }
    if (l$relativeLocations != lOther$relativeLocations) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$areaID = areaID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$municipality = municipality;
    final l$municipalityID = municipalityID;
    final l$name = name;
    final l$or = or;
    final l$relativeLocations = relativeLocations;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('areaID') ? l$areaID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('municipality') ? l$municipality : const {},
      _$data.containsKey('municipalityID') ? l$municipalityID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('relativeLocations') ? l$relativeLocations : const {},
    ]);
  }
}

abstract class CopyWith$Input$AreaFilterInput<TRes> {
  factory CopyWith$Input$AreaFilterInput(
    Input$AreaFilterInput instance,
    TRes Function(Input$AreaFilterInput) then,
  ) = _CopyWithImpl$Input$AreaFilterInput;

  factory CopyWith$Input$AreaFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AreaFilterInput;

  TRes call({
    List<Input$AreaFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$MunicipalityFilterInput? municipality,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$AreaFilterInput>? or,
    Input$ListFilterInputTypeOfRelativeLocationFilterInput? relativeLocations,
  });
  TRes and(
      Iterable<Input$AreaFilterInput>? Function(
              Iterable<CopyWith$Input$AreaFilterInput<Input$AreaFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$MunicipalityFilterInput<TRes> get municipality;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$AreaFilterInput>? Function(
              Iterable<CopyWith$Input$AreaFilterInput<Input$AreaFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes>
      get relativeLocations;
}

class _CopyWithImpl$Input$AreaFilterInput<TRes>
    implements CopyWith$Input$AreaFilterInput<TRes> {
  _CopyWithImpl$Input$AreaFilterInput(
    this._instance,
    this._then,
  );

  final Input$AreaFilterInput _instance;

  final TRes Function(Input$AreaFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? areaID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? municipality = _undefined,
    Object? municipalityID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? relativeLocations = _undefined,
  }) =>
      _then(Input$AreaFilterInput._({
        ..._instance._$data,
        if (and != _undefined) 'and': (and as List<Input$AreaFilterInput>?),
        if (areaID != _undefined)
          'areaID': (areaID as Input$ComparableInt64OperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (municipality != _undefined)
          'municipality': (municipality as Input$MunicipalityFilterInput?),
        if (municipalityID != _undefined)
          'municipalityID':
              (municipalityID as Input$ComparableInt64OperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$AreaFilterInput>?),
        if (relativeLocations != _undefined)
          'relativeLocations': (relativeLocations
              as Input$ListFilterInputTypeOfRelativeLocationFilterInput?),
      }));
  TRes and(
          Iterable<Input$AreaFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$AreaFilterInput<Input$AreaFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$AreaFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID {
    final local$areaID = _instance.areaID;
    return local$areaID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$areaID, (e) => call(areaID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$MunicipalityFilterInput<TRes> get municipality {
    final local$municipality = _instance.municipality;
    return local$municipality == null
        ? CopyWith$Input$MunicipalityFilterInput.stub(_then(_instance))
        : CopyWith$Input$MunicipalityFilterInput(
            local$municipality, (e) => call(municipality: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID {
    final local$municipalityID = _instance.municipalityID;
    return local$municipalityID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$municipalityID, (e) => call(municipalityID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$AreaFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$AreaFilterInput<Input$AreaFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$AreaFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes>
      get relativeLocations {
    final local$relativeLocations = _instance.relativeLocations;
    return local$relativeLocations == null
        ? CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput(
            local$relativeLocations, (e) => call(relativeLocations: e));
  }
}

class _CopyWithStubImpl$Input$AreaFilterInput<TRes>
    implements CopyWith$Input$AreaFilterInput<TRes> {
  _CopyWithStubImpl$Input$AreaFilterInput(this._res);

  TRes _res;

  call({
    List<Input$AreaFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$MunicipalityFilterInput? municipality,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$AreaFilterInput>? or,
    Input$ListFilterInputTypeOfRelativeLocationFilterInput? relativeLocations,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$MunicipalityFilterInput<TRes> get municipality =>
      CopyWith$Input$MunicipalityFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes>
      get relativeLocations =>
          CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput.stub(
              _res);
}

class Input$AreaSortInput {
  factory Input$AreaSortInput({
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$MunicipalitySortInput? municipality,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
  }) =>
      Input$AreaSortInput._({
        if (areaID != null) r'areaID': areaID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (municipality != null) r'municipality': municipality,
        if (municipalityID != null) r'municipalityID': municipalityID,
        if (name != null) r'name': name,
      });

  Input$AreaSortInput._(this._$data);

  factory Input$AreaSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('areaID')) {
      final l$areaID = data['areaID'];
      result$data['areaID'] = l$areaID == null
          ? null
          : fromJson$Enum$SortEnumType((l$areaID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('municipality')) {
      final l$municipality = data['municipality'];
      result$data['municipality'] = l$municipality == null
          ? null
          : Input$MunicipalitySortInput.fromJson(
              (l$municipality as Map<String, dynamic>));
    }
    if (data.containsKey('municipalityID')) {
      final l$municipalityID = data['municipalityID'];
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : fromJson$Enum$SortEnumType((l$municipalityID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    return Input$AreaSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get areaID => (_$data['areaID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Input$MunicipalitySortInput? get municipality =>
      (_$data['municipality'] as Input$MunicipalitySortInput?);
  Enum$SortEnumType? get municipalityID =>
      (_$data['municipalityID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('areaID')) {
      final l$areaID = areaID;
      result$data['areaID'] =
          l$areaID == null ? null : toJson$Enum$SortEnumType(l$areaID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('municipality')) {
      final l$municipality = municipality;
      result$data['municipality'] = l$municipality?.toJson();
    }
    if (_$data.containsKey('municipalityID')) {
      final l$municipalityID = municipalityID;
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : toJson$Enum$SortEnumType(l$municipalityID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    return result$data;
  }

  CopyWith$Input$AreaSortInput<Input$AreaSortInput> get copyWith =>
      CopyWith$Input$AreaSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AreaSortInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$areaID = areaID;
    final lOther$areaID = other.areaID;
    if (_$data.containsKey('areaID') != other._$data.containsKey('areaID')) {
      return false;
    }
    if (l$areaID != lOther$areaID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$municipality = municipality;
    final lOther$municipality = other.municipality;
    if (_$data.containsKey('municipality') !=
        other._$data.containsKey('municipality')) {
      return false;
    }
    if (l$municipality != lOther$municipality) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (_$data.containsKey('municipalityID') !=
        other._$data.containsKey('municipalityID')) {
      return false;
    }
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$areaID = areaID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$municipality = municipality;
    final l$municipalityID = municipalityID;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('areaID') ? l$areaID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('municipality') ? l$municipality : const {},
      _$data.containsKey('municipalityID') ? l$municipalityID : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$AreaSortInput<TRes> {
  factory CopyWith$Input$AreaSortInput(
    Input$AreaSortInput instance,
    TRes Function(Input$AreaSortInput) then,
  ) = _CopyWithImpl$Input$AreaSortInput;

  factory CopyWith$Input$AreaSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AreaSortInput;

  TRes call({
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$MunicipalitySortInput? municipality,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
  });
  CopyWith$Input$MunicipalitySortInput<TRes> get municipality;
}

class _CopyWithImpl$Input$AreaSortInput<TRes>
    implements CopyWith$Input$AreaSortInput<TRes> {
  _CopyWithImpl$Input$AreaSortInput(
    this._instance,
    this._then,
  );

  final Input$AreaSortInput _instance;

  final TRes Function(Input$AreaSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? areaID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? municipality = _undefined,
    Object? municipalityID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$AreaSortInput._({
        ..._instance._$data,
        if (areaID != _undefined) 'areaID': (areaID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (municipality != _undefined)
          'municipality': (municipality as Input$MunicipalitySortInput?),
        if (municipalityID != _undefined)
          'municipalityID': (municipalityID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      }));
  CopyWith$Input$MunicipalitySortInput<TRes> get municipality {
    final local$municipality = _instance.municipality;
    return local$municipality == null
        ? CopyWith$Input$MunicipalitySortInput.stub(_then(_instance))
        : CopyWith$Input$MunicipalitySortInput(
            local$municipality, (e) => call(municipality: e));
  }
}

class _CopyWithStubImpl$Input$AreaSortInput<TRes>
    implements CopyWith$Input$AreaSortInput<TRes> {
  _CopyWithStubImpl$Input$AreaSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$MunicipalitySortInput? municipality,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
  }) =>
      _res;
  CopyWith$Input$MunicipalitySortInput<TRes> get municipality =>
      CopyWith$Input$MunicipalitySortInput.stub(_res);
}

class Input$BooleanOperationFilterInput {
  factory Input$BooleanOperationFilterInput({
    bool? eq,
    bool? neq,
  }) =>
      Input$BooleanOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (neq != null) r'neq': neq,
      });

  Input$BooleanOperationFilterInput._(this._$data);

  factory Input$BooleanOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as bool?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as bool?);
    }
    return Input$BooleanOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get eq => (_$data['eq'] as bool?);
  bool? get neq => (_$data['neq'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$BooleanOperationFilterInput<Input$BooleanOperationFilterInput>
      get copyWith => CopyWith$Input$BooleanOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BooleanOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$BooleanOperationFilterInput<TRes> {
  factory CopyWith$Input$BooleanOperationFilterInput(
    Input$BooleanOperationFilterInput instance,
    TRes Function(Input$BooleanOperationFilterInput) then,
  ) = _CopyWithImpl$Input$BooleanOperationFilterInput;

  factory CopyWith$Input$BooleanOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BooleanOperationFilterInput;

  TRes call({
    bool? eq,
    bool? neq,
  });
}

class _CopyWithImpl$Input$BooleanOperationFilterInput<TRes>
    implements CopyWith$Input$BooleanOperationFilterInput<TRes> {
  _CopyWithImpl$Input$BooleanOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$BooleanOperationFilterInput _instance;

  final TRes Function(Input$BooleanOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
  }) =>
      _then(Input$BooleanOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as bool?),
        if (neq != _undefined) 'neq': (neq as bool?),
      }));
}

class _CopyWithStubImpl$Input$BooleanOperationFilterInput<TRes>
    implements CopyWith$Input$BooleanOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$BooleanOperationFilterInput(this._res);

  TRes _res;

  call({
    bool? eq,
    bool? neq,
  }) =>
      _res;
}

class Input$CohabitantFilterInput {
  factory Input$CohabitantFilterInput({
    List<Input$CohabitantFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? cohabitantID,
    Input$CohabitantTypeOperationFilterInput? cohabitantType,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$CohabitantFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  }) =>
      Input$CohabitantFilterInput._({
        if (and != null) r'and': and,
        if (cohabitantID != null) r'cohabitantID': cohabitantID,
        if (cohabitantType != null) r'cohabitantType': cohabitantType,
        if (description != null) r'description': description,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (personVariables != null) r'personVariables': personVariables,
      });

  Input$CohabitantFilterInput._(this._$data);

  factory Input$CohabitantFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$CohabitantFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('cohabitantID')) {
      final l$cohabitantID = data['cohabitantID'];
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$cohabitantID as Map<String, dynamic>));
    }
    if (data.containsKey('cohabitantType')) {
      final l$cohabitantType = data['cohabitantType'];
      result$data['cohabitantType'] = l$cohabitantType == null
          ? null
          : Input$CohabitantTypeOperationFilterInput.fromJson(
              (l$cohabitantType as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$CohabitantFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    return Input$CohabitantFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CohabitantFilterInput>? get and =>
      (_$data['and'] as List<Input$CohabitantFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get cohabitantID =>
      (_$data['cohabitantID'] as Input$ComparableInt64OperationFilterInput?);
  Input$CohabitantTypeOperationFilterInput? get cohabitantType =>
      (_$data['cohabitantType'] as Input$CohabitantTypeOperationFilterInput?);
  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$CohabitantFilterInput>? get or =>
      (_$data['or'] as List<Input$CohabitantFilterInput>?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('cohabitantID')) {
      final l$cohabitantID = cohabitantID;
      result$data['cohabitantID'] = l$cohabitantID?.toJson();
    }
    if (_$data.containsKey('cohabitantType')) {
      final l$cohabitantType = cohabitantType;
      result$data['cohabitantType'] = l$cohabitantType?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CohabitantFilterInput<Input$CohabitantFilterInput>
      get copyWith => CopyWith$Input$CohabitantFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CohabitantFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (_$data.containsKey('cohabitantID') !=
        other._$data.containsKey('cohabitantID')) {
      return false;
    }
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$cohabitantType = cohabitantType;
    final lOther$cohabitantType = other.cohabitantType;
    if (_$data.containsKey('cohabitantType') !=
        other._$data.containsKey('cohabitantType')) {
      return false;
    }
    if (l$cohabitantType != lOther$cohabitantType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$cohabitantID = cohabitantID;
    final l$cohabitantType = cohabitantType;
    final l$description = description;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$personVariables = personVariables;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('cohabitantID') ? l$cohabitantID : const {},
      _$data.containsKey('cohabitantType') ? l$cohabitantType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
    ]);
  }
}

abstract class CopyWith$Input$CohabitantFilterInput<TRes> {
  factory CopyWith$Input$CohabitantFilterInput(
    Input$CohabitantFilterInput instance,
    TRes Function(Input$CohabitantFilterInput) then,
  ) = _CopyWithImpl$Input$CohabitantFilterInput;

  factory CopyWith$Input$CohabitantFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CohabitantFilterInput;

  TRes call({
    List<Input$CohabitantFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? cohabitantID,
    Input$CohabitantTypeOperationFilterInput? cohabitantType,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$CohabitantFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  });
  TRes and(
      Iterable<Input$CohabitantFilterInput>? Function(
              Iterable<
                  CopyWith$Input$CohabitantFilterInput<
                      Input$CohabitantFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get cohabitantID;
  CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> get cohabitantType;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$CohabitantFilterInput>? Function(
              Iterable<
                  CopyWith$Input$CohabitantFilterInput<
                      Input$CohabitantFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
}

class _CopyWithImpl$Input$CohabitantFilterInput<TRes>
    implements CopyWith$Input$CohabitantFilterInput<TRes> {
  _CopyWithImpl$Input$CohabitantFilterInput(
    this._instance,
    this._then,
  );

  final Input$CohabitantFilterInput _instance;

  final TRes Function(Input$CohabitantFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? cohabitantID = _undefined,
    Object? cohabitantType = _undefined,
    Object? description = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? personVariables = _undefined,
  }) =>
      _then(Input$CohabitantFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$CohabitantFilterInput>?),
        if (cohabitantID != _undefined)
          'cohabitantID':
              (cohabitantID as Input$ComparableInt64OperationFilterInput?),
        if (cohabitantType != _undefined)
          'cohabitantType':
              (cohabitantType as Input$CohabitantTypeOperationFilterInput?),
        if (description != _undefined)
          'description': (description as Input$StringOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$CohabitantFilterInput>?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
      }));
  TRes and(
          Iterable<Input$CohabitantFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$CohabitantFilterInput<
                          Input$CohabitantFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$CohabitantFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get cohabitantID {
    final local$cohabitantID = _instance.cohabitantID;
    return local$cohabitantID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$cohabitantID, (e) => call(cohabitantID: e));
  }

  CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> get cohabitantType {
    final local$cohabitantType = _instance.cohabitantType;
    return local$cohabitantType == null
        ? CopyWith$Input$CohabitantTypeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$CohabitantTypeOperationFilterInput(
            local$cohabitantType, (e) => call(cohabitantType: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$CohabitantFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$CohabitantFilterInput<
                          Input$CohabitantFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$CohabitantFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }
}

class _CopyWithStubImpl$Input$CohabitantFilterInput<TRes>
    implements CopyWith$Input$CohabitantFilterInput<TRes> {
  _CopyWithStubImpl$Input$CohabitantFilterInput(this._res);

  TRes _res;

  call({
    List<Input$CohabitantFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? cohabitantID,
    Input$CohabitantTypeOperationFilterInput? cohabitantType,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$CohabitantFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get cohabitantID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> get cohabitantType =>
      CopyWith$Input$CohabitantTypeOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
}

class Input$CohabitantSortInput {
  factory Input$CohabitantSortInput({
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? cohabitantType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      Input$CohabitantSortInput._({
        if (cohabitantID != null) r'cohabitantID': cohabitantID,
        if (cohabitantType != null) r'cohabitantType': cohabitantType,
        if (description != null) r'description': description,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
      });

  Input$CohabitantSortInput._(this._$data);

  factory Input$CohabitantSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cohabitantID')) {
      final l$cohabitantID = data['cohabitantID'];
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : fromJson$Enum$SortEnumType((l$cohabitantID as String));
    }
    if (data.containsKey('cohabitantType')) {
      final l$cohabitantType = data['cohabitantType'];
      result$data['cohabitantType'] = l$cohabitantType == null
          ? null
          : fromJson$Enum$SortEnumType((l$cohabitantType as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    return Input$CohabitantSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get cohabitantID =>
      (_$data['cohabitantID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get cohabitantType =>
      (_$data['cohabitantType'] as Enum$SortEnumType?);
  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cohabitantID')) {
      final l$cohabitantID = cohabitantID;
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : toJson$Enum$SortEnumType(l$cohabitantID);
    }
    if (_$data.containsKey('cohabitantType')) {
      final l$cohabitantType = cohabitantType;
      result$data['cohabitantType'] = l$cohabitantType == null
          ? null
          : toJson$Enum$SortEnumType(l$cohabitantType);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    return result$data;
  }

  CopyWith$Input$CohabitantSortInput<Input$CohabitantSortInput> get copyWith =>
      CopyWith$Input$CohabitantSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CohabitantSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (_$data.containsKey('cohabitantID') !=
        other._$data.containsKey('cohabitantID')) {
      return false;
    }
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$cohabitantType = cohabitantType;
    final lOther$cohabitantType = other.cohabitantType;
    if (_$data.containsKey('cohabitantType') !=
        other._$data.containsKey('cohabitantType')) {
      return false;
    }
    if (l$cohabitantType != lOther$cohabitantType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cohabitantID = cohabitantID;
    final l$cohabitantType = cohabitantType;
    final l$description = description;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('cohabitantID') ? l$cohabitantID : const {},
      _$data.containsKey('cohabitantType') ? l$cohabitantType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CohabitantSortInput<TRes> {
  factory CopyWith$Input$CohabitantSortInput(
    Input$CohabitantSortInput instance,
    TRes Function(Input$CohabitantSortInput) then,
  ) = _CopyWithImpl$Input$CohabitantSortInput;

  factory CopyWith$Input$CohabitantSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CohabitantSortInput;

  TRes call({
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? cohabitantType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  });
}

class _CopyWithImpl$Input$CohabitantSortInput<TRes>
    implements CopyWith$Input$CohabitantSortInput<TRes> {
  _CopyWithImpl$Input$CohabitantSortInput(
    this._instance,
    this._then,
  );

  final Input$CohabitantSortInput _instance;

  final TRes Function(Input$CohabitantSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cohabitantID = _undefined,
    Object? cohabitantType = _undefined,
    Object? description = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CohabitantSortInput._({
        ..._instance._$data,
        if (cohabitantID != _undefined)
          'cohabitantID': (cohabitantID as Enum$SortEnumType?),
        if (cohabitantType != _undefined)
          'cohabitantType': (cohabitantType as Enum$SortEnumType?),
        if (description != _undefined)
          'description': (description as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$CohabitantSortInput<TRes>
    implements CopyWith$Input$CohabitantSortInput<TRes> {
  _CopyWithStubImpl$Input$CohabitantSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? cohabitantType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      _res;
}

class Input$CohabitantTypeOperationFilterInput {
  factory Input$CohabitantTypeOperationFilterInput({
    Enum$CohabitantType? eq,
    List<Enum$CohabitantType>? $in,
    Enum$CohabitantType? neq,
    List<Enum$CohabitantType>? nin,
  }) =>
      Input$CohabitantTypeOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
      });

  Input$CohabitantTypeOperationFilterInput._(this._$data);

  factory Input$CohabitantTypeOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$CohabitantType((l$eq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CohabitantType((e as String)))
          .toList();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CohabitantType((l$neq as String));
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CohabitantType((e as String)))
          .toList();
    }
    return Input$CohabitantTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CohabitantType? get eq => (_$data['eq'] as Enum$CohabitantType?);
  List<Enum$CohabitantType>? get $in =>
      (_$data['in'] as List<Enum$CohabitantType>?);
  Enum$CohabitantType? get neq => (_$data['neq'] as Enum$CohabitantType?);
  List<Enum$CohabitantType>? get nin =>
      (_$data['nin'] as List<Enum$CohabitantType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$CohabitantType(l$eq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$CohabitantType(e)).toList();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] =
          l$neq == null ? null : toJson$Enum$CohabitantType(l$neq);
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] =
          l$nin?.map((e) => toJson$Enum$CohabitantType(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$CohabitantTypeOperationFilterInput<
          Input$CohabitantTypeOperationFilterInput>
      get copyWith => CopyWith$Input$CohabitantTypeOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CohabitantTypeOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$neq = neq;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CohabitantTypeOperationFilterInput(
    Input$CohabitantTypeOperationFilterInput instance,
    TRes Function(Input$CohabitantTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CohabitantTypeOperationFilterInput;

  factory CopyWith$Input$CohabitantTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CohabitantTypeOperationFilterInput;

  TRes call({
    Enum$CohabitantType? eq,
    List<Enum$CohabitantType>? $in,
    Enum$CohabitantType? neq,
    List<Enum$CohabitantType>? nin,
  });
}

class _CopyWithImpl$Input$CohabitantTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CohabitantTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CohabitantTypeOperationFilterInput _instance;

  final TRes Function(Input$CohabitantTypeOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
  }) =>
      _then(Input$CohabitantTypeOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$CohabitantType?),
        if ($in != _undefined) 'in': ($in as List<Enum$CohabitantType>?),
        if (neq != _undefined) 'neq': (neq as Enum$CohabitantType?),
        if (nin != _undefined) 'nin': (nin as List<Enum$CohabitantType>?),
      }));
}

class _CopyWithStubImpl$Input$CohabitantTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CohabitantTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CohabitantTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CohabitantType? eq,
    List<Enum$CohabitantType>? $in,
    Enum$CohabitantType? neq,
    List<Enum$CohabitantType>? nin,
  }) =>
      _res;
}

class Input$ComparableDateTimeOperationFilterInput {
  factory Input$ComparableDateTimeOperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableDateTimeOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableDateTimeOperationFilterInput._(this._$data);

  factory Input$ComparableDateTimeOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableDateTimeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String>? get nin => (_$data['nin'] as List<String>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableDateTimeOperationFilterInput<
          Input$ComparableDateTimeOperationFilterInput>
      get copyWith => CopyWith$Input$ComparableDateTimeOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableDateTimeOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes> {
  factory CopyWith$Input$ComparableDateTimeOperationFilterInput(
    Input$ComparableDateTimeOperationFilterInput instance,
    TRes Function(Input$ComparableDateTimeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableDateTimeOperationFilterInput;

  factory CopyWith$Input$ComparableDateTimeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ComparableDateTimeOperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableDateTimeOperationFilterInput<TRes>
    implements CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableDateTimeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableDateTimeOperationFilterInput _instance;

  final TRes Function(Input$ComparableDateTimeOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableDateTimeOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableDateTimeOperationFilterInput<TRes>
    implements CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableDateTimeOperationFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$ComparableInt32OperationFilterInput {
  factory Input$ComparableInt32OperationFilterInput({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    int? neq,
    int? ngt,
    int? ngte,
    List<int>? nin,
    int? nlt,
    int? nlte,
  }) =>
      Input$ComparableInt32OperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableInt32OperationFilterInput._(this._$data);

  factory Input$ComparableInt32OperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as int?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as int?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as int?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as int?);
    }
    return Input$ComparableInt32OperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get neq => (_$data['neq'] as int?);
  int? get ngt => (_$data['ngt'] as int?);
  int? get ngte => (_$data['ngte'] as int?);
  List<int>? get nin => (_$data['nin'] as List<int>?);
  int? get nlt => (_$data['nlt'] as int?);
  int? get nlte => (_$data['nlte'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableInt32OperationFilterInput<
          Input$ComparableInt32OperationFilterInput>
      get copyWith => CopyWith$Input$ComparableInt32OperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableInt32OperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableInt32OperationFilterInput<TRes> {
  factory CopyWith$Input$ComparableInt32OperationFilterInput(
    Input$ComparableInt32OperationFilterInput instance,
    TRes Function(Input$ComparableInt32OperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableInt32OperationFilterInput;

  factory CopyWith$Input$ComparableInt32OperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ComparableInt32OperationFilterInput;

  TRes call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    int? neq,
    int? ngt,
    int? ngte,
    List<int>? nin,
    int? nlt,
    int? nlte,
  });
}

class _CopyWithImpl$Input$ComparableInt32OperationFilterInput<TRes>
    implements CopyWith$Input$ComparableInt32OperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableInt32OperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableInt32OperationFilterInput _instance;

  final TRes Function(Input$ComparableInt32OperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableInt32OperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (neq != _undefined) 'neq': (neq as int?),
        if (ngt != _undefined) 'ngt': (ngt as int?),
        if (ngte != _undefined) 'ngte': (ngte as int?),
        if (nin != _undefined) 'nin': (nin as List<int>?),
        if (nlt != _undefined) 'nlt': (nlt as int?),
        if (nlte != _undefined) 'nlte': (nlte as int?),
      }));
}

class _CopyWithStubImpl$Input$ComparableInt32OperationFilterInput<TRes>
    implements CopyWith$Input$ComparableInt32OperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableInt32OperationFilterInput(this._res);

  TRes _res;

  call({
    int? eq,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    int? neq,
    int? ngt,
    int? ngte,
    List<int>? nin,
    int? nlt,
    int? nlte,
  }) =>
      _res;
}

class Input$ComparableInt64OperationFilterInput {
  factory Input$ComparableInt64OperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableInt64OperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableInt64OperationFilterInput._(this._$data);

  factory Input$ComparableInt64OperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableInt64OperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String>? get nin => (_$data['nin'] as List<String>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<
          Input$ComparableInt64OperationFilterInput>
      get copyWith => CopyWith$Input$ComparableInt64OperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableInt64OperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableInt64OperationFilterInput<TRes> {
  factory CopyWith$Input$ComparableInt64OperationFilterInput(
    Input$ComparableInt64OperationFilterInput instance,
    TRes Function(Input$ComparableInt64OperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableInt64OperationFilterInput;

  factory CopyWith$Input$ComparableInt64OperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ComparableInt64OperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableInt64OperationFilterInput<TRes>
    implements CopyWith$Input$ComparableInt64OperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableInt64OperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableInt64OperationFilterInput _instance;

  final TRes Function(Input$ComparableInt64OperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableInt64OperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableInt64OperationFilterInput<TRes>
    implements CopyWith$Input$ComparableInt64OperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableInt64OperationFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$ComparableNullableOfDateTimeOffsetOperationFilterInput {
  factory Input$ComparableNullableOfDateTimeOffsetOperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableNullableOfDateTimeOffsetOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableNullableOfDateTimeOffsetOperationFilterInput._(this._$data);

  factory Input$ComparableNullableOfDateTimeOffsetOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableNullableOfDateTimeOffsetOperationFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String?>? get $in => (_$data['in'] as List<String?>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String?>? get nin => (_$data['nin'] as List<String?>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
          Input$ComparableNullableOfDateTimeOffsetOperationFilterInput>
      get copyWith =>
          CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ComparableNullableOfDateTimeOffsetOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
    TRes> {
  factory CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput(
    Input$ComparableNullableOfDateTimeOffsetOperationFilterInput instance,
    TRes Function(Input$ComparableNullableOfDateTimeOffsetOperationFilterInput)
        then,
  ) = _CopyWithImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput;

  factory CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
        TRes>
    implements
        CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
            TRes> {
  _CopyWithImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableNullableOfDateTimeOffsetOperationFilterInput _instance;

  final TRes Function(
      Input$ComparableNullableOfDateTimeOffsetOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableNullableOfDateTimeOffsetOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String?>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String?>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
        TRes>
    implements
        CopyWith$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOffsetOperationFilterInput(
      this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$ComparableNullableOfDateTimeOperationFilterInput {
  factory Input$ComparableNullableOfDateTimeOperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableNullableOfDateTimeOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableNullableOfDateTimeOperationFilterInput._(this._$data);

  factory Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableNullableOfDateTimeOperationFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String?>? get $in => (_$data['in'] as List<String?>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String?>? get nin => (_$data['nin'] as List<String?>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<
          Input$ComparableNullableOfDateTimeOperationFilterInput>
      get copyWith =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableNullableOfDateTimeOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<
    TRes> {
  factory CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
    Input$ComparableNullableOfDateTimeOperationFilterInput instance,
    TRes Function(Input$ComparableNullableOfDateTimeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableNullableOfDateTimeOperationFilterInput;

  factory CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
    implements
        CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableNullableOfDateTimeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableNullableOfDateTimeOperationFilterInput _instance;

  final TRes Function(Input$ComparableNullableOfDateTimeOperationFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableNullableOfDateTimeOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String?>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String?>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOperationFilterInput<
        TRes>
    implements
        CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableNullableOfDateTimeOperationFilterInput(
      this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$ComparableNullableOfDecimalOperationFilterInput {
  factory Input$ComparableNullableOfDecimalOperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableNullableOfDecimalOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableNullableOfDecimalOperationFilterInput._(this._$data);

  factory Input$ComparableNullableOfDecimalOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableNullableOfDecimalOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String?>? get $in => (_$data['in'] as List<String?>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String?>? get nin => (_$data['nin'] as List<String?>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<
          Input$ComparableNullableOfDecimalOperationFilterInput>
      get copyWith =>
          CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableNullableOfDecimalOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<
    TRes> {
  factory CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput(
    Input$ComparableNullableOfDecimalOperationFilterInput instance,
    TRes Function(Input$ComparableNullableOfDecimalOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableNullableOfDecimalOperationFilterInput;

  factory CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ComparableNullableOfDecimalOperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
    implements
        CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableNullableOfDecimalOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableNullableOfDecimalOperationFilterInput _instance;

  final TRes Function(Input$ComparableNullableOfDecimalOperationFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableNullableOfDecimalOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String?>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String?>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableNullableOfDecimalOperationFilterInput<
        TRes>
    implements
        CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableNullableOfDecimalOperationFilterInput(
      this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$ComparableNullableOfInt64OperationFilterInput {
  factory Input$ComparableNullableOfInt64OperationFilterInput({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      Input$ComparableNullableOfInt64OperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (neq != null) r'neq': neq,
        if (ngt != null) r'ngt': ngt,
        if (ngte != null) r'ngte': ngte,
        if (nin != null) r'nin': nin,
        if (nlt != null) r'nlt': nlt,
        if (nlte != null) r'nlte': nlte,
      });

  Input$ComparableNullableOfInt64OperationFilterInput._(this._$data);

  factory Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as String?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as String?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as String?);
    }
    return Input$ComparableNullableOfInt64OperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  List<String?>? get $in => (_$data['in'] as List<String?>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get neq => (_$data['neq'] as String?);
  String? get ngt => (_$data['ngt'] as String?);
  String? get ngte => (_$data['ngte'] as String?);
  List<String?>? get nin => (_$data['nin'] as List<String?>?);
  String? get nlt => (_$data['nlt'] as String?);
  String? get nlte => (_$data['nlte'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<
          Input$ComparableNullableOfInt64OperationFilterInput>
      get copyWith =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComparableNullableOfInt64OperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$neq = neq;
    final l$ngt = ngt;
    final l$ngte = ngte;
    final l$nin = nin;
    final l$nlt = nlt;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<
    TRes> {
  factory CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
    Input$ComparableNullableOfInt64OperationFilterInput instance,
    TRes Function(Input$ComparableNullableOfInt64OperationFilterInput) then,
  ) = _CopyWithImpl$Input$ComparableNullableOfInt64OperationFilterInput;

  factory CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ComparableNullableOfInt64OperationFilterInput;

  TRes call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  });
}

class _CopyWithImpl$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
    implements
        CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes> {
  _CopyWithImpl$Input$ComparableNullableOfInt64OperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ComparableNullableOfInt64OperationFilterInput _instance;

  final TRes Function(Input$ComparableNullableOfInt64OperationFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? neq = _undefined,
    Object? ngt = _undefined,
    Object? ngte = _undefined,
    Object? nin = _undefined,
    Object? nlt = _undefined,
    Object? nlte = _undefined,
  }) =>
      _then(Input$ComparableNullableOfInt64OperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String?>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (ngt != _undefined) 'ngt': (ngt as String?),
        if (ngte != _undefined) 'ngte': (ngte as String?),
        if (nin != _undefined) 'nin': (nin as List<String?>?),
        if (nlt != _undefined) 'nlt': (nlt as String?),
        if (nlte != _undefined) 'nlte': (nlte as String?),
      }));
}

class _CopyWithStubImpl$Input$ComparableNullableOfInt64OperationFilterInput<
        TRes>
    implements
        CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ComparableNullableOfInt64OperationFilterInput(
      this._res);

  TRes _res;

  call({
    String? eq,
    String? gt,
    String? gte,
    List<String?>? $in,
    String? lt,
    String? lte,
    String? neq,
    String? ngt,
    String? ngte,
    List<String?>? nin,
    String? nlt,
    String? nlte,
  }) =>
      _res;
}

class Input$CreateApplicationInput {
  factory Input$CreateApplicationInput({
    required String aPIKey,
    required bool active,
    required String applicationID,
    required String description,
    required String nombre,
    required String siglas,
  }) =>
      Input$CreateApplicationInput._({
        r'aPIKey': aPIKey,
        r'active': active,
        r'applicationID': applicationID,
        r'description': description,
        r'nombre': nombre,
        r'siglas': siglas,
      });

  Input$CreateApplicationInput._(this._$data);

  factory Input$CreateApplicationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$aPIKey = data['aPIKey'];
    result$data['aPIKey'] = (l$aPIKey as String);
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    final l$applicationID = data['applicationID'];
    result$data['applicationID'] = (l$applicationID as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$nombre = data['nombre'];
    result$data['nombre'] = (l$nombre as String);
    final l$siglas = data['siglas'];
    result$data['siglas'] = (l$siglas as String);
    return Input$CreateApplicationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get aPIKey => (_$data['aPIKey'] as String);
  bool get active => (_$data['active'] as bool);
  String get applicationID => (_$data['applicationID'] as String);
  String get description => (_$data['description'] as String);
  String get nombre => (_$data['nombre'] as String);
  String get siglas => (_$data['siglas'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$aPIKey = aPIKey;
    result$data['aPIKey'] = l$aPIKey;
    final l$active = active;
    result$data['active'] = l$active;
    final l$applicationID = applicationID;
    result$data['applicationID'] = l$applicationID;
    final l$description = description;
    result$data['description'] = l$description;
    final l$nombre = nombre;
    result$data['nombre'] = l$nombre;
    final l$siglas = siglas;
    result$data['siglas'] = l$siglas;
    return result$data;
  }

  CopyWith$Input$CreateApplicationInput<Input$CreateApplicationInput>
      get copyWith => CopyWith$Input$CreateApplicationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateApplicationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$aPIKey = aPIKey;
    final lOther$aPIKey = other.aPIKey;
    if (l$aPIKey != lOther$aPIKey) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$siglas = siglas;
    final lOther$siglas = other.siglas;
    if (l$siglas != lOther$siglas) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$aPIKey = aPIKey;
    final l$active = active;
    final l$applicationID = applicationID;
    final l$description = description;
    final l$nombre = nombre;
    final l$siglas = siglas;
    return Object.hashAll([
      l$aPIKey,
      l$active,
      l$applicationID,
      l$description,
      l$nombre,
      l$siglas,
    ]);
  }
}

abstract class CopyWith$Input$CreateApplicationInput<TRes> {
  factory CopyWith$Input$CreateApplicationInput(
    Input$CreateApplicationInput instance,
    TRes Function(Input$CreateApplicationInput) then,
  ) = _CopyWithImpl$Input$CreateApplicationInput;

  factory CopyWith$Input$CreateApplicationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateApplicationInput;

  TRes call({
    String? aPIKey,
    bool? active,
    String? applicationID,
    String? description,
    String? nombre,
    String? siglas,
  });
}

class _CopyWithImpl$Input$CreateApplicationInput<TRes>
    implements CopyWith$Input$CreateApplicationInput<TRes> {
  _CopyWithImpl$Input$CreateApplicationInput(
    this._instance,
    this._then,
  );

  final Input$CreateApplicationInput _instance;

  final TRes Function(Input$CreateApplicationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? aPIKey = _undefined,
    Object? active = _undefined,
    Object? applicationID = _undefined,
    Object? description = _undefined,
    Object? nombre = _undefined,
    Object? siglas = _undefined,
  }) =>
      _then(Input$CreateApplicationInput._({
        ..._instance._$data,
        if (aPIKey != _undefined && aPIKey != null)
          'aPIKey': (aPIKey as String),
        if (active != _undefined && active != null) 'active': (active as bool),
        if (applicationID != _undefined && applicationID != null)
          'applicationID': (applicationID as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (nombre != _undefined && nombre != null)
          'nombre': (nombre as String),
        if (siglas != _undefined && siglas != null)
          'siglas': (siglas as String),
      }));
}

class _CopyWithStubImpl$Input$CreateApplicationInput<TRes>
    implements CopyWith$Input$CreateApplicationInput<TRes> {
  _CopyWithStubImpl$Input$CreateApplicationInput(this._res);

  TRes _res;

  call({
    String? aPIKey,
    bool? active,
    String? applicationID,
    String? description,
    String? nombre,
    String? siglas,
  }) =>
      _res;
}

class Input$CreateApplicationRoleInput {
  factory Input$CreateApplicationRoleInput({
    String? concurrencyStamp,
    String? id,
    String? name,
    String? normalizedName,
  }) =>
      Input$CreateApplicationRoleInput._({
        if (concurrencyStamp != null) r'concurrencyStamp': concurrencyStamp,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (normalizedName != null) r'normalizedName': normalizedName,
      });

  Input$CreateApplicationRoleInput._(this._$data);

  factory Input$CreateApplicationRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = data['concurrencyStamp'];
      result$data['concurrencyStamp'] = (l$concurrencyStamp as String?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('normalizedName')) {
      final l$normalizedName = data['normalizedName'];
      result$data['normalizedName'] = (l$normalizedName as String?);
    }
    return Input$CreateApplicationRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get concurrencyStamp => (_$data['concurrencyStamp'] as String?);
  String? get id => (_$data['id'] as String?);
  String? get name => (_$data['name'] as String?);
  String? get normalizedName => (_$data['normalizedName'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('concurrencyStamp')) {
      final l$concurrencyStamp = concurrencyStamp;
      result$data['concurrencyStamp'] = l$concurrencyStamp;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('normalizedName')) {
      final l$normalizedName = normalizedName;
      result$data['normalizedName'] = l$normalizedName;
    }
    return result$data;
  }

  CopyWith$Input$CreateApplicationRoleInput<Input$CreateApplicationRoleInput>
      get copyWith => CopyWith$Input$CreateApplicationRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateApplicationRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$concurrencyStamp = concurrencyStamp;
    final lOther$concurrencyStamp = other.concurrencyStamp;
    if (_$data.containsKey('concurrencyStamp') !=
        other._$data.containsKey('concurrencyStamp')) {
      return false;
    }
    if (l$concurrencyStamp != lOther$concurrencyStamp) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$normalizedName = normalizedName;
    final lOther$normalizedName = other.normalizedName;
    if (_$data.containsKey('normalizedName') !=
        other._$data.containsKey('normalizedName')) {
      return false;
    }
    if (l$normalizedName != lOther$normalizedName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$concurrencyStamp = concurrencyStamp;
    final l$id = id;
    final l$name = name;
    final l$normalizedName = normalizedName;
    return Object.hashAll([
      _$data.containsKey('concurrencyStamp') ? l$concurrencyStamp : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('normalizedName') ? l$normalizedName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateApplicationRoleInput<TRes> {
  factory CopyWith$Input$CreateApplicationRoleInput(
    Input$CreateApplicationRoleInput instance,
    TRes Function(Input$CreateApplicationRoleInput) then,
  ) = _CopyWithImpl$Input$CreateApplicationRoleInput;

  factory CopyWith$Input$CreateApplicationRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateApplicationRoleInput;

  TRes call({
    String? concurrencyStamp,
    String? id,
    String? name,
    String? normalizedName,
  });
}

class _CopyWithImpl$Input$CreateApplicationRoleInput<TRes>
    implements CopyWith$Input$CreateApplicationRoleInput<TRes> {
  _CopyWithImpl$Input$CreateApplicationRoleInput(
    this._instance,
    this._then,
  );

  final Input$CreateApplicationRoleInput _instance;

  final TRes Function(Input$CreateApplicationRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? concurrencyStamp = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? normalizedName = _undefined,
  }) =>
      _then(Input$CreateApplicationRoleInput._({
        ..._instance._$data,
        if (concurrencyStamp != _undefined)
          'concurrencyStamp': (concurrencyStamp as String?),
        if (id != _undefined) 'id': (id as String?),
        if (name != _undefined) 'name': (name as String?),
        if (normalizedName != _undefined)
          'normalizedName': (normalizedName as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateApplicationRoleInput<TRes>
    implements CopyWith$Input$CreateApplicationRoleInput<TRes> {
  _CopyWithStubImpl$Input$CreateApplicationRoleInput(this._res);

  TRes _res;

  call({
    String? concurrencyStamp,
    String? id,
    String? name,
    String? normalizedName,
  }) =>
      _res;
}

class Input$CreateAreaInput {
  factory Input$CreateAreaInput({
    required String areaID,
    required String municipalityID,
    required String name,
  }) =>
      Input$CreateAreaInput._({
        r'areaID': areaID,
        r'municipalityID': municipalityID,
        r'name': name,
      });

  Input$CreateAreaInput._(this._$data);

  factory Input$CreateAreaInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$areaID = data['areaID'];
    result$data['areaID'] = (l$areaID as String);
    final l$municipalityID = data['municipalityID'];
    result$data['municipalityID'] = (l$municipalityID as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$CreateAreaInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get areaID => (_$data['areaID'] as String);
  String get municipalityID => (_$data['municipalityID'] as String);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$areaID = areaID;
    result$data['areaID'] = l$areaID;
    final l$municipalityID = municipalityID;
    result$data['municipalityID'] = l$municipalityID;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$CreateAreaInput<Input$CreateAreaInput> get copyWith =>
      CopyWith$Input$CreateAreaInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateAreaInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$areaID = areaID;
    final lOther$areaID = other.areaID;
    if (l$areaID != lOther$areaID) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$areaID = areaID;
    final l$municipalityID = municipalityID;
    final l$name = name;
    return Object.hashAll([
      l$areaID,
      l$municipalityID,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$CreateAreaInput<TRes> {
  factory CopyWith$Input$CreateAreaInput(
    Input$CreateAreaInput instance,
    TRes Function(Input$CreateAreaInput) then,
  ) = _CopyWithImpl$Input$CreateAreaInput;

  factory CopyWith$Input$CreateAreaInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAreaInput;

  TRes call({
    String? areaID,
    String? municipalityID,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateAreaInput<TRes>
    implements CopyWith$Input$CreateAreaInput<TRes> {
  _CopyWithImpl$Input$CreateAreaInput(
    this._instance,
    this._then,
  );

  final Input$CreateAreaInput _instance;

  final TRes Function(Input$CreateAreaInput) _then;

  static const _undefined = {};

  TRes call({
    Object? areaID = _undefined,
    Object? municipalityID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateAreaInput._({
        ..._instance._$data,
        if (areaID != _undefined && areaID != null)
          'areaID': (areaID as String),
        if (municipalityID != _undefined && municipalityID != null)
          'municipalityID': (municipalityID as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$CreateAreaInput<TRes>
    implements CopyWith$Input$CreateAreaInput<TRes> {
  _CopyWithStubImpl$Input$CreateAreaInput(this._res);

  TRes _res;

  call({
    String? areaID,
    String? municipalityID,
    String? name,
  }) =>
      _res;
}

class Input$CreateCohabitantInput {
  factory Input$CreateCohabitantInput({
    required String cohabitantID,
    required Enum$CohabitantType cohabitantType,
    required String description,
    required String name,
  }) =>
      Input$CreateCohabitantInput._({
        r'cohabitantID': cohabitantID,
        r'cohabitantType': cohabitantType,
        r'description': description,
        r'name': name,
      });

  Input$CreateCohabitantInput._(this._$data);

  factory Input$CreateCohabitantInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$cohabitantID = data['cohabitantID'];
    result$data['cohabitantID'] = (l$cohabitantID as String);
    final l$cohabitantType = data['cohabitantType'];
    result$data['cohabitantType'] =
        fromJson$Enum$CohabitantType((l$cohabitantType as String));
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$CreateCohabitantInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get cohabitantID => (_$data['cohabitantID'] as String);
  Enum$CohabitantType get cohabitantType =>
      (_$data['cohabitantType'] as Enum$CohabitantType);
  String get description => (_$data['description'] as String);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$cohabitantID = cohabitantID;
    result$data['cohabitantID'] = l$cohabitantID;
    final l$cohabitantType = cohabitantType;
    result$data['cohabitantType'] =
        toJson$Enum$CohabitantType(l$cohabitantType);
    final l$description = description;
    result$data['description'] = l$description;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$CreateCohabitantInput<Input$CreateCohabitantInput>
      get copyWith => CopyWith$Input$CreateCohabitantInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCohabitantInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$cohabitantType = cohabitantType;
    final lOther$cohabitantType = other.cohabitantType;
    if (l$cohabitantType != lOther$cohabitantType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cohabitantID = cohabitantID;
    final l$cohabitantType = cohabitantType;
    final l$description = description;
    final l$name = name;
    return Object.hashAll([
      l$cohabitantID,
      l$cohabitantType,
      l$description,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$CreateCohabitantInput<TRes> {
  factory CopyWith$Input$CreateCohabitantInput(
    Input$CreateCohabitantInput instance,
    TRes Function(Input$CreateCohabitantInput) then,
  ) = _CopyWithImpl$Input$CreateCohabitantInput;

  factory CopyWith$Input$CreateCohabitantInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCohabitantInput;

  TRes call({
    String? cohabitantID,
    Enum$CohabitantType? cohabitantType,
    String? description,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateCohabitantInput<TRes>
    implements CopyWith$Input$CreateCohabitantInput<TRes> {
  _CopyWithImpl$Input$CreateCohabitantInput(
    this._instance,
    this._then,
  );

  final Input$CreateCohabitantInput _instance;

  final TRes Function(Input$CreateCohabitantInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cohabitantID = _undefined,
    Object? cohabitantType = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateCohabitantInput._({
        ..._instance._$data,
        if (cohabitantID != _undefined && cohabitantID != null)
          'cohabitantID': (cohabitantID as String),
        if (cohabitantType != _undefined && cohabitantType != null)
          'cohabitantType': (cohabitantType as Enum$CohabitantType),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$CreateCohabitantInput<TRes>
    implements CopyWith$Input$CreateCohabitantInput<TRes> {
  _CopyWithStubImpl$Input$CreateCohabitantInput(this._res);

  TRes _res;

  call({
    String? cohabitantID,
    Enum$CohabitantType? cohabitantType,
    String? description,
    String? name,
  }) =>
      _res;
}

class Input$CreateEnumGroupInput {
  factory Input$CreateEnumGroupInput({
    required String enumGroupID,
    String? name,
  }) =>
      Input$CreateEnumGroupInput._({
        r'enumGroupID': enumGroupID,
        if (name != null) r'name': name,
      });

  Input$CreateEnumGroupInput._(this._$data);

  factory Input$CreateEnumGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enumGroupID = data['enumGroupID'];
    result$data['enumGroupID'] = (l$enumGroupID as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$CreateEnumGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enumGroupID => (_$data['enumGroupID'] as String);
  String? get name => (_$data['name'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enumGroupID = enumGroupID;
    result$data['enumGroupID'] = l$enumGroupID;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$CreateEnumGroupInput<Input$CreateEnumGroupInput>
      get copyWith => CopyWith$Input$CreateEnumGroupInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnumGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enumGroupID = enumGroupID;
    final l$name = name;
    return Object.hashAll([
      l$enumGroupID,
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateEnumGroupInput<TRes> {
  factory CopyWith$Input$CreateEnumGroupInput(
    Input$CreateEnumGroupInput instance,
    TRes Function(Input$CreateEnumGroupInput) then,
  ) = _CopyWithImpl$Input$CreateEnumGroupInput;

  factory CopyWith$Input$CreateEnumGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnumGroupInput;

  TRes call({
    String? enumGroupID,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateEnumGroupInput<TRes>
    implements CopyWith$Input$CreateEnumGroupInput<TRes> {
  _CopyWithImpl$Input$CreateEnumGroupInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnumGroupInput _instance;

  final TRes Function(Input$CreateEnumGroupInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enumGroupID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateEnumGroupInput._({
        ..._instance._$data,
        if (enumGroupID != _undefined && enumGroupID != null)
          'enumGroupID': (enumGroupID as String),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateEnumGroupInput<TRes>
    implements CopyWith$Input$CreateEnumGroupInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnumGroupInput(this._res);

  TRes _res;

  call({
    String? enumGroupID,
    String? name,
  }) =>
      _res;
}

class Input$CreateEnumItemInput {
  factory Input$CreateEnumItemInput({
    required String enumGroupID,
    String? name,
  }) =>
      Input$CreateEnumItemInput._({
        r'enumGroupID': enumGroupID,
        if (name != null) r'name': name,
      });

  Input$CreateEnumItemInput._(this._$data);

  factory Input$CreateEnumItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enumGroupID = data['enumGroupID'];
    result$data['enumGroupID'] = (l$enumGroupID as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$CreateEnumItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enumGroupID => (_$data['enumGroupID'] as String);
  String? get name => (_$data['name'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enumGroupID = enumGroupID;
    result$data['enumGroupID'] = l$enumGroupID;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$CreateEnumItemInput<Input$CreateEnumItemInput> get copyWith =>
      CopyWith$Input$CreateEnumItemInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnumItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enumGroupID = enumGroupID;
    final l$name = name;
    return Object.hashAll([
      l$enumGroupID,
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateEnumItemInput<TRes> {
  factory CopyWith$Input$CreateEnumItemInput(
    Input$CreateEnumItemInput instance,
    TRes Function(Input$CreateEnumItemInput) then,
  ) = _CopyWithImpl$Input$CreateEnumItemInput;

  factory CopyWith$Input$CreateEnumItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnumItemInput;

  TRes call({
    String? enumGroupID,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateEnumItemInput<TRes>
    implements CopyWith$Input$CreateEnumItemInput<TRes> {
  _CopyWithImpl$Input$CreateEnumItemInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnumItemInput _instance;

  final TRes Function(Input$CreateEnumItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enumGroupID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateEnumItemInput._({
        ..._instance._$data,
        if (enumGroupID != _undefined && enumGroupID != null)
          'enumGroupID': (enumGroupID as String),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateEnumItemInput<TRes>
    implements CopyWith$Input$CreateEnumItemInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnumItemInput(this._res);

  TRes _res;

  call({
    String? enumGroupID,
    String? name,
  }) =>
      _res;
}

class Input$CreateMunicipalityInput {
  factory Input$CreateMunicipalityInput({
    required String municipalityID,
    required String name,
    required String provinceID,
  }) =>
      Input$CreateMunicipalityInput._({
        r'municipalityID': municipalityID,
        r'name': name,
        r'provinceID': provinceID,
      });

  Input$CreateMunicipalityInput._(this._$data);

  factory Input$CreateMunicipalityInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$municipalityID = data['municipalityID'];
    result$data['municipalityID'] = (l$municipalityID as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$provinceID = data['provinceID'];
    result$data['provinceID'] = (l$provinceID as String);
    return Input$CreateMunicipalityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get municipalityID => (_$data['municipalityID'] as String);
  String get name => (_$data['name'] as String);
  String get provinceID => (_$data['provinceID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$municipalityID = municipalityID;
    result$data['municipalityID'] = l$municipalityID;
    final l$name = name;
    result$data['name'] = l$name;
    final l$provinceID = provinceID;
    result$data['provinceID'] = l$provinceID;
    return result$data;
  }

  CopyWith$Input$CreateMunicipalityInput<Input$CreateMunicipalityInput>
      get copyWith => CopyWith$Input$CreateMunicipalityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateMunicipalityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$municipalityID = municipalityID;
    final l$name = name;
    final l$provinceID = provinceID;
    return Object.hashAll([
      l$municipalityID,
      l$name,
      l$provinceID,
    ]);
  }
}

abstract class CopyWith$Input$CreateMunicipalityInput<TRes> {
  factory CopyWith$Input$CreateMunicipalityInput(
    Input$CreateMunicipalityInput instance,
    TRes Function(Input$CreateMunicipalityInput) then,
  ) = _CopyWithImpl$Input$CreateMunicipalityInput;

  factory CopyWith$Input$CreateMunicipalityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMunicipalityInput;

  TRes call({
    String? municipalityID,
    String? name,
    String? provinceID,
  });
}

class _CopyWithImpl$Input$CreateMunicipalityInput<TRes>
    implements CopyWith$Input$CreateMunicipalityInput<TRes> {
  _CopyWithImpl$Input$CreateMunicipalityInput(
    this._instance,
    this._then,
  );

  final Input$CreateMunicipalityInput _instance;

  final TRes Function(Input$CreateMunicipalityInput) _then;

  static const _undefined = {};

  TRes call({
    Object? municipalityID = _undefined,
    Object? name = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$CreateMunicipalityInput._({
        ..._instance._$data,
        if (municipalityID != _undefined && municipalityID != null)
          'municipalityID': (municipalityID as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (provinceID != _undefined && provinceID != null)
          'provinceID': (provinceID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateMunicipalityInput<TRes>
    implements CopyWith$Input$CreateMunicipalityInput<TRes> {
  _CopyWithStubImpl$Input$CreateMunicipalityInput(this._res);

  TRes _res;

  call({
    String? municipalityID,
    String? name,
    String? provinceID,
  }) =>
      _res;
}

class Input$CreatePersonInput {
  factory Input$CreatePersonInput({
    String? apellidos,
    String? cI,
    String? nombre,
    required String personID,
    String? statusID,
    String? tutorCI,
  }) =>
      Input$CreatePersonInput._({
        if (apellidos != null) r'apellidos': apellidos,
        if (cI != null) r'cI': cI,
        if (nombre != null) r'nombre': nombre,
        r'personID': personID,
        if (statusID != null) r'statusID': statusID,
        if (tutorCI != null) r'tutorCI': tutorCI,
      });

  Input$CreatePersonInput._(this._$data);

  factory Input$CreatePersonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('apellidos')) {
      final l$apellidos = data['apellidos'];
      result$data['apellidos'] = (l$apellidos as String?);
    }
    if (data.containsKey('cI')) {
      final l$cI = data['cI'];
      result$data['cI'] = (l$cI as String?);
    }
    if (data.containsKey('nombre')) {
      final l$nombre = data['nombre'];
      result$data['nombre'] = (l$nombre as String?);
    }
    final l$personID = data['personID'];
    result$data['personID'] = (l$personID as String);
    if (data.containsKey('statusID')) {
      final l$statusID = data['statusID'];
      result$data['statusID'] = (l$statusID as String?);
    }
    if (data.containsKey('tutorCI')) {
      final l$tutorCI = data['tutorCI'];
      result$data['tutorCI'] = (l$tutorCI as String?);
    }
    return Input$CreatePersonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get apellidos => (_$data['apellidos'] as String?);
  String? get cI => (_$data['cI'] as String?);
  String? get nombre => (_$data['nombre'] as String?);
  String get personID => (_$data['personID'] as String);
  String? get statusID => (_$data['statusID'] as String?);
  String? get tutorCI => (_$data['tutorCI'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('apellidos')) {
      final l$apellidos = apellidos;
      result$data['apellidos'] = l$apellidos;
    }
    if (_$data.containsKey('cI')) {
      final l$cI = cI;
      result$data['cI'] = l$cI;
    }
    if (_$data.containsKey('nombre')) {
      final l$nombre = nombre;
      result$data['nombre'] = l$nombre;
    }
    final l$personID = personID;
    result$data['personID'] = l$personID;
    if (_$data.containsKey('statusID')) {
      final l$statusID = statusID;
      result$data['statusID'] = l$statusID;
    }
    if (_$data.containsKey('tutorCI')) {
      final l$tutorCI = tutorCI;
      result$data['tutorCI'] = l$tutorCI;
    }
    return result$data;
  }

  CopyWith$Input$CreatePersonInput<Input$CreatePersonInput> get copyWith =>
      CopyWith$Input$CreatePersonInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreatePersonInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$apellidos = apellidos;
    final lOther$apellidos = other.apellidos;
    if (_$data.containsKey('apellidos') !=
        other._$data.containsKey('apellidos')) {
      return false;
    }
    if (l$apellidos != lOther$apellidos) {
      return false;
    }
    final l$cI = cI;
    final lOther$cI = other.cI;
    if (_$data.containsKey('cI') != other._$data.containsKey('cI')) {
      return false;
    }
    if (l$cI != lOther$cI) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (_$data.containsKey('nombre') != other._$data.containsKey('nombre')) {
      return false;
    }
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$statusID = statusID;
    final lOther$statusID = other.statusID;
    if (_$data.containsKey('statusID') !=
        other._$data.containsKey('statusID')) {
      return false;
    }
    if (l$statusID != lOther$statusID) {
      return false;
    }
    final l$tutorCI = tutorCI;
    final lOther$tutorCI = other.tutorCI;
    if (_$data.containsKey('tutorCI') != other._$data.containsKey('tutorCI')) {
      return false;
    }
    if (l$tutorCI != lOther$tutorCI) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$apellidos = apellidos;
    final l$cI = cI;
    final l$nombre = nombre;
    final l$personID = personID;
    final l$statusID = statusID;
    final l$tutorCI = tutorCI;
    return Object.hashAll([
      _$data.containsKey('apellidos') ? l$apellidos : const {},
      _$data.containsKey('cI') ? l$cI : const {},
      _$data.containsKey('nombre') ? l$nombre : const {},
      l$personID,
      _$data.containsKey('statusID') ? l$statusID : const {},
      _$data.containsKey('tutorCI') ? l$tutorCI : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreatePersonInput<TRes> {
  factory CopyWith$Input$CreatePersonInput(
    Input$CreatePersonInput instance,
    TRes Function(Input$CreatePersonInput) then,
  ) = _CopyWithImpl$Input$CreatePersonInput;

  factory CopyWith$Input$CreatePersonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePersonInput;

  TRes call({
    String? apellidos,
    String? cI,
    String? nombre,
    String? personID,
    String? statusID,
    String? tutorCI,
  });
}

class _CopyWithImpl$Input$CreatePersonInput<TRes>
    implements CopyWith$Input$CreatePersonInput<TRes> {
  _CopyWithImpl$Input$CreatePersonInput(
    this._instance,
    this._then,
  );

  final Input$CreatePersonInput _instance;

  final TRes Function(Input$CreatePersonInput) _then;

  static const _undefined = {};

  TRes call({
    Object? apellidos = _undefined,
    Object? cI = _undefined,
    Object? nombre = _undefined,
    Object? personID = _undefined,
    Object? statusID = _undefined,
    Object? tutorCI = _undefined,
  }) =>
      _then(Input$CreatePersonInput._({
        ..._instance._$data,
        if (apellidos != _undefined) 'apellidos': (apellidos as String?),
        if (cI != _undefined) 'cI': (cI as String?),
        if (nombre != _undefined) 'nombre': (nombre as String?),
        if (personID != _undefined && personID != null)
          'personID': (personID as String),
        if (statusID != _undefined) 'statusID': (statusID as String?),
        if (tutorCI != _undefined) 'tutorCI': (tutorCI as String?),
      }));
}

class _CopyWithStubImpl$Input$CreatePersonInput<TRes>
    implements CopyWith$Input$CreatePersonInput<TRes> {
  _CopyWithStubImpl$Input$CreatePersonInput(this._res);

  TRes _res;

  call({
    String? apellidos,
    String? cI,
    String? nombre,
    String? personID,
    String? statusID,
    String? tutorCI,
  }) =>
      _res;
}

class Input$CreatePersonStatusInput {
  factory Input$CreatePersonStatusInput({
    required String description,
    required String personStatusID,
    required String status,
  }) =>
      Input$CreatePersonStatusInput._({
        r'description': description,
        r'personStatusID': personStatusID,
        r'status': status,
      });

  Input$CreatePersonStatusInput._(this._$data);

  factory Input$CreatePersonStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$personStatusID = data['personStatusID'];
    result$data['personStatusID'] = (l$personStatusID as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$CreatePersonStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get description => (_$data['description'] as String);
  String get personStatusID => (_$data['personStatusID'] as String);
  String get status => (_$data['status'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$description = description;
    result$data['description'] = l$description;
    final l$personStatusID = personStatusID;
    result$data['personStatusID'] = l$personStatusID;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$CreatePersonStatusInput<Input$CreatePersonStatusInput>
      get copyWith => CopyWith$Input$CreatePersonStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreatePersonStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$personStatusID = personStatusID;
    final lOther$personStatusID = other.personStatusID;
    if (l$personStatusID != lOther$personStatusID) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$personStatusID = personStatusID;
    final l$status = status;
    return Object.hashAll([
      l$description,
      l$personStatusID,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$CreatePersonStatusInput<TRes> {
  factory CopyWith$Input$CreatePersonStatusInput(
    Input$CreatePersonStatusInput instance,
    TRes Function(Input$CreatePersonStatusInput) then,
  ) = _CopyWithImpl$Input$CreatePersonStatusInput;

  factory CopyWith$Input$CreatePersonStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePersonStatusInput;

  TRes call({
    String? description,
    String? personStatusID,
    String? status,
  });
}

class _CopyWithImpl$Input$CreatePersonStatusInput<TRes>
    implements CopyWith$Input$CreatePersonStatusInput<TRes> {
  _CopyWithImpl$Input$CreatePersonStatusInput(
    this._instance,
    this._then,
  );

  final Input$CreatePersonStatusInput _instance;

  final TRes Function(Input$CreatePersonStatusInput) _then;

  static const _undefined = {};

  TRes call({
    Object? description = _undefined,
    Object? personStatusID = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CreatePersonStatusInput._({
        ..._instance._$data,
        if (description != _undefined && description != null)
          'description': (description as String),
        if (personStatusID != _undefined && personStatusID != null)
          'personStatusID': (personStatusID as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$CreatePersonStatusInput<TRes>
    implements CopyWith$Input$CreatePersonStatusInput<TRes> {
  _CopyWithStubImpl$Input$CreatePersonStatusInput(this._res);

  TRes _res;

  call({
    String? description,
    String? personStatusID,
    String? status,
  }) =>
      _res;
}

class Input$CreatePersonVariableInput {
  factory Input$CreatePersonVariableInput({
    bool? boolValue,
    String? cohabitantID,
    String? decimalValue,
    String? doubleValue,
    String? enumValue,
    required bool lastValue,
    String? longValue,
    required String personID,
    required String personVariableID,
    String? relativeLocationID,
    String? stringValue,
    required String territoryID,
    required String variableTypeID,
  }) =>
      Input$CreatePersonVariableInput._({
        if (boolValue != null) r'boolValue': boolValue,
        if (cohabitantID != null) r'cohabitantID': cohabitantID,
        if (decimalValue != null) r'decimalValue': decimalValue,
        if (doubleValue != null) r'doubleValue': doubleValue,
        if (enumValue != null) r'enumValue': enumValue,
        r'lastValue': lastValue,
        if (longValue != null) r'longValue': longValue,
        r'personID': personID,
        r'personVariableID': personVariableID,
        if (relativeLocationID != null)
          r'relativeLocationID': relativeLocationID,
        if (stringValue != null) r'stringValue': stringValue,
        r'territoryID': territoryID,
        r'variableTypeID': variableTypeID,
      });

  Input$CreatePersonVariableInput._(this._$data);

  factory Input$CreatePersonVariableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('boolValue')) {
      final l$boolValue = data['boolValue'];
      result$data['boolValue'] = (l$boolValue as bool?);
    }
    if (data.containsKey('cohabitantID')) {
      final l$cohabitantID = data['cohabitantID'];
      result$data['cohabitantID'] = (l$cohabitantID as String?);
    }
    if (data.containsKey('decimalValue')) {
      final l$decimalValue = data['decimalValue'];
      result$data['decimalValue'] = (l$decimalValue as String?);
    }
    if (data.containsKey('doubleValue')) {
      final l$doubleValue = data['doubleValue'];
      result$data['doubleValue'] = (l$doubleValue as String?);
    }
    if (data.containsKey('enumValue')) {
      final l$enumValue = data['enumValue'];
      result$data['enumValue'] = (l$enumValue as String?);
    }
    final l$lastValue = data['lastValue'];
    result$data['lastValue'] = (l$lastValue as bool);
    if (data.containsKey('longValue')) {
      final l$longValue = data['longValue'];
      result$data['longValue'] = (l$longValue as String?);
    }
    final l$personID = data['personID'];
    result$data['personID'] = (l$personID as String);
    final l$personVariableID = data['personVariableID'];
    result$data['personVariableID'] = (l$personVariableID as String);
    if (data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = data['relativeLocationID'];
      result$data['relativeLocationID'] = (l$relativeLocationID as String?);
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = (l$stringValue as String?);
    }
    final l$territoryID = data['territoryID'];
    result$data['territoryID'] = (l$territoryID as String);
    final l$variableTypeID = data['variableTypeID'];
    result$data['variableTypeID'] = (l$variableTypeID as String);
    return Input$CreatePersonVariableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get boolValue => (_$data['boolValue'] as bool?);
  String? get cohabitantID => (_$data['cohabitantID'] as String?);
  String? get decimalValue => (_$data['decimalValue'] as String?);
  String? get doubleValue => (_$data['doubleValue'] as String?);
  String? get enumValue => (_$data['enumValue'] as String?);
  bool get lastValue => (_$data['lastValue'] as bool);
  String? get longValue => (_$data['longValue'] as String?);
  String get personID => (_$data['personID'] as String);
  String get personVariableID => (_$data['personVariableID'] as String);
  String? get relativeLocationID => (_$data['relativeLocationID'] as String?);
  String? get stringValue => (_$data['stringValue'] as String?);
  String get territoryID => (_$data['territoryID'] as String);
  String get variableTypeID => (_$data['variableTypeID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('boolValue')) {
      final l$boolValue = boolValue;
      result$data['boolValue'] = l$boolValue;
    }
    if (_$data.containsKey('cohabitantID')) {
      final l$cohabitantID = cohabitantID;
      result$data['cohabitantID'] = l$cohabitantID;
    }
    if (_$data.containsKey('decimalValue')) {
      final l$decimalValue = decimalValue;
      result$data['decimalValue'] = l$decimalValue;
    }
    if (_$data.containsKey('doubleValue')) {
      final l$doubleValue = doubleValue;
      result$data['doubleValue'] = l$doubleValue;
    }
    if (_$data.containsKey('enumValue')) {
      final l$enumValue = enumValue;
      result$data['enumValue'] = l$enumValue;
    }
    final l$lastValue = lastValue;
    result$data['lastValue'] = l$lastValue;
    if (_$data.containsKey('longValue')) {
      final l$longValue = longValue;
      result$data['longValue'] = l$longValue;
    }
    final l$personID = personID;
    result$data['personID'] = l$personID;
    final l$personVariableID = personVariableID;
    result$data['personVariableID'] = l$personVariableID;
    if (_$data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = relativeLocationID;
      result$data['relativeLocationID'] = l$relativeLocationID;
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue;
    }
    final l$territoryID = territoryID;
    result$data['territoryID'] = l$territoryID;
    final l$variableTypeID = variableTypeID;
    result$data['variableTypeID'] = l$variableTypeID;
    return result$data;
  }

  CopyWith$Input$CreatePersonVariableInput<Input$CreatePersonVariableInput>
      get copyWith => CopyWith$Input$CreatePersonVariableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreatePersonVariableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$boolValue = boolValue;
    final lOther$boolValue = other.boolValue;
    if (_$data.containsKey('boolValue') !=
        other._$data.containsKey('boolValue')) {
      return false;
    }
    if (l$boolValue != lOther$boolValue) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (_$data.containsKey('cohabitantID') !=
        other._$data.containsKey('cohabitantID')) {
      return false;
    }
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$decimalValue = decimalValue;
    final lOther$decimalValue = other.decimalValue;
    if (_$data.containsKey('decimalValue') !=
        other._$data.containsKey('decimalValue')) {
      return false;
    }
    if (l$decimalValue != lOther$decimalValue) {
      return false;
    }
    final l$doubleValue = doubleValue;
    final lOther$doubleValue = other.doubleValue;
    if (_$data.containsKey('doubleValue') !=
        other._$data.containsKey('doubleValue')) {
      return false;
    }
    if (l$doubleValue != lOther$doubleValue) {
      return false;
    }
    final l$enumValue = enumValue;
    final lOther$enumValue = other.enumValue;
    if (_$data.containsKey('enumValue') !=
        other._$data.containsKey('enumValue')) {
      return false;
    }
    if (l$enumValue != lOther$enumValue) {
      return false;
    }
    final l$lastValue = lastValue;
    final lOther$lastValue = other.lastValue;
    if (l$lastValue != lOther$lastValue) {
      return false;
    }
    final l$longValue = longValue;
    final lOther$longValue = other.longValue;
    if (_$data.containsKey('longValue') !=
        other._$data.containsKey('longValue')) {
      return false;
    }
    if (l$longValue != lOther$longValue) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$personVariableID = personVariableID;
    final lOther$personVariableID = other.personVariableID;
    if (l$personVariableID != lOther$personVariableID) {
      return false;
    }
    final l$relativeLocationID = relativeLocationID;
    final lOther$relativeLocationID = other.relativeLocationID;
    if (_$data.containsKey('relativeLocationID') !=
        other._$data.containsKey('relativeLocationID')) {
      return false;
    }
    if (l$relativeLocationID != lOther$relativeLocationID) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$boolValue = boolValue;
    final l$cohabitantID = cohabitantID;
    final l$decimalValue = decimalValue;
    final l$doubleValue = doubleValue;
    final l$enumValue = enumValue;
    final l$lastValue = lastValue;
    final l$longValue = longValue;
    final l$personID = personID;
    final l$personVariableID = personVariableID;
    final l$relativeLocationID = relativeLocationID;
    final l$stringValue = stringValue;
    final l$territoryID = territoryID;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('boolValue') ? l$boolValue : const {},
      _$data.containsKey('cohabitantID') ? l$cohabitantID : const {},
      _$data.containsKey('decimalValue') ? l$decimalValue : const {},
      _$data.containsKey('doubleValue') ? l$doubleValue : const {},
      _$data.containsKey('enumValue') ? l$enumValue : const {},
      l$lastValue,
      _$data.containsKey('longValue') ? l$longValue : const {},
      l$personID,
      l$personVariableID,
      _$data.containsKey('relativeLocationID')
          ? l$relativeLocationID
          : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      l$territoryID,
      l$variableTypeID,
    ]);
  }
}

abstract class CopyWith$Input$CreatePersonVariableInput<TRes> {
  factory CopyWith$Input$CreatePersonVariableInput(
    Input$CreatePersonVariableInput instance,
    TRes Function(Input$CreatePersonVariableInput) then,
  ) = _CopyWithImpl$Input$CreatePersonVariableInput;

  factory CopyWith$Input$CreatePersonVariableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePersonVariableInput;

  TRes call({
    bool? boolValue,
    String? cohabitantID,
    String? decimalValue,
    String? doubleValue,
    String? enumValue,
    bool? lastValue,
    String? longValue,
    String? personID,
    String? personVariableID,
    String? relativeLocationID,
    String? stringValue,
    String? territoryID,
    String? variableTypeID,
  });
}

class _CopyWithImpl$Input$CreatePersonVariableInput<TRes>
    implements CopyWith$Input$CreatePersonVariableInput<TRes> {
  _CopyWithImpl$Input$CreatePersonVariableInput(
    this._instance,
    this._then,
  );

  final Input$CreatePersonVariableInput _instance;

  final TRes Function(Input$CreatePersonVariableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? boolValue = _undefined,
    Object? cohabitantID = _undefined,
    Object? decimalValue = _undefined,
    Object? doubleValue = _undefined,
    Object? enumValue = _undefined,
    Object? lastValue = _undefined,
    Object? longValue = _undefined,
    Object? personID = _undefined,
    Object? personVariableID = _undefined,
    Object? relativeLocationID = _undefined,
    Object? stringValue = _undefined,
    Object? territoryID = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$CreatePersonVariableInput._({
        ..._instance._$data,
        if (boolValue != _undefined) 'boolValue': (boolValue as bool?),
        if (cohabitantID != _undefined)
          'cohabitantID': (cohabitantID as String?),
        if (decimalValue != _undefined)
          'decimalValue': (decimalValue as String?),
        if (doubleValue != _undefined) 'doubleValue': (doubleValue as String?),
        if (enumValue != _undefined) 'enumValue': (enumValue as String?),
        if (lastValue != _undefined && lastValue != null)
          'lastValue': (lastValue as bool),
        if (longValue != _undefined) 'longValue': (longValue as String?),
        if (personID != _undefined && personID != null)
          'personID': (personID as String),
        if (personVariableID != _undefined && personVariableID != null)
          'personVariableID': (personVariableID as String),
        if (relativeLocationID != _undefined)
          'relativeLocationID': (relativeLocationID as String?),
        if (stringValue != _undefined) 'stringValue': (stringValue as String?),
        if (territoryID != _undefined && territoryID != null)
          'territoryID': (territoryID as String),
        if (variableTypeID != _undefined && variableTypeID != null)
          'variableTypeID': (variableTypeID as String),
      }));
}

class _CopyWithStubImpl$Input$CreatePersonVariableInput<TRes>
    implements CopyWith$Input$CreatePersonVariableInput<TRes> {
  _CopyWithStubImpl$Input$CreatePersonVariableInput(this._res);

  TRes _res;

  call({
    bool? boolValue,
    String? cohabitantID,
    String? decimalValue,
    String? doubleValue,
    String? enumValue,
    bool? lastValue,
    String? longValue,
    String? personID,
    String? personVariableID,
    String? relativeLocationID,
    String? stringValue,
    String? territoryID,
    String? variableTypeID,
  }) =>
      _res;
}

class Input$CreateProvinceInput {
  factory Input$CreateProvinceInput({
    required String name,
    required String provinceID,
  }) =>
      Input$CreateProvinceInput._({
        r'name': name,
        r'provinceID': provinceID,
      });

  Input$CreateProvinceInput._(this._$data);

  factory Input$CreateProvinceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$provinceID = data['provinceID'];
    result$data['provinceID'] = (l$provinceID as String);
    return Input$CreateProvinceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get provinceID => (_$data['provinceID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$provinceID = provinceID;
    result$data['provinceID'] = l$provinceID;
    return result$data;
  }

  CopyWith$Input$CreateProvinceInput<Input$CreateProvinceInput> get copyWith =>
      CopyWith$Input$CreateProvinceInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProvinceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$provinceID = provinceID;
    return Object.hashAll([
      l$name,
      l$provinceID,
    ]);
  }
}

abstract class CopyWith$Input$CreateProvinceInput<TRes> {
  factory CopyWith$Input$CreateProvinceInput(
    Input$CreateProvinceInput instance,
    TRes Function(Input$CreateProvinceInput) then,
  ) = _CopyWithImpl$Input$CreateProvinceInput;

  factory CopyWith$Input$CreateProvinceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProvinceInput;

  TRes call({
    String? name,
    String? provinceID,
  });
}

class _CopyWithImpl$Input$CreateProvinceInput<TRes>
    implements CopyWith$Input$CreateProvinceInput<TRes> {
  _CopyWithImpl$Input$CreateProvinceInput(
    this._instance,
    this._then,
  );

  final Input$CreateProvinceInput _instance;

  final TRes Function(Input$CreateProvinceInput) _then;

  static const _undefined = {};

  TRes call({
    Object? name = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$CreateProvinceInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (provinceID != _undefined && provinceID != null)
          'provinceID': (provinceID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateProvinceInput<TRes>
    implements CopyWith$Input$CreateProvinceInput<TRes> {
  _CopyWithStubImpl$Input$CreateProvinceInput(this._res);

  TRes _res;

  call({
    String? name,
    String? provinceID,
  }) =>
      _res;
}

class Input$CreateRolePermissionInput {
  factory Input$CreateRolePermissionInput({
    required Enum$Permission permission,
    required String roleID,
  }) =>
      Input$CreateRolePermissionInput._({
        r'permission': permission,
        r'roleID': roleID,
      });

  Input$CreateRolePermissionInput._(this._$data);

  factory Input$CreateRolePermissionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$permission = data['permission'];
    result$data['permission'] =
        fromJson$Enum$Permission((l$permission as String));
    final l$roleID = data['roleID'];
    result$data['roleID'] = (l$roleID as String);
    return Input$CreateRolePermissionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$Permission get permission => (_$data['permission'] as Enum$Permission);
  String get roleID => (_$data['roleID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$permission = permission;
    result$data['permission'] = toJson$Enum$Permission(l$permission);
    final l$roleID = roleID;
    result$data['roleID'] = l$roleID;
    return result$data;
  }

  CopyWith$Input$CreateRolePermissionInput<Input$CreateRolePermissionInput>
      get copyWith => CopyWith$Input$CreateRolePermissionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRolePermissionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (l$permission != lOther$permission) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (l$roleID != lOther$roleID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$permission = permission;
    final l$roleID = roleID;
    return Object.hashAll([
      l$permission,
      l$roleID,
    ]);
  }
}

abstract class CopyWith$Input$CreateRolePermissionInput<TRes> {
  factory CopyWith$Input$CreateRolePermissionInput(
    Input$CreateRolePermissionInput instance,
    TRes Function(Input$CreateRolePermissionInput) then,
  ) = _CopyWithImpl$Input$CreateRolePermissionInput;

  factory CopyWith$Input$CreateRolePermissionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRolePermissionInput;

  TRes call({
    Enum$Permission? permission,
    String? roleID,
  });
}

class _CopyWithImpl$Input$CreateRolePermissionInput<TRes>
    implements CopyWith$Input$CreateRolePermissionInput<TRes> {
  _CopyWithImpl$Input$CreateRolePermissionInput(
    this._instance,
    this._then,
  );

  final Input$CreateRolePermissionInput _instance;

  final TRes Function(Input$CreateRolePermissionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? permission = _undefined,
    Object? roleID = _undefined,
  }) =>
      _then(Input$CreateRolePermissionInput._({
        ..._instance._$data,
        if (permission != _undefined && permission != null)
          'permission': (permission as Enum$Permission),
        if (roleID != _undefined && roleID != null)
          'roleID': (roleID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateRolePermissionInput<TRes>
    implements CopyWith$Input$CreateRolePermissionInput<TRes> {
  _CopyWithStubImpl$Input$CreateRolePermissionInput(this._res);

  TRes _res;

  call({
    Enum$Permission? permission,
    String? roleID,
  }) =>
      _res;
}

class Input$CreateSectionInput {
  factory Input$CreateSectionInput({
    required String name,
    required String sectionID,
  }) =>
      Input$CreateSectionInput._({
        r'name': name,
        r'sectionID': sectionID,
      });

  Input$CreateSectionInput._(this._$data);

  factory Input$CreateSectionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$sectionID = data['sectionID'];
    result$data['sectionID'] = (l$sectionID as String);
    return Input$CreateSectionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get sectionID => (_$data['sectionID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$sectionID = sectionID;
    result$data['sectionID'] = l$sectionID;
    return result$data;
  }

  CopyWith$Input$CreateSectionInput<Input$CreateSectionInput> get copyWith =>
      CopyWith$Input$CreateSectionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSectionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$sectionID = sectionID;
    return Object.hashAll([
      l$name,
      l$sectionID,
    ]);
  }
}

abstract class CopyWith$Input$CreateSectionInput<TRes> {
  factory CopyWith$Input$CreateSectionInput(
    Input$CreateSectionInput instance,
    TRes Function(Input$CreateSectionInput) then,
  ) = _CopyWithImpl$Input$CreateSectionInput;

  factory CopyWith$Input$CreateSectionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSectionInput;

  TRes call({
    String? name,
    String? sectionID,
  });
}

class _CopyWithImpl$Input$CreateSectionInput<TRes>
    implements CopyWith$Input$CreateSectionInput<TRes> {
  _CopyWithImpl$Input$CreateSectionInput(
    this._instance,
    this._then,
  );

  final Input$CreateSectionInput _instance;

  final TRes Function(Input$CreateSectionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? name = _undefined,
    Object? sectionID = _undefined,
  }) =>
      _then(Input$CreateSectionInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (sectionID != _undefined && sectionID != null)
          'sectionID': (sectionID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateSectionInput<TRes>
    implements CopyWith$Input$CreateSectionInput<TRes> {
  _CopyWithStubImpl$Input$CreateSectionInput(this._res);

  TRes _res;

  call({
    String? name,
    String? sectionID,
  }) =>
      _res;
}

class Input$CreateTerritoryInput {
  factory Input$CreateTerritoryInput({
    required String name,
    required String sectionID,
    required String territoryID,
  }) =>
      Input$CreateTerritoryInput._({
        r'name': name,
        r'sectionID': sectionID,
        r'territoryID': territoryID,
      });

  Input$CreateTerritoryInput._(this._$data);

  factory Input$CreateTerritoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$sectionID = data['sectionID'];
    result$data['sectionID'] = (l$sectionID as String);
    final l$territoryID = data['territoryID'];
    result$data['territoryID'] = (l$territoryID as String);
    return Input$CreateTerritoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get sectionID => (_$data['sectionID'] as String);
  String get territoryID => (_$data['territoryID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$sectionID = sectionID;
    result$data['sectionID'] = l$sectionID;
    final l$territoryID = territoryID;
    result$data['territoryID'] = l$territoryID;
    return result$data;
  }

  CopyWith$Input$CreateTerritoryInput<Input$CreateTerritoryInput>
      get copyWith => CopyWith$Input$CreateTerritoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTerritoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$sectionID = sectionID;
    final l$territoryID = territoryID;
    return Object.hashAll([
      l$name,
      l$sectionID,
      l$territoryID,
    ]);
  }
}

abstract class CopyWith$Input$CreateTerritoryInput<TRes> {
  factory CopyWith$Input$CreateTerritoryInput(
    Input$CreateTerritoryInput instance,
    TRes Function(Input$CreateTerritoryInput) then,
  ) = _CopyWithImpl$Input$CreateTerritoryInput;

  factory CopyWith$Input$CreateTerritoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTerritoryInput;

  TRes call({
    String? name,
    String? sectionID,
    String? territoryID,
  });
}

class _CopyWithImpl$Input$CreateTerritoryInput<TRes>
    implements CopyWith$Input$CreateTerritoryInput<TRes> {
  _CopyWithImpl$Input$CreateTerritoryInput(
    this._instance,
    this._then,
  );

  final Input$CreateTerritoryInput _instance;

  final TRes Function(Input$CreateTerritoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? name = _undefined,
    Object? sectionID = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$CreateTerritoryInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (sectionID != _undefined && sectionID != null)
          'sectionID': (sectionID as String),
        if (territoryID != _undefined && territoryID != null)
          'territoryID': (territoryID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateTerritoryInput<TRes>
    implements CopyWith$Input$CreateTerritoryInput<TRes> {
  _CopyWithStubImpl$Input$CreateTerritoryInput(this._res);

  TRes _res;

  call({
    String? name,
    String? sectionID,
    String? territoryID,
  }) =>
      _res;
}

class Input$CreateTerritoryRoleInput {
  factory Input$CreateTerritoryRoleInput({
    required String roleID,
    required String territoryID,
  }) =>
      Input$CreateTerritoryRoleInput._({
        r'roleID': roleID,
        r'territoryID': territoryID,
      });

  Input$CreateTerritoryRoleInput._(this._$data);

  factory Input$CreateTerritoryRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$roleID = data['roleID'];
    result$data['roleID'] = (l$roleID as String);
    final l$territoryID = data['territoryID'];
    result$data['territoryID'] = (l$territoryID as String);
    return Input$CreateTerritoryRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get roleID => (_$data['roleID'] as String);
  String get territoryID => (_$data['territoryID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$roleID = roleID;
    result$data['roleID'] = l$roleID;
    final l$territoryID = territoryID;
    result$data['territoryID'] = l$territoryID;
    return result$data;
  }

  CopyWith$Input$CreateTerritoryRoleInput<Input$CreateTerritoryRoleInput>
      get copyWith => CopyWith$Input$CreateTerritoryRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTerritoryRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (l$roleID != lOther$roleID) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$roleID = roleID;
    final l$territoryID = territoryID;
    return Object.hashAll([
      l$roleID,
      l$territoryID,
    ]);
  }
}

abstract class CopyWith$Input$CreateTerritoryRoleInput<TRes> {
  factory CopyWith$Input$CreateTerritoryRoleInput(
    Input$CreateTerritoryRoleInput instance,
    TRes Function(Input$CreateTerritoryRoleInput) then,
  ) = _CopyWithImpl$Input$CreateTerritoryRoleInput;

  factory CopyWith$Input$CreateTerritoryRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTerritoryRoleInput;

  TRes call({
    String? roleID,
    String? territoryID,
  });
}

class _CopyWithImpl$Input$CreateTerritoryRoleInput<TRes>
    implements CopyWith$Input$CreateTerritoryRoleInput<TRes> {
  _CopyWithImpl$Input$CreateTerritoryRoleInput(
    this._instance,
    this._then,
  );

  final Input$CreateTerritoryRoleInput _instance;

  final TRes Function(Input$CreateTerritoryRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? roleID = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$CreateTerritoryRoleInput._({
        ..._instance._$data,
        if (roleID != _undefined && roleID != null)
          'roleID': (roleID as String),
        if (territoryID != _undefined && territoryID != null)
          'territoryID': (territoryID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateTerritoryRoleInput<TRes>
    implements CopyWith$Input$CreateTerritoryRoleInput<TRes> {
  _CopyWithStubImpl$Input$CreateTerritoryRoleInput(this._res);

  TRes _res;

  call({
    String? roleID,
    String? territoryID,
  }) =>
      _res;
}

class Input$CreateUserTerritoryInput {
  factory Input$CreateUserTerritoryInput({
    required bool active,
    required String cargo,
    required String territoryID,
    required String userID,
  }) =>
      Input$CreateUserTerritoryInput._({
        r'active': active,
        r'cargo': cargo,
        r'territoryID': territoryID,
        r'userID': userID,
      });

  Input$CreateUserTerritoryInput._(this._$data);

  factory Input$CreateUserTerritoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    final l$cargo = data['cargo'];
    result$data['cargo'] = (l$cargo as String);
    final l$territoryID = data['territoryID'];
    result$data['territoryID'] = (l$territoryID as String);
    final l$userID = data['userID'];
    result$data['userID'] = (l$userID as String);
    return Input$CreateUserTerritoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get active => (_$data['active'] as bool);
  String get cargo => (_$data['cargo'] as String);
  String get territoryID => (_$data['territoryID'] as String);
  String get userID => (_$data['userID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$active = active;
    result$data['active'] = l$active;
    final l$cargo = cargo;
    result$data['cargo'] = l$cargo;
    final l$territoryID = territoryID;
    result$data['territoryID'] = l$territoryID;
    final l$userID = userID;
    result$data['userID'] = l$userID;
    return result$data;
  }

  CopyWith$Input$CreateUserTerritoryInput<Input$CreateUserTerritoryInput>
      get copyWith => CopyWith$Input$CreateUserTerritoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateUserTerritoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$cargo = cargo;
    final lOther$cargo = other.cargo;
    if (l$cargo != lOther$cargo) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$userID = userID;
    final lOther$userID = other.userID;
    if (l$userID != lOther$userID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$active = active;
    final l$cargo = cargo;
    final l$territoryID = territoryID;
    final l$userID = userID;
    return Object.hashAll([
      l$active,
      l$cargo,
      l$territoryID,
      l$userID,
    ]);
  }
}

abstract class CopyWith$Input$CreateUserTerritoryInput<TRes> {
  factory CopyWith$Input$CreateUserTerritoryInput(
    Input$CreateUserTerritoryInput instance,
    TRes Function(Input$CreateUserTerritoryInput) then,
  ) = _CopyWithImpl$Input$CreateUserTerritoryInput;

  factory CopyWith$Input$CreateUserTerritoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateUserTerritoryInput;

  TRes call({
    bool? active,
    String? cargo,
    String? territoryID,
    String? userID,
  });
}

class _CopyWithImpl$Input$CreateUserTerritoryInput<TRes>
    implements CopyWith$Input$CreateUserTerritoryInput<TRes> {
  _CopyWithImpl$Input$CreateUserTerritoryInput(
    this._instance,
    this._then,
  );

  final Input$CreateUserTerritoryInput _instance;

  final TRes Function(Input$CreateUserTerritoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? active = _undefined,
    Object? cargo = _undefined,
    Object? territoryID = _undefined,
    Object? userID = _undefined,
  }) =>
      _then(Input$CreateUserTerritoryInput._({
        ..._instance._$data,
        if (active != _undefined && active != null) 'active': (active as bool),
        if (cargo != _undefined && cargo != null) 'cargo': (cargo as String),
        if (territoryID != _undefined && territoryID != null)
          'territoryID': (territoryID as String),
        if (userID != _undefined && userID != null)
          'userID': (userID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateUserTerritoryInput<TRes>
    implements CopyWith$Input$CreateUserTerritoryInput<TRes> {
  _CopyWithStubImpl$Input$CreateUserTerritoryInput(this._res);

  TRes _res;

  call({
    bool? active,
    String? cargo,
    String? territoryID,
    String? userID,
  }) =>
      _res;
}

class Input$CreateVariableTypeConditionDependencyInput {
  factory Input$CreateVariableTypeConditionDependencyInput({
    required String dependencyDestinationID,
    required String dependencyOriginID,
  }) =>
      Input$CreateVariableTypeConditionDependencyInput._({
        r'dependencyDestinationID': dependencyDestinationID,
        r'dependencyOriginID': dependencyOriginID,
      });

  Input$CreateVariableTypeConditionDependencyInput._(this._$data);

  factory Input$CreateVariableTypeConditionDependencyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$dependencyDestinationID = data['dependencyDestinationID'];
    result$data['dependencyDestinationID'] =
        (l$dependencyDestinationID as String);
    final l$dependencyOriginID = data['dependencyOriginID'];
    result$data['dependencyOriginID'] = (l$dependencyOriginID as String);
    return Input$CreateVariableTypeConditionDependencyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get dependencyDestinationID =>
      (_$data['dependencyDestinationID'] as String);
  String get dependencyOriginID => (_$data['dependencyOriginID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$dependencyDestinationID = dependencyDestinationID;
    result$data['dependencyDestinationID'] = l$dependencyDestinationID;
    final l$dependencyOriginID = dependencyOriginID;
    result$data['dependencyOriginID'] = l$dependencyOriginID;
    return result$data;
  }

  CopyWith$Input$CreateVariableTypeConditionDependencyInput<
          Input$CreateVariableTypeConditionDependencyInput>
      get copyWith => CopyWith$Input$CreateVariableTypeConditionDependencyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateVariableTypeConditionDependencyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$dependencyDestinationID = dependencyDestinationID;
    final lOther$dependencyDestinationID = other.dependencyDestinationID;
    if (l$dependencyDestinationID != lOther$dependencyDestinationID) {
      return false;
    }
    final l$dependencyOriginID = dependencyOriginID;
    final lOther$dependencyOriginID = other.dependencyOriginID;
    if (l$dependencyOriginID != lOther$dependencyOriginID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$dependencyDestinationID = dependencyDestinationID;
    final l$dependencyOriginID = dependencyOriginID;
    return Object.hashAll([
      l$dependencyDestinationID,
      l$dependencyOriginID,
    ]);
  }
}

abstract class CopyWith$Input$CreateVariableTypeConditionDependencyInput<TRes> {
  factory CopyWith$Input$CreateVariableTypeConditionDependencyInput(
    Input$CreateVariableTypeConditionDependencyInput instance,
    TRes Function(Input$CreateVariableTypeConditionDependencyInput) then,
  ) = _CopyWithImpl$Input$CreateVariableTypeConditionDependencyInput;

  factory CopyWith$Input$CreateVariableTypeConditionDependencyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CreateVariableTypeConditionDependencyInput;

  TRes call({
    String? dependencyDestinationID,
    String? dependencyOriginID,
  });
}

class _CopyWithImpl$Input$CreateVariableTypeConditionDependencyInput<TRes>
    implements CopyWith$Input$CreateVariableTypeConditionDependencyInput<TRes> {
  _CopyWithImpl$Input$CreateVariableTypeConditionDependencyInput(
    this._instance,
    this._then,
  );

  final Input$CreateVariableTypeConditionDependencyInput _instance;

  final TRes Function(Input$CreateVariableTypeConditionDependencyInput) _then;

  static const _undefined = {};

  TRes call({
    Object? dependencyDestinationID = _undefined,
    Object? dependencyOriginID = _undefined,
  }) =>
      _then(Input$CreateVariableTypeConditionDependencyInput._({
        ..._instance._$data,
        if (dependencyDestinationID != _undefined &&
            dependencyDestinationID != null)
          'dependencyDestinationID': (dependencyDestinationID as String),
        if (dependencyOriginID != _undefined && dependencyOriginID != null)
          'dependencyOriginID': (dependencyOriginID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateVariableTypeConditionDependencyInput<TRes>
    implements CopyWith$Input$CreateVariableTypeConditionDependencyInput<TRes> {
  _CopyWithStubImpl$Input$CreateVariableTypeConditionDependencyInput(this._res);

  TRes _res;

  call({
    String? dependencyDestinationID,
    String? dependencyOriginID,
  }) =>
      _res;
}

class Input$CreateVariableTypeInput {
  factory Input$CreateVariableTypeInput({
    required Enum$Accessibility accessibility,
    required String applicationID,
    String? calculationCode,
    String? conditionCode,
    required Enum$DataType dataType,
    required String description,
    String? enumGroupID,
    String? listID,
    required String name,
    required String variableTypeID,
  }) =>
      Input$CreateVariableTypeInput._({
        r'accessibility': accessibility,
        r'applicationID': applicationID,
        if (calculationCode != null) r'calculationCode': calculationCode,
        if (conditionCode != null) r'conditionCode': conditionCode,
        r'dataType': dataType,
        r'description': description,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (listID != null) r'listID': listID,
        r'name': name,
        r'variableTypeID': variableTypeID,
      });

  Input$CreateVariableTypeInput._(this._$data);

  factory Input$CreateVariableTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$accessibility = data['accessibility'];
    result$data['accessibility'] =
        fromJson$Enum$Accessibility((l$accessibility as String));
    final l$applicationID = data['applicationID'];
    result$data['applicationID'] = (l$applicationID as String);
    if (data.containsKey('calculationCode')) {
      final l$calculationCode = data['calculationCode'];
      result$data['calculationCode'] = (l$calculationCode as String?);
    }
    if (data.containsKey('conditionCode')) {
      final l$conditionCode = data['conditionCode'];
      result$data['conditionCode'] = (l$conditionCode as String?);
    }
    final l$dataType = data['dataType'];
    result$data['dataType'] = fromJson$Enum$DataType((l$dataType as String));
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = (l$enumGroupID as String?);
    }
    if (data.containsKey('listID')) {
      final l$listID = data['listID'];
      result$data['listID'] = (l$listID as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$variableTypeID = data['variableTypeID'];
    result$data['variableTypeID'] = (l$variableTypeID as String);
    return Input$CreateVariableTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$Accessibility get accessibility =>
      (_$data['accessibility'] as Enum$Accessibility);
  String get applicationID => (_$data['applicationID'] as String);
  String? get calculationCode => (_$data['calculationCode'] as String?);
  String? get conditionCode => (_$data['conditionCode'] as String?);
  Enum$DataType get dataType => (_$data['dataType'] as Enum$DataType);
  String get description => (_$data['description'] as String);
  String? get enumGroupID => (_$data['enumGroupID'] as String?);
  String? get listID => (_$data['listID'] as String?);
  String get name => (_$data['name'] as String);
  String get variableTypeID => (_$data['variableTypeID'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$accessibility = accessibility;
    result$data['accessibility'] = toJson$Enum$Accessibility(l$accessibility);
    final l$applicationID = applicationID;
    result$data['applicationID'] = l$applicationID;
    if (_$data.containsKey('calculationCode')) {
      final l$calculationCode = calculationCode;
      result$data['calculationCode'] = l$calculationCode;
    }
    if (_$data.containsKey('conditionCode')) {
      final l$conditionCode = conditionCode;
      result$data['conditionCode'] = l$conditionCode;
    }
    final l$dataType = dataType;
    result$data['dataType'] = toJson$Enum$DataType(l$dataType);
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID;
    }
    if (_$data.containsKey('listID')) {
      final l$listID = listID;
      result$data['listID'] = l$listID;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$variableTypeID = variableTypeID;
    result$data['variableTypeID'] = l$variableTypeID;
    return result$data;
  }

  CopyWith$Input$CreateVariableTypeInput<Input$CreateVariableTypeInput>
      get copyWith => CopyWith$Input$CreateVariableTypeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateVariableTypeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessibility = accessibility;
    final lOther$accessibility = other.accessibility;
    if (l$accessibility != lOther$accessibility) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$calculationCode = calculationCode;
    final lOther$calculationCode = other.calculationCode;
    if (_$data.containsKey('calculationCode') !=
        other._$data.containsKey('calculationCode')) {
      return false;
    }
    if (l$calculationCode != lOther$calculationCode) {
      return false;
    }
    final l$conditionCode = conditionCode;
    final lOther$conditionCode = other.conditionCode;
    if (_$data.containsKey('conditionCode') !=
        other._$data.containsKey('conditionCode')) {
      return false;
    }
    if (l$conditionCode != lOther$conditionCode) {
      return false;
    }
    final l$dataType = dataType;
    final lOther$dataType = other.dataType;
    if (l$dataType != lOther$dataType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$listID = listID;
    final lOther$listID = other.listID;
    if (_$data.containsKey('listID') != other._$data.containsKey('listID')) {
      return false;
    }
    if (l$listID != lOther$listID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessibility = accessibility;
    final l$applicationID = applicationID;
    final l$calculationCode = calculationCode;
    final l$conditionCode = conditionCode;
    final l$dataType = dataType;
    final l$description = description;
    final l$enumGroupID = enumGroupID;
    final l$listID = listID;
    final l$name = name;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      l$accessibility,
      l$applicationID,
      _$data.containsKey('calculationCode') ? l$calculationCode : const {},
      _$data.containsKey('conditionCode') ? l$conditionCode : const {},
      l$dataType,
      l$description,
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('listID') ? l$listID : const {},
      l$name,
      l$variableTypeID,
    ]);
  }
}

abstract class CopyWith$Input$CreateVariableTypeInput<TRes> {
  factory CopyWith$Input$CreateVariableTypeInput(
    Input$CreateVariableTypeInput instance,
    TRes Function(Input$CreateVariableTypeInput) then,
  ) = _CopyWithImpl$Input$CreateVariableTypeInput;

  factory CopyWith$Input$CreateVariableTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateVariableTypeInput;

  TRes call({
    Enum$Accessibility? accessibility,
    String? applicationID,
    String? calculationCode,
    String? conditionCode,
    Enum$DataType? dataType,
    String? description,
    String? enumGroupID,
    String? listID,
    String? name,
    String? variableTypeID,
  });
}

class _CopyWithImpl$Input$CreateVariableTypeInput<TRes>
    implements CopyWith$Input$CreateVariableTypeInput<TRes> {
  _CopyWithImpl$Input$CreateVariableTypeInput(
    this._instance,
    this._then,
  );

  final Input$CreateVariableTypeInput _instance;

  final TRes Function(Input$CreateVariableTypeInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessibility = _undefined,
    Object? applicationID = _undefined,
    Object? calculationCode = _undefined,
    Object? conditionCode = _undefined,
    Object? dataType = _undefined,
    Object? description = _undefined,
    Object? enumGroupID = _undefined,
    Object? listID = _undefined,
    Object? name = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$CreateVariableTypeInput._({
        ..._instance._$data,
        if (accessibility != _undefined && accessibility != null)
          'accessibility': (accessibility as Enum$Accessibility),
        if (applicationID != _undefined && applicationID != null)
          'applicationID': (applicationID as String),
        if (calculationCode != _undefined)
          'calculationCode': (calculationCode as String?),
        if (conditionCode != _undefined)
          'conditionCode': (conditionCode as String?),
        if (dataType != _undefined && dataType != null)
          'dataType': (dataType as Enum$DataType),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (enumGroupID != _undefined) 'enumGroupID': (enumGroupID as String?),
        if (listID != _undefined) 'listID': (listID as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (variableTypeID != _undefined && variableTypeID != null)
          'variableTypeID': (variableTypeID as String),
      }));
}

class _CopyWithStubImpl$Input$CreateVariableTypeInput<TRes>
    implements CopyWith$Input$CreateVariableTypeInput<TRes> {
  _CopyWithStubImpl$Input$CreateVariableTypeInput(this._res);

  TRes _res;

  call({
    Enum$Accessibility? accessibility,
    String? applicationID,
    String? calculationCode,
    String? conditionCode,
    Enum$DataType? dataType,
    String? description,
    String? enumGroupID,
    String? listID,
    String? name,
    String? variableTypeID,
  }) =>
      _res;
}

class Input$DataTypeOperationFilterInput {
  factory Input$DataTypeOperationFilterInput({
    Enum$DataType? eq,
    List<Enum$DataType>? $in,
    Enum$DataType? neq,
    List<Enum$DataType>? nin,
  }) =>
      Input$DataTypeOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
      });

  Input$DataTypeOperationFilterInput._(this._$data);

  factory Input$DataTypeOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$DataType((l$eq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DataType((e as String)))
          .toList();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : fromJson$Enum$DataType((l$neq as String));
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DataType((e as String)))
          .toList();
    }
    return Input$DataTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DataType? get eq => (_$data['eq'] as Enum$DataType?);
  List<Enum$DataType>? get $in => (_$data['in'] as List<Enum$DataType>?);
  Enum$DataType? get neq => (_$data['neq'] as Enum$DataType?);
  List<Enum$DataType>? get nin => (_$data['nin'] as List<Enum$DataType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$DataType(l$eq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$DataType(e)).toList();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$DataType(l$neq);
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => toJson$Enum$DataType(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$DataTypeOperationFilterInput<
          Input$DataTypeOperationFilterInput>
      get copyWith => CopyWith$Input$DataTypeOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DataTypeOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$neq = neq;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DataTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$DataTypeOperationFilterInput(
    Input$DataTypeOperationFilterInput instance,
    TRes Function(Input$DataTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$DataTypeOperationFilterInput;

  factory CopyWith$Input$DataTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DataTypeOperationFilterInput;

  TRes call({
    Enum$DataType? eq,
    List<Enum$DataType>? $in,
    Enum$DataType? neq,
    List<Enum$DataType>? nin,
  });
}

class _CopyWithImpl$Input$DataTypeOperationFilterInput<TRes>
    implements CopyWith$Input$DataTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$DataTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$DataTypeOperationFilterInput _instance;

  final TRes Function(Input$DataTypeOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
  }) =>
      _then(Input$DataTypeOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$DataType?),
        if ($in != _undefined) 'in': ($in as List<Enum$DataType>?),
        if (neq != _undefined) 'neq': (neq as Enum$DataType?),
        if (nin != _undefined) 'nin': (nin as List<Enum$DataType>?),
      }));
}

class _CopyWithStubImpl$Input$DataTypeOperationFilterInput<TRes>
    implements CopyWith$Input$DataTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$DataTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$DataType? eq,
    List<Enum$DataType>? $in,
    Enum$DataType? neq,
    List<Enum$DataType>? nin,
  }) =>
      _res;
}

class Input$EnumGroupFilterInput {
  factory Input$EnumGroupFilterInput({
    List<Input$EnumGroupFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ListFilterInputTypeOfEnumItemFilterInput? enumItems,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumGroupFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? variableTypes,
  }) =>
      Input$EnumGroupFilterInput._({
        if (and != null) r'and': and,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (enumItems != null) r'enumItems': enumItems,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (variableTypes != null) r'variableTypes': variableTypes,
      });

  Input$EnumGroupFilterInput._(this._$data);

  factory Input$EnumGroupFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$EnumGroupFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$enumGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('enumItems')) {
      final l$enumItems = data['enumItems'];
      result$data['enumItems'] = l$enumItems == null
          ? null
          : Input$ListFilterInputTypeOfEnumItemFilterInput.fromJson(
              (l$enumItems as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$EnumGroupFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('variableTypes')) {
      final l$variableTypes = data['variableTypes'];
      result$data['variableTypes'] = l$variableTypes == null
          ? null
          : Input$ListFilterInputTypeOfVariableTypeFilterInput.fromJson(
              (l$variableTypes as Map<String, dynamic>));
    }
    return Input$EnumGroupFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EnumGroupFilterInput>? get and =>
      (_$data['and'] as List<Input$EnumGroupFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get enumGroupID =>
      (_$data['enumGroupID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfEnumItemFilterInput? get enumItems =>
      (_$data['enumItems'] as Input$ListFilterInputTypeOfEnumItemFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$EnumGroupFilterInput>? get or =>
      (_$data['or'] as List<Input$EnumGroupFilterInput>?);
  Input$ListFilterInputTypeOfVariableTypeFilterInput? get variableTypes =>
      (_$data['variableTypes']
          as Input$ListFilterInputTypeOfVariableTypeFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID?.toJson();
    }
    if (_$data.containsKey('enumItems')) {
      final l$enumItems = enumItems;
      result$data['enumItems'] = l$enumItems?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('variableTypes')) {
      final l$variableTypes = variableTypes;
      result$data['variableTypes'] = l$variableTypes?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumGroupFilterInput<Input$EnumGroupFilterInput>
      get copyWith => CopyWith$Input$EnumGroupFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumGroupFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$enumItems = enumItems;
    final lOther$enumItems = other.enumItems;
    if (_$data.containsKey('enumItems') !=
        other._$data.containsKey('enumItems')) {
      return false;
    }
    if (l$enumItems != lOther$enumItems) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$variableTypes = variableTypes;
    final lOther$variableTypes = other.variableTypes;
    if (_$data.containsKey('variableTypes') !=
        other._$data.containsKey('variableTypes')) {
      return false;
    }
    if (l$variableTypes != lOther$variableTypes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$enumGroupID = enumGroupID;
    final l$enumItems = enumItems;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$variableTypes = variableTypes;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('enumItems') ? l$enumItems : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('variableTypes') ? l$variableTypes : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumGroupFilterInput<TRes> {
  factory CopyWith$Input$EnumGroupFilterInput(
    Input$EnumGroupFilterInput instance,
    TRes Function(Input$EnumGroupFilterInput) then,
  ) = _CopyWithImpl$Input$EnumGroupFilterInput;

  factory CopyWith$Input$EnumGroupFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumGroupFilterInput;

  TRes call({
    List<Input$EnumGroupFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ListFilterInputTypeOfEnumItemFilterInput? enumItems,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumGroupFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? variableTypes,
  });
  TRes and(
      Iterable<Input$EnumGroupFilterInput>? Function(
              Iterable<
                  CopyWith$Input$EnumGroupFilterInput<
                      Input$EnumGroupFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID;
  CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> get enumItems;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$EnumGroupFilterInput>? Function(
              Iterable<
                  CopyWith$Input$EnumGroupFilterInput<
                      Input$EnumGroupFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get variableTypes;
}

class _CopyWithImpl$Input$EnumGroupFilterInput<TRes>
    implements CopyWith$Input$EnumGroupFilterInput<TRes> {
  _CopyWithImpl$Input$EnumGroupFilterInput(
    this._instance,
    this._then,
  );

  final Input$EnumGroupFilterInput _instance;

  final TRes Function(Input$EnumGroupFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? enumGroupID = _undefined,
    Object? enumItems = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? variableTypes = _undefined,
  }) =>
      _then(Input$EnumGroupFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$EnumGroupFilterInput>?),
        if (enumGroupID != _undefined)
          'enumGroupID':
              (enumGroupID as Input$ComparableInt64OperationFilterInput?),
        if (enumItems != _undefined)
          'enumItems':
              (enumItems as Input$ListFilterInputTypeOfEnumItemFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$EnumGroupFilterInput>?),
        if (variableTypes != _undefined)
          'variableTypes': (variableTypes
              as Input$ListFilterInputTypeOfVariableTypeFilterInput?),
      }));
  TRes and(
          Iterable<Input$EnumGroupFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$EnumGroupFilterInput<
                          Input$EnumGroupFilterInput>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$EnumGroupFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID {
    final local$enumGroupID = _instance.enumGroupID;
    return local$enumGroupID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$enumGroupID, (e) => call(enumGroupID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> get enumItems {
    final local$enumItems = _instance.enumItems;
    return local$enumItems == null
        ? CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput(
            local$enumItems, (e) => call(enumItems: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$EnumGroupFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$EnumGroupFilterInput<
                          Input$EnumGroupFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$EnumGroupFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get variableTypes {
    final local$variableTypes = _instance.variableTypes;
    return local$variableTypes == null
        ? CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput(
            local$variableTypes, (e) => call(variableTypes: e));
  }
}

class _CopyWithStubImpl$Input$EnumGroupFilterInput<TRes>
    implements CopyWith$Input$EnumGroupFilterInput<TRes> {
  _CopyWithStubImpl$Input$EnumGroupFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EnumGroupFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ListFilterInputTypeOfEnumItemFilterInput? enumItems,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumGroupFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? variableTypes,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> get enumItems =>
      CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get variableTypes =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
              _res);
}

class Input$EnumGroupSortInput {
  factory Input$EnumGroupSortInput({
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      Input$EnumGroupSortInput._({
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
      });

  Input$EnumGroupSortInput._(this._$data);

  factory Input$EnumGroupSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : fromJson$Enum$SortEnumType((l$enumGroupID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    return Input$EnumGroupSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get enumGroupID =>
      (_$data['enumGroupID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : toJson$Enum$SortEnumType(l$enumGroupID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    return result$data;
  }

  CopyWith$Input$EnumGroupSortInput<Input$EnumGroupSortInput> get copyWith =>
      CopyWith$Input$EnumGroupSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumGroupSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enumGroupID = enumGroupID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumGroupSortInput<TRes> {
  factory CopyWith$Input$EnumGroupSortInput(
    Input$EnumGroupSortInput instance,
    TRes Function(Input$EnumGroupSortInput) then,
  ) = _CopyWithImpl$Input$EnumGroupSortInput;

  factory CopyWith$Input$EnumGroupSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumGroupSortInput;

  TRes call({
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  });
}

class _CopyWithImpl$Input$EnumGroupSortInput<TRes>
    implements CopyWith$Input$EnumGroupSortInput<TRes> {
  _CopyWithImpl$Input$EnumGroupSortInput(
    this._instance,
    this._then,
  );

  final Input$EnumGroupSortInput _instance;

  final TRes Function(Input$EnumGroupSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enumGroupID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$EnumGroupSortInput._({
        ..._instance._$data,
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$EnumGroupSortInput<TRes>
    implements CopyWith$Input$EnumGroupSortInput<TRes> {
  _CopyWithStubImpl$Input$EnumGroupSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      _res;
}

class Input$EnumItemFilterInput {
  factory Input$EnumItemFilterInput({
    List<Input$EnumItemFilterInput>? and,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumItemFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  }) =>
      Input$EnumItemFilterInput._({
        if (and != null) r'and': and,
        if (enumGroup != null) r'enumGroup': enumGroup,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (personVariables != null) r'personVariables': personVariables,
      });

  Input$EnumItemFilterInput._(this._$data);

  factory Input$EnumItemFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$EnumItemFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('enumGroup')) {
      final l$enumGroup = data['enumGroup'];
      result$data['enumGroup'] = l$enumGroup == null
          ? null
          : Input$EnumGroupFilterInput.fromJson(
              (l$enumGroup as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$enumGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$EnumItemFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    return Input$EnumItemFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EnumItemFilterInput>? get and =>
      (_$data['and'] as List<Input$EnumItemFilterInput>?);
  Input$EnumGroupFilterInput? get enumGroup =>
      (_$data['enumGroup'] as Input$EnumGroupFilterInput?);
  Input$ComparableInt64OperationFilterInput? get enumGroupID =>
      (_$data['enumGroupID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$EnumItemFilterInput>? get or =>
      (_$data['or'] as List<Input$EnumItemFilterInput>?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('enumGroup')) {
      final l$enumGroup = enumGroup;
      result$data['enumGroup'] = l$enumGroup?.toJson();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumItemFilterInput<Input$EnumItemFilterInput> get copyWith =>
      CopyWith$Input$EnumItemFilterInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumItemFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$enumGroup = enumGroup;
    final lOther$enumGroup = other.enumGroup;
    if (_$data.containsKey('enumGroup') !=
        other._$data.containsKey('enumGroup')) {
      return false;
    }
    if (l$enumGroup != lOther$enumGroup) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$enumGroup = enumGroup;
    final l$enumGroupID = enumGroupID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$personVariables = personVariables;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('enumGroup') ? l$enumGroup : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumItemFilterInput<TRes> {
  factory CopyWith$Input$EnumItemFilterInput(
    Input$EnumItemFilterInput instance,
    TRes Function(Input$EnumItemFilterInput) then,
  ) = _CopyWithImpl$Input$EnumItemFilterInput;

  factory CopyWith$Input$EnumItemFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumItemFilterInput;

  TRes call({
    List<Input$EnumItemFilterInput>? and,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumItemFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  });
  TRes and(
      Iterable<Input$EnumItemFilterInput>? Function(
              Iterable<
                  CopyWith$Input$EnumItemFilterInput<
                      Input$EnumItemFilterInput>>?)
          _fn);
  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$EnumItemFilterInput>? Function(
              Iterable<
                  CopyWith$Input$EnumItemFilterInput<
                      Input$EnumItemFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
}

class _CopyWithImpl$Input$EnumItemFilterInput<TRes>
    implements CopyWith$Input$EnumItemFilterInput<TRes> {
  _CopyWithImpl$Input$EnumItemFilterInput(
    this._instance,
    this._then,
  );

  final Input$EnumItemFilterInput _instance;

  final TRes Function(Input$EnumItemFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? enumGroup = _undefined,
    Object? enumGroupID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? personVariables = _undefined,
  }) =>
      _then(Input$EnumItemFilterInput._({
        ..._instance._$data,
        if (and != _undefined) 'and': (and as List<Input$EnumItemFilterInput>?),
        if (enumGroup != _undefined)
          'enumGroup': (enumGroup as Input$EnumGroupFilterInput?),
        if (enumGroupID != _undefined)
          'enumGroupID':
              (enumGroupID as Input$ComparableInt64OperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$EnumItemFilterInput>?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
      }));
  TRes and(
          Iterable<Input$EnumItemFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$EnumItemFilterInput<
                          Input$EnumItemFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$EnumItemFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup {
    final local$enumGroup = _instance.enumGroup;
    return local$enumGroup == null
        ? CopyWith$Input$EnumGroupFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumGroupFilterInput(
            local$enumGroup, (e) => call(enumGroup: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID {
    final local$enumGroupID = _instance.enumGroupID;
    return local$enumGroupID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$enumGroupID, (e) => call(enumGroupID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$EnumItemFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$EnumItemFilterInput<
                          Input$EnumItemFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$EnumItemFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }
}

class _CopyWithStubImpl$Input$EnumItemFilterInput<TRes>
    implements CopyWith$Input$EnumItemFilterInput<TRes> {
  _CopyWithStubImpl$Input$EnumItemFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EnumItemFilterInput>? and,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableInt64OperationFilterInput? enumGroupID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$EnumItemFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup =>
      CopyWith$Input$EnumGroupFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get enumGroupID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
}

class Input$EnumItemSortInput {
  factory Input$EnumItemSortInput({
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      Input$EnumItemSortInput._({
        if (enumGroup != null) r'enumGroup': enumGroup,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
      });

  Input$EnumItemSortInput._(this._$data);

  factory Input$EnumItemSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('enumGroup')) {
      final l$enumGroup = data['enumGroup'];
      result$data['enumGroup'] = l$enumGroup == null
          ? null
          : Input$EnumGroupSortInput.fromJson(
              (l$enumGroup as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : fromJson$Enum$SortEnumType((l$enumGroupID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    return Input$EnumItemSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EnumGroupSortInput? get enumGroup =>
      (_$data['enumGroup'] as Input$EnumGroupSortInput?);
  Enum$SortEnumType? get enumGroupID =>
      (_$data['enumGroupID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('enumGroup')) {
      final l$enumGroup = enumGroup;
      result$data['enumGroup'] = l$enumGroup?.toJson();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : toJson$Enum$SortEnumType(l$enumGroupID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    return result$data;
  }

  CopyWith$Input$EnumItemSortInput<Input$EnumItemSortInput> get copyWith =>
      CopyWith$Input$EnumItemSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumItemSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enumGroup = enumGroup;
    final lOther$enumGroup = other.enumGroup;
    if (_$data.containsKey('enumGroup') !=
        other._$data.containsKey('enumGroup')) {
      return false;
    }
    if (l$enumGroup != lOther$enumGroup) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enumGroup = enumGroup;
    final l$enumGroupID = enumGroupID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('enumGroup') ? l$enumGroup : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumItemSortInput<TRes> {
  factory CopyWith$Input$EnumItemSortInput(
    Input$EnumItemSortInput instance,
    TRes Function(Input$EnumItemSortInput) then,
  ) = _CopyWithImpl$Input$EnumItemSortInput;

  factory CopyWith$Input$EnumItemSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumItemSortInput;

  TRes call({
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  });
  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup;
}

class _CopyWithImpl$Input$EnumItemSortInput<TRes>
    implements CopyWith$Input$EnumItemSortInput<TRes> {
  _CopyWithImpl$Input$EnumItemSortInput(
    this._instance,
    this._then,
  );

  final Input$EnumItemSortInput _instance;

  final TRes Function(Input$EnumItemSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enumGroup = _undefined,
    Object? enumGroupID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$EnumItemSortInput._({
        ..._instance._$data,
        if (enumGroup != _undefined)
          'enumGroup': (enumGroup as Input$EnumGroupSortInput?),
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      }));
  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup {
    final local$enumGroup = _instance.enumGroup;
    return local$enumGroup == null
        ? CopyWith$Input$EnumGroupSortInput.stub(_then(_instance))
        : CopyWith$Input$EnumGroupSortInput(
            local$enumGroup, (e) => call(enumGroup: e));
  }
}

class _CopyWithStubImpl$Input$EnumItemSortInput<TRes>
    implements CopyWith$Input$EnumItemSortInput<TRes> {
  _CopyWithStubImpl$Input$EnumItemSortInput(this._res);

  TRes _res;

  call({
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      _res;
  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup =>
      CopyWith$Input$EnumGroupSortInput.stub(_res);
}

class Input$ListFilterInputTypeOfApplicationFilterInput {
  factory Input$ListFilterInputTypeOfApplicationFilterInput({
    Input$ApplicationFilterInput? all,
    bool? any,
    Input$ApplicationFilterInput? none,
    Input$ApplicationFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfApplicationFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfApplicationFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfApplicationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfApplicationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ApplicationFilterInput? get all =>
      (_$data['all'] as Input$ApplicationFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$ApplicationFilterInput? get none =>
      (_$data['none'] as Input$ApplicationFilterInput?);
  Input$ApplicationFilterInput? get some =>
      (_$data['some'] as Input$ApplicationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<
          Input$ListFilterInputTypeOfApplicationFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfApplicationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput(
    Input$ListFilterInputTypeOfApplicationFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfApplicationFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfApplicationFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationFilterInput;

  TRes call({
    Input$ApplicationFilterInput? all,
    bool? any,
    Input$ApplicationFilterInput? none,
    Input$ApplicationFilterInput? some,
  });
  CopyWith$Input$ApplicationFilterInput<TRes> get all;
  CopyWith$Input$ApplicationFilterInput<TRes> get none;
  CopyWith$Input$ApplicationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfApplicationFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfApplicationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfApplicationFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfApplicationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfApplicationFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$ApplicationFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined) 'none': (none as Input$ApplicationFilterInput?),
        if (some != _undefined) 'some': (some as Input$ApplicationFilterInput?),
      }));
  CopyWith$Input$ApplicationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$ApplicationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$ApplicationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfApplicationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationFilterInput(
      this._res);

  TRes _res;

  call({
    Input$ApplicationFilterInput? all,
    bool? any,
    Input$ApplicationFilterInput? none,
    Input$ApplicationFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$ApplicationFilterInput<TRes> get all =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
  CopyWith$Input$ApplicationFilterInput<TRes> get none =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
  CopyWith$Input$ApplicationFilterInput<TRes> get some =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfApplicationRoleFilterInput {
  factory Input$ListFilterInputTypeOfApplicationRoleFilterInput({
    Input$ApplicationRoleFilterInput? all,
    bool? any,
    Input$ApplicationRoleFilterInput? none,
    Input$ApplicationRoleFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfApplicationRoleFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfApplicationRoleFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfApplicationRoleFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfApplicationRoleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ApplicationRoleFilterInput? get all =>
      (_$data['all'] as Input$ApplicationRoleFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$ApplicationRoleFilterInput? get none =>
      (_$data['none'] as Input$ApplicationRoleFilterInput?);
  Input$ApplicationRoleFilterInput? get some =>
      (_$data['some'] as Input$ApplicationRoleFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<
          Input$ListFilterInputTypeOfApplicationRoleFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfApplicationRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput(
    Input$ListFilterInputTypeOfApplicationRoleFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfApplicationRoleFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput;

  TRes call({
    Input$ApplicationRoleFilterInput? all,
    bool? any,
    Input$ApplicationRoleFilterInput? none,
    Input$ApplicationRoleFilterInput? some,
  });
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get all;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get none;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfApplicationRoleFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfApplicationRoleFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfApplicationRoleFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$ApplicationRoleFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$ApplicationRoleFilterInput?),
        if (some != _undefined)
          'some': (some as Input$ApplicationRoleFilterInput?),
      }));
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$ApplicationRoleFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$ApplicationRoleFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfApplicationRoleFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfApplicationRoleFilterInput(
      this._res);

  TRes _res;

  call({
    Input$ApplicationRoleFilterInput? all,
    bool? any,
    Input$ApplicationRoleFilterInput? none,
    Input$ApplicationRoleFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get all =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get none =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get some =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfAreaFilterInput {
  factory Input$ListFilterInputTypeOfAreaFilterInput({
    Input$AreaFilterInput? all,
    bool? any,
    Input$AreaFilterInput? none,
    Input$AreaFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfAreaFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfAreaFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfAreaFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$AreaFilterInput.fromJson((l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$AreaFilterInput.fromJson((l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$AreaFilterInput.fromJson((l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfAreaFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AreaFilterInput? get all => (_$data['all'] as Input$AreaFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$AreaFilterInput? get none => (_$data['none'] as Input$AreaFilterInput?);
  Input$AreaFilterInput? get some => (_$data['some'] as Input$AreaFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<
          Input$ListFilterInputTypeOfAreaFilterInput>
      get copyWith => CopyWith$Input$ListFilterInputTypeOfAreaFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfAreaFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfAreaFilterInput(
    Input$ListFilterInputTypeOfAreaFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfAreaFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfAreaFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfAreaFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfAreaFilterInput;

  TRes call({
    Input$AreaFilterInput? all,
    bool? any,
    Input$AreaFilterInput? none,
    Input$AreaFilterInput? some,
  });
  CopyWith$Input$AreaFilterInput<TRes> get all;
  CopyWith$Input$AreaFilterInput<TRes> get none;
  CopyWith$Input$AreaFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfAreaFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfAreaFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfAreaFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfAreaFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfAreaFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$AreaFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined) 'none': (none as Input$AreaFilterInput?),
        if (some != _undefined) 'some': (some as Input$AreaFilterInput?),
      }));
  CopyWith$Input$AreaFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$AreaFilterInput.stub(_then(_instance))
        : CopyWith$Input$AreaFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$AreaFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$AreaFilterInput.stub(_then(_instance))
        : CopyWith$Input$AreaFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$AreaFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$AreaFilterInput.stub(_then(_instance))
        : CopyWith$Input$AreaFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfAreaFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfAreaFilterInput(this._res);

  TRes _res;

  call({
    Input$AreaFilterInput? all,
    bool? any,
    Input$AreaFilterInput? none,
    Input$AreaFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$AreaFilterInput<TRes> get all =>
      CopyWith$Input$AreaFilterInput.stub(_res);
  CopyWith$Input$AreaFilterInput<TRes> get none =>
      CopyWith$Input$AreaFilterInput.stub(_res);
  CopyWith$Input$AreaFilterInput<TRes> get some =>
      CopyWith$Input$AreaFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfEnumItemFilterInput {
  factory Input$ListFilterInputTypeOfEnumItemFilterInput({
    Input$EnumItemFilterInput? all,
    bool? any,
    Input$EnumItemFilterInput? none,
    Input$EnumItemFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfEnumItemFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfEnumItemFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfEnumItemFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$EnumItemFilterInput.fromJson((l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$EnumItemFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$EnumItemFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfEnumItemFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EnumItemFilterInput? get all =>
      (_$data['all'] as Input$EnumItemFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$EnumItemFilterInput? get none =>
      (_$data['none'] as Input$EnumItemFilterInput?);
  Input$EnumItemFilterInput? get some =>
      (_$data['some'] as Input$EnumItemFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<
          Input$ListFilterInputTypeOfEnumItemFilterInput>
      get copyWith => CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfEnumItemFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput(
    Input$ListFilterInputTypeOfEnumItemFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfEnumItemFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfEnumItemFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfEnumItemFilterInput;

  TRes call({
    Input$EnumItemFilterInput? all,
    bool? any,
    Input$EnumItemFilterInput? none,
    Input$EnumItemFilterInput? some,
  });
  CopyWith$Input$EnumItemFilterInput<TRes> get all;
  CopyWith$Input$EnumItemFilterInput<TRes> get none;
  CopyWith$Input$EnumItemFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfEnumItemFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfEnumItemFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfEnumItemFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfEnumItemFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$EnumItemFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined) 'none': (none as Input$EnumItemFilterInput?),
        if (some != _undefined) 'some': (some as Input$EnumItemFilterInput?),
      }));
  CopyWith$Input$EnumItemFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$EnumItemFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumItemFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$EnumItemFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$EnumItemFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumItemFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$EnumItemFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$EnumItemFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumItemFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfEnumItemFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfEnumItemFilterInput(this._res);

  TRes _res;

  call({
    Input$EnumItemFilterInput? all,
    bool? any,
    Input$EnumItemFilterInput? none,
    Input$EnumItemFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$EnumItemFilterInput<TRes> get all =>
      CopyWith$Input$EnumItemFilterInput.stub(_res);
  CopyWith$Input$EnumItemFilterInput<TRes> get none =>
      CopyWith$Input$EnumItemFilterInput.stub(_res);
  CopyWith$Input$EnumItemFilterInput<TRes> get some =>
      CopyWith$Input$EnumItemFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfMunicipalityFilterInput {
  factory Input$ListFilterInputTypeOfMunicipalityFilterInput({
    Input$MunicipalityFilterInput? all,
    bool? any,
    Input$MunicipalityFilterInput? none,
    Input$MunicipalityFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfMunicipalityFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfMunicipalityFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfMunicipalityFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$MunicipalityFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$MunicipalityFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$MunicipalityFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfMunicipalityFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$MunicipalityFilterInput? get all =>
      (_$data['all'] as Input$MunicipalityFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$MunicipalityFilterInput? get none =>
      (_$data['none'] as Input$MunicipalityFilterInput?);
  Input$MunicipalityFilterInput? get some =>
      (_$data['some'] as Input$MunicipalityFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<
          Input$ListFilterInputTypeOfMunicipalityFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfMunicipalityFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput(
    Input$ListFilterInputTypeOfMunicipalityFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfMunicipalityFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput;

  TRes call({
    Input$MunicipalityFilterInput? all,
    bool? any,
    Input$MunicipalityFilterInput? none,
    Input$MunicipalityFilterInput? some,
  });
  CopyWith$Input$MunicipalityFilterInput<TRes> get all;
  CopyWith$Input$MunicipalityFilterInput<TRes> get none;
  CopyWith$Input$MunicipalityFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfMunicipalityFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfMunicipalityFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfMunicipalityFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$MunicipalityFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$MunicipalityFilterInput?),
        if (some != _undefined)
          'some': (some as Input$MunicipalityFilterInput?),
      }));
  CopyWith$Input$MunicipalityFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$MunicipalityFilterInput.stub(_then(_instance))
        : CopyWith$Input$MunicipalityFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$MunicipalityFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$MunicipalityFilterInput.stub(_then(_instance))
        : CopyWith$Input$MunicipalityFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$MunicipalityFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$MunicipalityFilterInput.stub(_then(_instance))
        : CopyWith$Input$MunicipalityFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfMunicipalityFilterInput(
      this._res);

  TRes _res;

  call({
    Input$MunicipalityFilterInput? all,
    bool? any,
    Input$MunicipalityFilterInput? none,
    Input$MunicipalityFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$MunicipalityFilterInput<TRes> get all =>
      CopyWith$Input$MunicipalityFilterInput.stub(_res);
  CopyWith$Input$MunicipalityFilterInput<TRes> get none =>
      CopyWith$Input$MunicipalityFilterInput.stub(_res);
  CopyWith$Input$MunicipalityFilterInput<TRes> get some =>
      CopyWith$Input$MunicipalityFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfPersonFilterInput {
  factory Input$ListFilterInputTypeOfPersonFilterInput({
    Input$PersonFilterInput? all,
    bool? any,
    Input$PersonFilterInput? none,
    Input$PersonFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfPersonFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfPersonFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfPersonFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$PersonFilterInput.fromJson((l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$PersonFilterInput.fromJson((l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$PersonFilterInput.fromJson((l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfPersonFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PersonFilterInput? get all =>
      (_$data['all'] as Input$PersonFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$PersonFilterInput? get none =>
      (_$data['none'] as Input$PersonFilterInput?);
  Input$PersonFilterInput? get some =>
      (_$data['some'] as Input$PersonFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<
          Input$ListFilterInputTypeOfPersonFilterInput>
      get copyWith => CopyWith$Input$ListFilterInputTypeOfPersonFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfPersonFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfPersonFilterInput(
    Input$ListFilterInputTypeOfPersonFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfPersonFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfPersonFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfPersonFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonFilterInput;

  TRes call({
    Input$PersonFilterInput? all,
    bool? any,
    Input$PersonFilterInput? none,
    Input$PersonFilterInput? some,
  });
  CopyWith$Input$PersonFilterInput<TRes> get all;
  CopyWith$Input$PersonFilterInput<TRes> get none;
  CopyWith$Input$PersonFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfPersonFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfPersonFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfPersonFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfPersonFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfPersonFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$PersonFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined) 'none': (none as Input$PersonFilterInput?),
        if (some != _undefined) 'some': (some as Input$PersonFilterInput?),
      }));
  CopyWith$Input$PersonFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$PersonFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$PersonFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonFilterInput(this._res);

  TRes _res;

  call({
    Input$PersonFilterInput? all,
    bool? any,
    Input$PersonFilterInput? none,
    Input$PersonFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$PersonFilterInput<TRes> get all =>
      CopyWith$Input$PersonFilterInput.stub(_res);
  CopyWith$Input$PersonFilterInput<TRes> get none =>
      CopyWith$Input$PersonFilterInput.stub(_res);
  CopyWith$Input$PersonFilterInput<TRes> get some =>
      CopyWith$Input$PersonFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfPersonVariableFilterInput {
  factory Input$ListFilterInputTypeOfPersonVariableFilterInput({
    Input$PersonVariableFilterInput? all,
    bool? any,
    Input$PersonVariableFilterInput? none,
    Input$PersonVariableFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfPersonVariableFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfPersonVariableFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$PersonVariableFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$PersonVariableFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$PersonVariableFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfPersonVariableFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PersonVariableFilterInput? get all =>
      (_$data['all'] as Input$PersonVariableFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$PersonVariableFilterInput? get none =>
      (_$data['none'] as Input$PersonVariableFilterInput?);
  Input$PersonVariableFilterInput? get some =>
      (_$data['some'] as Input$PersonVariableFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<
          Input$ListFilterInputTypeOfPersonVariableFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfPersonVariableFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
    Input$ListFilterInputTypeOfPersonVariableFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfPersonVariableFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput;

  TRes call({
    Input$PersonVariableFilterInput? all,
    bool? any,
    Input$PersonVariableFilterInput? none,
    Input$PersonVariableFilterInput? some,
  });
  CopyWith$Input$PersonVariableFilterInput<TRes> get all;
  CopyWith$Input$PersonVariableFilterInput<TRes> get none;
  CopyWith$Input$PersonVariableFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfPersonVariableFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfPersonVariableFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfPersonVariableFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$PersonVariableFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$PersonVariableFilterInput?),
        if (some != _undefined)
          'some': (some as Input$PersonVariableFilterInput?),
      }));
  CopyWith$Input$PersonVariableFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$PersonVariableFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonVariableFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$PersonVariableFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$PersonVariableFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonVariableFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$PersonVariableFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$PersonVariableFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonVariableFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfPersonVariableFilterInput(
      this._res);

  TRes _res;

  call({
    Input$PersonVariableFilterInput? all,
    bool? any,
    Input$PersonVariableFilterInput? none,
    Input$PersonVariableFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$PersonVariableFilterInput<TRes> get all =>
      CopyWith$Input$PersonVariableFilterInput.stub(_res);
  CopyWith$Input$PersonVariableFilterInput<TRes> get none =>
      CopyWith$Input$PersonVariableFilterInput.stub(_res);
  CopyWith$Input$PersonVariableFilterInput<TRes> get some =>
      CopyWith$Input$PersonVariableFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfRelativeLocationFilterInput {
  factory Input$ListFilterInputTypeOfRelativeLocationFilterInput({
    Input$RelativeLocationFilterInput? all,
    bool? any,
    Input$RelativeLocationFilterInput? none,
    Input$RelativeLocationFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfRelativeLocationFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfRelativeLocationFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfRelativeLocationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$RelativeLocationFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$RelativeLocationFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$RelativeLocationFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfRelativeLocationFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$RelativeLocationFilterInput? get all =>
      (_$data['all'] as Input$RelativeLocationFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$RelativeLocationFilterInput? get none =>
      (_$data['none'] as Input$RelativeLocationFilterInput?);
  Input$RelativeLocationFilterInput? get some =>
      (_$data['some'] as Input$RelativeLocationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<
          Input$ListFilterInputTypeOfRelativeLocationFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfRelativeLocationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput(
    Input$ListFilterInputTypeOfRelativeLocationFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfRelativeLocationFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput;

  TRes call({
    Input$RelativeLocationFilterInput? all,
    bool? any,
    Input$RelativeLocationFilterInput? none,
    Input$RelativeLocationFilterInput? some,
  });
  CopyWith$Input$RelativeLocationFilterInput<TRes> get all;
  CopyWith$Input$RelativeLocationFilterInput<TRes> get none;
  CopyWith$Input$RelativeLocationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfRelativeLocationFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfRelativeLocationFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfRelativeLocationFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$RelativeLocationFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$RelativeLocationFilterInput?),
        if (some != _undefined)
          'some': (some as Input$RelativeLocationFilterInput?),
      }));
  CopyWith$Input$RelativeLocationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$RelativeLocationFilterInput.stub(_then(_instance))
        : CopyWith$Input$RelativeLocationFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$RelativeLocationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$RelativeLocationFilterInput.stub(_then(_instance))
        : CopyWith$Input$RelativeLocationFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$RelativeLocationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$RelativeLocationFilterInput.stub(_then(_instance))
        : CopyWith$Input$RelativeLocationFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRelativeLocationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfRelativeLocationFilterInput(
      this._res);

  TRes _res;

  call({
    Input$RelativeLocationFilterInput? all,
    bool? any,
    Input$RelativeLocationFilterInput? none,
    Input$RelativeLocationFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$RelativeLocationFilterInput<TRes> get all =>
      CopyWith$Input$RelativeLocationFilterInput.stub(_res);
  CopyWith$Input$RelativeLocationFilterInput<TRes> get none =>
      CopyWith$Input$RelativeLocationFilterInput.stub(_res);
  CopyWith$Input$RelativeLocationFilterInput<TRes> get some =>
      CopyWith$Input$RelativeLocationFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfRolePermissionFilterInput {
  factory Input$ListFilterInputTypeOfRolePermissionFilterInput({
    Input$RolePermissionFilterInput? all,
    bool? any,
    Input$RolePermissionFilterInput? none,
    Input$RolePermissionFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfRolePermissionFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfRolePermissionFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfRolePermissionFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$RolePermissionFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$RolePermissionFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$RolePermissionFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfRolePermissionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$RolePermissionFilterInput? get all =>
      (_$data['all'] as Input$RolePermissionFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$RolePermissionFilterInput? get none =>
      (_$data['none'] as Input$RolePermissionFilterInput?);
  Input$RolePermissionFilterInput? get some =>
      (_$data['some'] as Input$RolePermissionFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<
          Input$ListFilterInputTypeOfRolePermissionFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfRolePermissionFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput(
    Input$ListFilterInputTypeOfRolePermissionFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfRolePermissionFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput;

  TRes call({
    Input$RolePermissionFilterInput? all,
    bool? any,
    Input$RolePermissionFilterInput? none,
    Input$RolePermissionFilterInput? some,
  });
  CopyWith$Input$RolePermissionFilterInput<TRes> get all;
  CopyWith$Input$RolePermissionFilterInput<TRes> get none;
  CopyWith$Input$RolePermissionFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfRolePermissionFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfRolePermissionFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfRolePermissionFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$RolePermissionFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$RolePermissionFilterInput?),
        if (some != _undefined)
          'some': (some as Input$RolePermissionFilterInput?),
      }));
  CopyWith$Input$RolePermissionFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$RolePermissionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RolePermissionFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$RolePermissionFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$RolePermissionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RolePermissionFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$RolePermissionFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$RolePermissionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RolePermissionFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRolePermissionFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfRolePermissionFilterInput(
      this._res);

  TRes _res;

  call({
    Input$RolePermissionFilterInput? all,
    bool? any,
    Input$RolePermissionFilterInput? none,
    Input$RolePermissionFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$RolePermissionFilterInput<TRes> get all =>
      CopyWith$Input$RolePermissionFilterInput.stub(_res);
  CopyWith$Input$RolePermissionFilterInput<TRes> get none =>
      CopyWith$Input$RolePermissionFilterInput.stub(_res);
  CopyWith$Input$RolePermissionFilterInput<TRes> get some =>
      CopyWith$Input$RolePermissionFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput {
  factory Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput({
    Input$SuscriptionTerritoryFilterInput? all,
    bool? any,
    Input$SuscriptionTerritoryFilterInput? none,
    Input$SuscriptionTerritoryFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$SuscriptionTerritoryFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$SuscriptionTerritoryFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$SuscriptionTerritoryFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$SuscriptionTerritoryFilterInput? get all =>
      (_$data['all'] as Input$SuscriptionTerritoryFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$SuscriptionTerritoryFilterInput? get none =>
      (_$data['none'] as Input$SuscriptionTerritoryFilterInput?);
  Input$SuscriptionTerritoryFilterInput? get some =>
      (_$data['some'] as Input$SuscriptionTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
          Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput)
        then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput;

  TRes call({
    Input$SuscriptionTerritoryFilterInput? all,
    bool? any,
    Input$SuscriptionTerritoryFilterInput? none,
    Input$SuscriptionTerritoryFilterInput? some,
  });
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get all;
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get none;
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
            TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput _instance;

  final TRes Function(
      Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$SuscriptionTerritoryFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$SuscriptionTerritoryFilterInput?),
        if (some != _undefined)
          'some': (some as Input$SuscriptionTerritoryFilterInput?),
      }));
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$SuscriptionTerritoryFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$SuscriptionTerritoryFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$SuscriptionTerritoryFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
      this._res);

  TRes _res;

  call({
    Input$SuscriptionTerritoryFilterInput? all,
    bool? any,
    Input$SuscriptionTerritoryFilterInput? none,
    Input$SuscriptionTerritoryFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get all =>
      CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_res);
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get none =>
      CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_res);
  CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> get some =>
      CopyWith$Input$SuscriptionTerritoryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfTerritoryFilterInput {
  factory Input$ListFilterInputTypeOfTerritoryFilterInput({
    Input$TerritoryFilterInput? all,
    bool? any,
    Input$TerritoryFilterInput? none,
    Input$TerritoryFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfTerritoryFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfTerritoryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfTerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TerritoryFilterInput? get all =>
      (_$data['all'] as Input$TerritoryFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$TerritoryFilterInput? get none =>
      (_$data['none'] as Input$TerritoryFilterInput?);
  Input$TerritoryFilterInput? get some =>
      (_$data['some'] as Input$TerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<
          Input$ListFilterInputTypeOfTerritoryFilterInput>
      get copyWith => CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput(
    Input$ListFilterInputTypeOfTerritoryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfTerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryFilterInput;

  TRes call({
    Input$TerritoryFilterInput? all,
    bool? any,
    Input$TerritoryFilterInput? none,
    Input$TerritoryFilterInput? some,
  });
  CopyWith$Input$TerritoryFilterInput<TRes> get all;
  CopyWith$Input$TerritoryFilterInput<TRes> get none;
  CopyWith$Input$TerritoryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfTerritoryFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfTerritoryFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$TerritoryFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined) 'none': (none as Input$TerritoryFilterInput?),
        if (some != _undefined) 'some': (some as Input$TerritoryFilterInput?),
      }));
  CopyWith$Input$TerritoryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$TerritoryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$TerritoryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryFilterInput(this._res);

  TRes _res;

  call({
    Input$TerritoryFilterInput? all,
    bool? any,
    Input$TerritoryFilterInput? none,
    Input$TerritoryFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$TerritoryFilterInput<TRes> get all =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$TerritoryFilterInput<TRes> get none =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$TerritoryFilterInput<TRes> get some =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput {
  factory Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput({
    Input$TerritoryGroupRoleFilterInput? all,
    bool? any,
    Input$TerritoryGroupRoleFilterInput? none,
    Input$TerritoryGroupRoleFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$TerritoryGroupRoleFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TerritoryGroupRoleFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TerritoryGroupRoleFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TerritoryGroupRoleFilterInput? get all =>
      (_$data['all'] as Input$TerritoryGroupRoleFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$TerritoryGroupRoleFilterInput? get none =>
      (_$data['none'] as Input$TerritoryGroupRoleFilterInput?);
  Input$TerritoryGroupRoleFilterInput? get some =>
      (_$data['some'] as Input$TerritoryGroupRoleFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
          Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput)
        then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput;

  TRes call({
    Input$TerritoryGroupRoleFilterInput? all,
    bool? any,
    Input$TerritoryGroupRoleFilterInput? none,
    Input$TerritoryGroupRoleFilterInput? some,
  });
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get all;
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get none;
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
            TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$TerritoryGroupRoleFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$TerritoryGroupRoleFilterInput?),
        if (some != _undefined)
          'some': (some as Input$TerritoryGroupRoleFilterInput?),
      }));
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryGroupRoleFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryGroupRoleFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryGroupRoleFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
      this._res);

  TRes _res;

  call({
    Input$TerritoryGroupRoleFilterInput? all,
    bool? any,
    Input$TerritoryGroupRoleFilterInput? none,
    Input$TerritoryGroupRoleFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get all =>
      CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get none =>
      CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> get some =>
      CopyWith$Input$TerritoryGroupRoleFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput {
  factory Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput({
    Input$TerritoryGroupTerritoryFilterInput? all,
    bool? any,
    Input$TerritoryGroupTerritoryFilterInput? none,
    Input$TerritoryGroupTerritoryFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$TerritoryGroupTerritoryFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TerritoryGroupTerritoryFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TerritoryGroupTerritoryFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TerritoryGroupTerritoryFilterInput? get all =>
      (_$data['all'] as Input$TerritoryGroupTerritoryFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$TerritoryGroupTerritoryFilterInput? get none =>
      (_$data['none'] as Input$TerritoryGroupTerritoryFilterInput?);
  Input$TerritoryGroupTerritoryFilterInput? get some =>
      (_$data['some'] as Input$TerritoryGroupTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
          Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput)
        then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput;

  TRes call({
    Input$TerritoryGroupTerritoryFilterInput? all,
    bool? any,
    Input$TerritoryGroupTerritoryFilterInput? none,
    Input$TerritoryGroupTerritoryFilterInput? some,
  });
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get all;
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get none;
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
            TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput _instance;

  final TRes Function(
      Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$TerritoryGroupTerritoryFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$TerritoryGroupTerritoryFilterInput?),
        if (some != _undefined)
          'some': (some as Input$TerritoryGroupTerritoryFilterInput?),
      }));
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$TerritoryGroupTerritoryFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$TerritoryGroupTerritoryFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$TerritoryGroupTerritoryFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
      this._res);

  TRes _res;

  call({
    Input$TerritoryGroupTerritoryFilterInput? all,
    bool? any,
    Input$TerritoryGroupTerritoryFilterInput? none,
    Input$TerritoryGroupTerritoryFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get all =>
      CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get none =>
      CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> get some =>
      CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfTerritoryRoleFilterInput {
  factory Input$ListFilterInputTypeOfTerritoryRoleFilterInput({
    Input$TerritoryRoleFilterInput? all,
    bool? any,
    Input$TerritoryRoleFilterInput? none,
    Input$TerritoryRoleFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfTerritoryRoleFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfTerritoryRoleFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfTerritoryRoleFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$TerritoryRoleFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TerritoryRoleFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TerritoryRoleFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfTerritoryRoleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TerritoryRoleFilterInput? get all =>
      (_$data['all'] as Input$TerritoryRoleFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$TerritoryRoleFilterInput? get none =>
      (_$data['none'] as Input$TerritoryRoleFilterInput?);
  Input$TerritoryRoleFilterInput? get some =>
      (_$data['some'] as Input$TerritoryRoleFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<
          Input$ListFilterInputTypeOfTerritoryRoleFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfTerritoryRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfTerritoryRoleFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput;

  TRes call({
    Input$TerritoryRoleFilterInput? all,
    bool? any,
    Input$TerritoryRoleFilterInput? none,
    Input$TerritoryRoleFilterInput? some,
  });
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get all;
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get none;
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfTerritoryRoleFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfTerritoryRoleFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfTerritoryRoleFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$TerritoryRoleFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$TerritoryRoleFilterInput?),
        if (some != _undefined)
          'some': (some as Input$TerritoryRoleFilterInput?),
      }));
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$TerritoryRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryRoleFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$TerritoryRoleFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TerritoryRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryRoleFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$TerritoryRoleFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TerritoryRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryRoleFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
      this._res);

  TRes _res;

  call({
    Input$TerritoryRoleFilterInput? all,
    bool? any,
    Input$TerritoryRoleFilterInput? none,
    Input$TerritoryRoleFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get all =>
      CopyWith$Input$TerritoryRoleFilterInput.stub(_res);
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get none =>
      CopyWith$Input$TerritoryRoleFilterInput.stub(_res);
  CopyWith$Input$TerritoryRoleFilterInput<TRes> get some =>
      CopyWith$Input$TerritoryRoleFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfUserPersonMarkerFilterInput {
  factory Input$ListFilterInputTypeOfUserPersonMarkerFilterInput({
    Input$UserPersonMarkerFilterInput? all,
    bool? any,
    Input$UserPersonMarkerFilterInput? none,
    Input$UserPersonMarkerFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfUserPersonMarkerFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$UserPersonMarkerFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$UserPersonMarkerFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$UserPersonMarkerFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfUserPersonMarkerFilterInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserPersonMarkerFilterInput? get all =>
      (_$data['all'] as Input$UserPersonMarkerFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$UserPersonMarkerFilterInput? get none =>
      (_$data['none'] as Input$UserPersonMarkerFilterInput?);
  Input$UserPersonMarkerFilterInput? get some =>
      (_$data['some'] as Input$UserPersonMarkerFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<
          Input$ListFilterInputTypeOfUserPersonMarkerFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfUserPersonMarkerFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfUserPersonMarkerFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput;

  TRes call({
    Input$UserPersonMarkerFilterInput? all,
    bool? any,
    Input$UserPersonMarkerFilterInput? none,
    Input$UserPersonMarkerFilterInput? some,
  });
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get all;
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get none;
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfUserPersonMarkerFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfUserPersonMarkerFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfUserPersonMarkerFilterInput._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$UserPersonMarkerFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$UserPersonMarkerFilterInput?),
        if (some != _undefined)
          'some': (some as Input$UserPersonMarkerFilterInput?),
      }));
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$UserPersonMarkerFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserPersonMarkerFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$UserPersonMarkerFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserPersonMarkerFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$UserPersonMarkerFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserPersonMarkerFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
      this._res);

  TRes _res;

  call({
    Input$UserPersonMarkerFilterInput? all,
    bool? any,
    Input$UserPersonMarkerFilterInput? none,
    Input$UserPersonMarkerFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get all =>
      CopyWith$Input$UserPersonMarkerFilterInput.stub(_res);
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get none =>
      CopyWith$Input$UserPersonMarkerFilterInput.stub(_res);
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get some =>
      CopyWith$Input$UserPersonMarkerFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput {
  factory Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput({
    Input$UserPersonMarkerPersonVariableFilterInput? all,
    bool? any,
    Input$UserPersonMarkerPersonVariableFilterInput? none,
    Input$UserPersonMarkerPersonVariableFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput._(
      this._$data);

  factory Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserPersonMarkerPersonVariableFilterInput? get all =>
      (_$data['all'] as Input$UserPersonMarkerPersonVariableFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$UserPersonMarkerPersonVariableFilterInput? get none =>
      (_$data['none'] as Input$UserPersonMarkerPersonVariableFilterInput?);
  Input$UserPersonMarkerPersonVariableFilterInput? get some =>
      (_$data['some'] as Input$UserPersonMarkerPersonVariableFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
          Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
        instance,
    TRes Function(
            Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput)
        then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput;

  TRes call({
    Input$UserPersonMarkerPersonVariableFilterInput? all,
    bool? any,
    Input$UserPersonMarkerPersonVariableFilterInput? none,
    Input$UserPersonMarkerPersonVariableFilterInput? some,
  });
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get all;
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get none;
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
            TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
      _instance;

  final TRes Function(
          Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
          ._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$UserPersonMarkerPersonVariableFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$UserPersonMarkerPersonVariableFilterInput?),
        if (some != _undefined)
          'some': (some as Input$UserPersonMarkerPersonVariableFilterInput?),
      }));
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
      this._res);

  TRes _res;

  call({
    Input$UserPersonMarkerPersonVariableFilterInput? all,
    bool? any,
    Input$UserPersonMarkerPersonVariableFilterInput? none,
    Input$UserPersonMarkerPersonVariableFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get all =>
      CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(_res);
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get none =>
      CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(_res);
  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> get some =>
      CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfUserTerritoryFilterInput {
  factory Input$ListFilterInputTypeOfUserTerritoryFilterInput({
    Input$UserTerritoryFilterInput? all,
    bool? any,
    Input$UserTerritoryFilterInput? none,
    Input$UserTerritoryFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfUserTerritoryFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfUserTerritoryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfUserTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$UserTerritoryFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$UserTerritoryFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$UserTerritoryFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfUserTerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserTerritoryFilterInput? get all =>
      (_$data['all'] as Input$UserTerritoryFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$UserTerritoryFilterInput? get none =>
      (_$data['none'] as Input$UserTerritoryFilterInput?);
  Input$UserTerritoryFilterInput? get some =>
      (_$data['some'] as Input$UserTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<
          Input$ListFilterInputTypeOfUserTerritoryFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfUserTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
    Input$ListFilterInputTypeOfUserTerritoryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfUserTerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput;

  TRes call({
    Input$UserTerritoryFilterInput? all,
    bool? any,
    Input$UserTerritoryFilterInput? none,
    Input$UserTerritoryFilterInput? some,
  });
  CopyWith$Input$UserTerritoryFilterInput<TRes> get all;
  CopyWith$Input$UserTerritoryFilterInput<TRes> get none;
  CopyWith$Input$UserTerritoryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfUserTerritoryFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfUserTerritoryFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfUserTerritoryFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$UserTerritoryFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$UserTerritoryFilterInput?),
        if (some != _undefined)
          'some': (some as Input$UserTerritoryFilterInput?),
      }));
  CopyWith$Input$UserTerritoryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$UserTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserTerritoryFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$UserTerritoryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$UserTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserTerritoryFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$UserTerritoryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$UserTerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserTerritoryFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
      this._res);

  TRes _res;

  call({
    Input$UserTerritoryFilterInput? all,
    bool? any,
    Input$UserTerritoryFilterInput? none,
    Input$UserTerritoryFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$UserTerritoryFilterInput<TRes> get all =>
      CopyWith$Input$UserTerritoryFilterInput.stub(_res);
  CopyWith$Input$UserTerritoryFilterInput<TRes> get none =>
      CopyWith$Input$UserTerritoryFilterInput.stub(_res);
  CopyWith$Input$UserTerritoryFilterInput<TRes> get some =>
      CopyWith$Input$UserTerritoryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput {
  factory Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput({
    Input$VariableTypeConditionDependencyFilterInput? all,
    bool? any,
    Input$VariableTypeConditionDependencyFilterInput? none,
    Input$VariableTypeConditionDependencyFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput._(
      this._$data);

  factory Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$VariableTypeConditionDependencyFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$VariableTypeConditionDependencyFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$VariableTypeConditionDependencyFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$VariableTypeConditionDependencyFilterInput? get all =>
      (_$data['all'] as Input$VariableTypeConditionDependencyFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$VariableTypeConditionDependencyFilterInput? get none =>
      (_$data['none'] as Input$VariableTypeConditionDependencyFilterInput?);
  Input$VariableTypeConditionDependencyFilterInput? get some =>
      (_$data['some'] as Input$VariableTypeConditionDependencyFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
          Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
        instance,
    TRes Function(
            Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput)
        then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput;

  TRes call({
    Input$VariableTypeConditionDependencyFilterInput? all,
    bool? any,
    Input$VariableTypeConditionDependencyFilterInput? none,
    Input$VariableTypeConditionDependencyFilterInput? some,
  });
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get all;
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get none;
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
            TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
      _instance;

  final TRes Function(
          Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(
          Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
              ._({
        ..._instance._$data,
        if (all != _undefined)
          'all': (all as Input$VariableTypeConditionDependencyFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$VariableTypeConditionDependencyFilterInput?),
        if (some != _undefined)
          'some': (some as Input$VariableTypeConditionDependencyFilterInput?),
      }));
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$VariableTypeConditionDependencyFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$VariableTypeConditionDependencyFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$VariableTypeConditionDependencyFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
        TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
            TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
      this._res);

  TRes _res;

  call({
    Input$VariableTypeConditionDependencyFilterInput? all,
    bool? any,
    Input$VariableTypeConditionDependencyFilterInput? none,
    Input$VariableTypeConditionDependencyFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get all =>
      CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(_res);
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get none =>
      CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(_res);
  CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> get some =>
      CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfVariableTypeFilterInput {
  factory Input$ListFilterInputTypeOfVariableTypeFilterInput({
    Input$VariableTypeFilterInput? all,
    bool? any,
    Input$VariableTypeFilterInput? none,
    Input$VariableTypeFilterInput? some,
  }) =>
      Input$ListFilterInputTypeOfVariableTypeFilterInput._({
        if (all != null) r'all': all,
        if (any != null) r'any': any,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
      });

  Input$ListFilterInputTypeOfVariableTypeFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfVariableTypeFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$all as Map<String, dynamic>));
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    return Input$ListFilterInputTypeOfVariableTypeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$VariableTypeFilterInput? get all =>
      (_$data['all'] as Input$VariableTypeFilterInput?);
  bool? get any => (_$data['any'] as bool?);
  Input$VariableTypeFilterInput? get none =>
      (_$data['none'] as Input$VariableTypeFilterInput?);
  Input$VariableTypeFilterInput? get some =>
      (_$data['some'] as Input$VariableTypeFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<
          Input$ListFilterInputTypeOfVariableTypeFilterInput>
      get copyWith =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ListFilterInputTypeOfVariableTypeFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$any = any;
    final l$none = none;
    final l$some = some;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('any') ? l$any : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<
    TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput(
    Input$ListFilterInputTypeOfVariableTypeFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfVariableTypeFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput;

  TRes call({
    Input$VariableTypeFilterInput? all,
    bool? any,
    Input$VariableTypeFilterInput? none,
    Input$VariableTypeFilterInput? some,
  });
  CopyWith$Input$VariableTypeFilterInput<TRes> get all;
  CopyWith$Input$VariableTypeFilterInput<TRes> get none;
  CopyWith$Input$VariableTypeFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfVariableTypeFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfVariableTypeFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? all = _undefined,
    Object? any = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
  }) =>
      _then(Input$ListFilterInputTypeOfVariableTypeFilterInput._({
        ..._instance._$data,
        if (all != _undefined) 'all': (all as Input$VariableTypeFilterInput?),
        if (any != _undefined) 'any': (any as bool?),
        if (none != _undefined)
          'none': (none as Input$VariableTypeFilterInput?),
        if (some != _undefined)
          'some': (some as Input$VariableTypeFilterInput?),
      }));
  CopyWith$Input$VariableTypeFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$all, (e) => call(all: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$none, (e) => call(none: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfVariableTypeFilterInput(
      this._res);

  TRes _res;

  call({
    Input$VariableTypeFilterInput? all,
    bool? any,
    Input$VariableTypeFilterInput? none,
    Input$VariableTypeFilterInput? some,
  }) =>
      _res;
  CopyWith$Input$VariableTypeFilterInput<TRes> get all =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get none =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get some =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
}

class Input$MarkerModeOperationFilterInput {
  factory Input$MarkerModeOperationFilterInput({
    Enum$MarkerMode? eq,
    List<Enum$MarkerMode>? $in,
    Enum$MarkerMode? neq,
    List<Enum$MarkerMode>? nin,
  }) =>
      Input$MarkerModeOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
      });

  Input$MarkerModeOperationFilterInput._(this._$data);

  factory Input$MarkerModeOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$MarkerMode((l$eq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$MarkerMode((e as String)))
          .toList();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : fromJson$Enum$MarkerMode((l$neq as String));
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$MarkerMode((e as String)))
          .toList();
    }
    return Input$MarkerModeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$MarkerMode? get eq => (_$data['eq'] as Enum$MarkerMode?);
  List<Enum$MarkerMode>? get $in => (_$data['in'] as List<Enum$MarkerMode>?);
  Enum$MarkerMode? get neq => (_$data['neq'] as Enum$MarkerMode?);
  List<Enum$MarkerMode>? get nin => (_$data['nin'] as List<Enum$MarkerMode>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$MarkerMode(l$eq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$MarkerMode(e)).toList();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$MarkerMode(l$neq);
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] =
          l$nin?.map((e) => toJson$Enum$MarkerMode(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$MarkerModeOperationFilterInput<
          Input$MarkerModeOperationFilterInput>
      get copyWith => CopyWith$Input$MarkerModeOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkerModeOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$neq = neq;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkerModeOperationFilterInput<TRes> {
  factory CopyWith$Input$MarkerModeOperationFilterInput(
    Input$MarkerModeOperationFilterInput instance,
    TRes Function(Input$MarkerModeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$MarkerModeOperationFilterInput;

  factory CopyWith$Input$MarkerModeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkerModeOperationFilterInput;

  TRes call({
    Enum$MarkerMode? eq,
    List<Enum$MarkerMode>? $in,
    Enum$MarkerMode? neq,
    List<Enum$MarkerMode>? nin,
  });
}

class _CopyWithImpl$Input$MarkerModeOperationFilterInput<TRes>
    implements CopyWith$Input$MarkerModeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$MarkerModeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$MarkerModeOperationFilterInput _instance;

  final TRes Function(Input$MarkerModeOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
  }) =>
      _then(Input$MarkerModeOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$MarkerMode?),
        if ($in != _undefined) 'in': ($in as List<Enum$MarkerMode>?),
        if (neq != _undefined) 'neq': (neq as Enum$MarkerMode?),
        if (nin != _undefined) 'nin': (nin as List<Enum$MarkerMode>?),
      }));
}

class _CopyWithStubImpl$Input$MarkerModeOperationFilterInput<TRes>
    implements CopyWith$Input$MarkerModeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$MarkerModeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$MarkerMode? eq,
    List<Enum$MarkerMode>? $in,
    Enum$MarkerMode? neq,
    List<Enum$MarkerMode>? nin,
  }) =>
      _res;
}

class Input$MarkerTypeFilterInput {
  factory Input$MarkerTypeFilterInput({
    List<Input$MarkerTypeFilterInput>? and,
    Input$MarkerModeOperationFilterInput? markerMode,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$MarkerTypeFilterInput>? or,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      Input$MarkerTypeFilterInput._({
        if (and != null) r'and': and,
        if (markerMode != null) r'markerMode': markerMode,
        if (markerTypeID != null) r'markerTypeID': markerTypeID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (userPersonMarkers != null) r'userPersonMarkers': userPersonMarkers,
      });

  Input$MarkerTypeFilterInput._(this._$data);

  factory Input$MarkerTypeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$MarkerTypeFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('markerMode')) {
      final l$markerMode = data['markerMode'];
      result$data['markerMode'] = l$markerMode == null
          ? null
          : Input$MarkerModeOperationFilterInput.fromJson(
              (l$markerMode as Map<String, dynamic>));
    }
    if (data.containsKey('markerTypeID')) {
      final l$markerTypeID = data['markerTypeID'];
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$markerTypeID as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$MarkerTypeFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = data['userPersonMarkers'];
      result$data['userPersonMarkers'] = l$userPersonMarkers == null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
              (l$userPersonMarkers as Map<String, dynamic>));
    }
    return Input$MarkerTypeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MarkerTypeFilterInput>? get and =>
      (_$data['and'] as List<Input$MarkerTypeFilterInput>?);
  Input$MarkerModeOperationFilterInput? get markerMode =>
      (_$data['markerMode'] as Input$MarkerModeOperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get markerTypeID =>
      (_$data['markerTypeID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$MarkerTypeFilterInput>? get or =>
      (_$data['or'] as List<Input$MarkerTypeFilterInput>?);
  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
      get userPersonMarkers => (_$data['userPersonMarkers']
          as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('markerMode')) {
      final l$markerMode = markerMode;
      result$data['markerMode'] = l$markerMode?.toJson();
    }
    if (_$data.containsKey('markerTypeID')) {
      final l$markerTypeID = markerTypeID;
      result$data['markerTypeID'] = l$markerTypeID?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = userPersonMarkers;
      result$data['userPersonMarkers'] = l$userPersonMarkers?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MarkerTypeFilterInput<Input$MarkerTypeFilterInput>
      get copyWith => CopyWith$Input$MarkerTypeFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkerTypeFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$markerMode = markerMode;
    final lOther$markerMode = other.markerMode;
    if (_$data.containsKey('markerMode') !=
        other._$data.containsKey('markerMode')) {
      return false;
    }
    if (l$markerMode != lOther$markerMode) {
      return false;
    }
    final l$markerTypeID = markerTypeID;
    final lOther$markerTypeID = other.markerTypeID;
    if (_$data.containsKey('markerTypeID') !=
        other._$data.containsKey('markerTypeID')) {
      return false;
    }
    if (l$markerTypeID != lOther$markerTypeID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$userPersonMarkers = userPersonMarkers;
    final lOther$userPersonMarkers = other.userPersonMarkers;
    if (_$data.containsKey('userPersonMarkers') !=
        other._$data.containsKey('userPersonMarkers')) {
      return false;
    }
    if (l$userPersonMarkers != lOther$userPersonMarkers) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$markerMode = markerMode;
    final l$markerTypeID = markerTypeID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$userPersonMarkers = userPersonMarkers;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('markerMode') ? l$markerMode : const {},
      _$data.containsKey('markerTypeID') ? l$markerTypeID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('userPersonMarkers') ? l$userPersonMarkers : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkerTypeFilterInput<TRes> {
  factory CopyWith$Input$MarkerTypeFilterInput(
    Input$MarkerTypeFilterInput instance,
    TRes Function(Input$MarkerTypeFilterInput) then,
  ) = _CopyWithImpl$Input$MarkerTypeFilterInput;

  factory CopyWith$Input$MarkerTypeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkerTypeFilterInput;

  TRes call({
    List<Input$MarkerTypeFilterInput>? and,
    Input$MarkerModeOperationFilterInput? markerMode,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$MarkerTypeFilterInput>? or,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  });
  TRes and(
      Iterable<Input$MarkerTypeFilterInput>? Function(
              Iterable<
                  CopyWith$Input$MarkerTypeFilterInput<
                      Input$MarkerTypeFilterInput>>?)
          _fn);
  CopyWith$Input$MarkerModeOperationFilterInput<TRes> get markerMode;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$MarkerTypeFilterInput>? Function(
              Iterable<
                  CopyWith$Input$MarkerTypeFilterInput<
                      Input$MarkerTypeFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers;
}

class _CopyWithImpl$Input$MarkerTypeFilterInput<TRes>
    implements CopyWith$Input$MarkerTypeFilterInput<TRes> {
  _CopyWithImpl$Input$MarkerTypeFilterInput(
    this._instance,
    this._then,
  );

  final Input$MarkerTypeFilterInput _instance;

  final TRes Function(Input$MarkerTypeFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? markerMode = _undefined,
    Object? markerTypeID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? userPersonMarkers = _undefined,
  }) =>
      _then(Input$MarkerTypeFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$MarkerTypeFilterInput>?),
        if (markerMode != _undefined)
          'markerMode': (markerMode as Input$MarkerModeOperationFilterInput?),
        if (markerTypeID != _undefined)
          'markerTypeID':
              (markerTypeID as Input$ComparableInt64OperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$MarkerTypeFilterInput>?),
        if (userPersonMarkers != _undefined)
          'userPersonMarkers': (userPersonMarkers
              as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?),
      }));
  TRes and(
          Iterable<Input$MarkerTypeFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$MarkerTypeFilterInput<
                          Input$MarkerTypeFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$MarkerTypeFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$MarkerModeOperationFilterInput<TRes> get markerMode {
    final local$markerMode = _instance.markerMode;
    return local$markerMode == null
        ? CopyWith$Input$MarkerModeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$MarkerModeOperationFilterInput(
            local$markerMode, (e) => call(markerMode: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID {
    final local$markerTypeID = _instance.markerTypeID;
    return local$markerTypeID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$markerTypeID, (e) => call(markerTypeID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$MarkerTypeFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$MarkerTypeFilterInput<
                          Input$MarkerTypeFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$MarkerTypeFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers {
    final local$userPersonMarkers = _instance.userPersonMarkers;
    return local$userPersonMarkers == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            local$userPersonMarkers, (e) => call(userPersonMarkers: e));
  }
}

class _CopyWithStubImpl$Input$MarkerTypeFilterInput<TRes>
    implements CopyWith$Input$MarkerTypeFilterInput<TRes> {
  _CopyWithStubImpl$Input$MarkerTypeFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MarkerTypeFilterInput>? and,
    Input$MarkerModeOperationFilterInput? markerMode,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$MarkerTypeFilterInput>? or,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$MarkerModeOperationFilterInput<TRes> get markerMode =>
      CopyWith$Input$MarkerModeOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
              _res);
}

class Input$MarkerTypeSortInput {
  factory Input$MarkerTypeSortInput({
    Enum$SortEnumType? markerMode,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      Input$MarkerTypeSortInput._({
        if (markerMode != null) r'markerMode': markerMode,
        if (markerTypeID != null) r'markerTypeID': markerTypeID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
      });

  Input$MarkerTypeSortInput._(this._$data);

  factory Input$MarkerTypeSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('markerMode')) {
      final l$markerMode = data['markerMode'];
      result$data['markerMode'] = l$markerMode == null
          ? null
          : fromJson$Enum$SortEnumType((l$markerMode as String));
    }
    if (data.containsKey('markerTypeID')) {
      final l$markerTypeID = data['markerTypeID'];
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : fromJson$Enum$SortEnumType((l$markerTypeID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    return Input$MarkerTypeSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get markerMode =>
      (_$data['markerMode'] as Enum$SortEnumType?);
  Enum$SortEnumType? get markerTypeID =>
      (_$data['markerTypeID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('markerMode')) {
      final l$markerMode = markerMode;
      result$data['markerMode'] =
          l$markerMode == null ? null : toJson$Enum$SortEnumType(l$markerMode);
    }
    if (_$data.containsKey('markerTypeID')) {
      final l$markerTypeID = markerTypeID;
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : toJson$Enum$SortEnumType(l$markerTypeID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    return result$data;
  }

  CopyWith$Input$MarkerTypeSortInput<Input$MarkerTypeSortInput> get copyWith =>
      CopyWith$Input$MarkerTypeSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkerTypeSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$markerMode = markerMode;
    final lOther$markerMode = other.markerMode;
    if (_$data.containsKey('markerMode') !=
        other._$data.containsKey('markerMode')) {
      return false;
    }
    if (l$markerMode != lOther$markerMode) {
      return false;
    }
    final l$markerTypeID = markerTypeID;
    final lOther$markerTypeID = other.markerTypeID;
    if (_$data.containsKey('markerTypeID') !=
        other._$data.containsKey('markerTypeID')) {
      return false;
    }
    if (l$markerTypeID != lOther$markerTypeID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$markerMode = markerMode;
    final l$markerTypeID = markerTypeID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('markerMode') ? l$markerMode : const {},
      _$data.containsKey('markerTypeID') ? l$markerTypeID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkerTypeSortInput<TRes> {
  factory CopyWith$Input$MarkerTypeSortInput(
    Input$MarkerTypeSortInput instance,
    TRes Function(Input$MarkerTypeSortInput) then,
  ) = _CopyWithImpl$Input$MarkerTypeSortInput;

  factory CopyWith$Input$MarkerTypeSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkerTypeSortInput;

  TRes call({
    Enum$SortEnumType? markerMode,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  });
}

class _CopyWithImpl$Input$MarkerTypeSortInput<TRes>
    implements CopyWith$Input$MarkerTypeSortInput<TRes> {
  _CopyWithImpl$Input$MarkerTypeSortInput(
    this._instance,
    this._then,
  );

  final Input$MarkerTypeSortInput _instance;

  final TRes Function(Input$MarkerTypeSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? markerMode = _undefined,
    Object? markerTypeID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$MarkerTypeSortInput._({
        ..._instance._$data,
        if (markerMode != _undefined)
          'markerMode': (markerMode as Enum$SortEnumType?),
        if (markerTypeID != _undefined)
          'markerTypeID': (markerTypeID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$MarkerTypeSortInput<TRes>
    implements CopyWith$Input$MarkerTypeSortInput<TRes> {
  _CopyWithStubImpl$Input$MarkerTypeSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? markerMode,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
  }) =>
      _res;
}

class Input$MunicipalityFilterInput {
  factory Input$MunicipalityFilterInput({
    List<Input$MunicipalityFilterInput>? and,
    Input$ListFilterInputTypeOfAreaFilterInput? areas,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$MunicipalityFilterInput>? or,
    Input$ProvinceFilterInput? province,
    Input$ComparableInt64OperationFilterInput? provinceID,
  }) =>
      Input$MunicipalityFilterInput._({
        if (and != null) r'and': and,
        if (areas != null) r'areas': areas,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (municipalityID != null) r'municipalityID': municipalityID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (province != null) r'province': province,
        if (provinceID != null) r'provinceID': provinceID,
      });

  Input$MunicipalityFilterInput._(this._$data);

  factory Input$MunicipalityFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$MunicipalityFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('areas')) {
      final l$areas = data['areas'];
      result$data['areas'] = l$areas == null
          ? null
          : Input$ListFilterInputTypeOfAreaFilterInput.fromJson(
              (l$areas as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('municipalityID')) {
      final l$municipalityID = data['municipalityID'];
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$municipalityID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$MunicipalityFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('province')) {
      final l$province = data['province'];
      result$data['province'] = l$province == null
          ? null
          : Input$ProvinceFilterInput.fromJson(
              (l$province as Map<String, dynamic>));
    }
    if (data.containsKey('provinceID')) {
      final l$provinceID = data['provinceID'];
      result$data['provinceID'] = l$provinceID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$provinceID as Map<String, dynamic>));
    }
    return Input$MunicipalityFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MunicipalityFilterInput>? get and =>
      (_$data['and'] as List<Input$MunicipalityFilterInput>?);
  Input$ListFilterInputTypeOfAreaFilterInput? get areas =>
      (_$data['areas'] as Input$ListFilterInputTypeOfAreaFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get municipalityID =>
      (_$data['municipalityID'] as Input$ComparableInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$MunicipalityFilterInput>? get or =>
      (_$data['or'] as List<Input$MunicipalityFilterInput>?);
  Input$ProvinceFilterInput? get province =>
      (_$data['province'] as Input$ProvinceFilterInput?);
  Input$ComparableInt64OperationFilterInput? get provinceID =>
      (_$data['provinceID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('areas')) {
      final l$areas = areas;
      result$data['areas'] = l$areas?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('municipalityID')) {
      final l$municipalityID = municipalityID;
      result$data['municipalityID'] = l$municipalityID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('province')) {
      final l$province = province;
      result$data['province'] = l$province?.toJson();
    }
    if (_$data.containsKey('provinceID')) {
      final l$provinceID = provinceID;
      result$data['provinceID'] = l$provinceID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MunicipalityFilterInput<Input$MunicipalityFilterInput>
      get copyWith => CopyWith$Input$MunicipalityFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MunicipalityFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$areas = areas;
    final lOther$areas = other.areas;
    if (_$data.containsKey('areas') != other._$data.containsKey('areas')) {
      return false;
    }
    if (l$areas != lOther$areas) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (_$data.containsKey('municipalityID') !=
        other._$data.containsKey('municipalityID')) {
      return false;
    }
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$province = province;
    final lOther$province = other.province;
    if (_$data.containsKey('province') !=
        other._$data.containsKey('province')) {
      return false;
    }
    if (l$province != lOther$province) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (_$data.containsKey('provinceID') !=
        other._$data.containsKey('provinceID')) {
      return false;
    }
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$areas = areas;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$municipalityID = municipalityID;
    final l$name = name;
    final l$or = or;
    final l$province = province;
    final l$provinceID = provinceID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('areas') ? l$areas : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('municipalityID') ? l$municipalityID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('province') ? l$province : const {},
      _$data.containsKey('provinceID') ? l$provinceID : const {},
    ]);
  }
}

abstract class CopyWith$Input$MunicipalityFilterInput<TRes> {
  factory CopyWith$Input$MunicipalityFilterInput(
    Input$MunicipalityFilterInput instance,
    TRes Function(Input$MunicipalityFilterInput) then,
  ) = _CopyWithImpl$Input$MunicipalityFilterInput;

  factory CopyWith$Input$MunicipalityFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MunicipalityFilterInput;

  TRes call({
    List<Input$MunicipalityFilterInput>? and,
    Input$ListFilterInputTypeOfAreaFilterInput? areas,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$MunicipalityFilterInput>? or,
    Input$ProvinceFilterInput? province,
    Input$ComparableInt64OperationFilterInput? provinceID,
  });
  TRes and(
      Iterable<Input$MunicipalityFilterInput>? Function(
              Iterable<
                  CopyWith$Input$MunicipalityFilterInput<
                      Input$MunicipalityFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> get areas;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$MunicipalityFilterInput>? Function(
              Iterable<
                  CopyWith$Input$MunicipalityFilterInput<
                      Input$MunicipalityFilterInput>>?)
          _fn);
  CopyWith$Input$ProvinceFilterInput<TRes> get province;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID;
}

class _CopyWithImpl$Input$MunicipalityFilterInput<TRes>
    implements CopyWith$Input$MunicipalityFilterInput<TRes> {
  _CopyWithImpl$Input$MunicipalityFilterInput(
    this._instance,
    this._then,
  );

  final Input$MunicipalityFilterInput _instance;

  final TRes Function(Input$MunicipalityFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? areas = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? municipalityID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? province = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$MunicipalityFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$MunicipalityFilterInput>?),
        if (areas != _undefined)
          'areas': (areas as Input$ListFilterInputTypeOfAreaFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (municipalityID != _undefined)
          'municipalityID':
              (municipalityID as Input$ComparableInt64OperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$MunicipalityFilterInput>?),
        if (province != _undefined)
          'province': (province as Input$ProvinceFilterInput?),
        if (provinceID != _undefined)
          'provinceID':
              (provinceID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$MunicipalityFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$MunicipalityFilterInput<
                          Input$MunicipalityFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$MunicipalityFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> get areas {
    final local$areas = _instance.areas;
    return local$areas == null
        ? CopyWith$Input$ListFilterInputTypeOfAreaFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfAreaFilterInput(
            local$areas, (e) => call(areas: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID {
    final local$municipalityID = _instance.municipalityID;
    return local$municipalityID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$municipalityID, (e) => call(municipalityID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$MunicipalityFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$MunicipalityFilterInput<
                          Input$MunicipalityFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$MunicipalityFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ProvinceFilterInput<TRes> get province {
    final local$province = _instance.province;
    return local$province == null
        ? CopyWith$Input$ProvinceFilterInput.stub(_then(_instance))
        : CopyWith$Input$ProvinceFilterInput(
            local$province, (e) => call(province: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID {
    final local$provinceID = _instance.provinceID;
    return local$provinceID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$provinceID, (e) => call(provinceID: e));
  }
}

class _CopyWithStubImpl$Input$MunicipalityFilterInput<TRes>
    implements CopyWith$Input$MunicipalityFilterInput<TRes> {
  _CopyWithStubImpl$Input$MunicipalityFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MunicipalityFilterInput>? and,
    Input$ListFilterInputTypeOfAreaFilterInput? areas,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ComparableInt64OperationFilterInput? municipalityID,
    Input$StringOperationFilterInput? name,
    List<Input$MunicipalityFilterInput>? or,
    Input$ProvinceFilterInput? province,
    Input$ComparableInt64OperationFilterInput? provinceID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfAreaFilterInput<TRes> get areas =>
      CopyWith$Input$ListFilterInputTypeOfAreaFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get municipalityID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ProvinceFilterInput<TRes> get province =>
      CopyWith$Input$ProvinceFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$MunicipalitySortInput {
  factory Input$MunicipalitySortInput({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
    Input$ProvinceSortInput? province,
    Enum$SortEnumType? provinceID,
  }) =>
      Input$MunicipalitySortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (municipalityID != null) r'municipalityID': municipalityID,
        if (name != null) r'name': name,
        if (province != null) r'province': province,
        if (provinceID != null) r'provinceID': provinceID,
      });

  Input$MunicipalitySortInput._(this._$data);

  factory Input$MunicipalitySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('municipalityID')) {
      final l$municipalityID = data['municipalityID'];
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : fromJson$Enum$SortEnumType((l$municipalityID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('province')) {
      final l$province = data['province'];
      result$data['province'] = l$province == null
          ? null
          : Input$ProvinceSortInput.fromJson(
              (l$province as Map<String, dynamic>));
    }
    if (data.containsKey('provinceID')) {
      final l$provinceID = data['provinceID'];
      result$data['provinceID'] = l$provinceID == null
          ? null
          : fromJson$Enum$SortEnumType((l$provinceID as String));
    }
    return Input$MunicipalitySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get municipalityID =>
      (_$data['municipalityID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Input$ProvinceSortInput? get province =>
      (_$data['province'] as Input$ProvinceSortInput?);
  Enum$SortEnumType? get provinceID =>
      (_$data['provinceID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('municipalityID')) {
      final l$municipalityID = municipalityID;
      result$data['municipalityID'] = l$municipalityID == null
          ? null
          : toJson$Enum$SortEnumType(l$municipalityID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('province')) {
      final l$province = province;
      result$data['province'] = l$province?.toJson();
    }
    if (_$data.containsKey('provinceID')) {
      final l$provinceID = provinceID;
      result$data['provinceID'] =
          l$provinceID == null ? null : toJson$Enum$SortEnumType(l$provinceID);
    }
    return result$data;
  }

  CopyWith$Input$MunicipalitySortInput<Input$MunicipalitySortInput>
      get copyWith => CopyWith$Input$MunicipalitySortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MunicipalitySortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$municipalityID = municipalityID;
    final lOther$municipalityID = other.municipalityID;
    if (_$data.containsKey('municipalityID') !=
        other._$data.containsKey('municipalityID')) {
      return false;
    }
    if (l$municipalityID != lOther$municipalityID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$province = province;
    final lOther$province = other.province;
    if (_$data.containsKey('province') !=
        other._$data.containsKey('province')) {
      return false;
    }
    if (l$province != lOther$province) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (_$data.containsKey('provinceID') !=
        other._$data.containsKey('provinceID')) {
      return false;
    }
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$municipalityID = municipalityID;
    final l$name = name;
    final l$province = province;
    final l$provinceID = provinceID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('municipalityID') ? l$municipalityID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('province') ? l$province : const {},
      _$data.containsKey('provinceID') ? l$provinceID : const {},
    ]);
  }
}

abstract class CopyWith$Input$MunicipalitySortInput<TRes> {
  factory CopyWith$Input$MunicipalitySortInput(
    Input$MunicipalitySortInput instance,
    TRes Function(Input$MunicipalitySortInput) then,
  ) = _CopyWithImpl$Input$MunicipalitySortInput;

  factory CopyWith$Input$MunicipalitySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MunicipalitySortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
    Input$ProvinceSortInput? province,
    Enum$SortEnumType? provinceID,
  });
  CopyWith$Input$ProvinceSortInput<TRes> get province;
}

class _CopyWithImpl$Input$MunicipalitySortInput<TRes>
    implements CopyWith$Input$MunicipalitySortInput<TRes> {
  _CopyWithImpl$Input$MunicipalitySortInput(
    this._instance,
    this._then,
  );

  final Input$MunicipalitySortInput _instance;

  final TRes Function(Input$MunicipalitySortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? municipalityID = _undefined,
    Object? name = _undefined,
    Object? province = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$MunicipalitySortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (municipalityID != _undefined)
          'municipalityID': (municipalityID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (province != _undefined)
          'province': (province as Input$ProvinceSortInput?),
        if (provinceID != _undefined)
          'provinceID': (provinceID as Enum$SortEnumType?),
      }));
  CopyWith$Input$ProvinceSortInput<TRes> get province {
    final local$province = _instance.province;
    return local$province == null
        ? CopyWith$Input$ProvinceSortInput.stub(_then(_instance))
        : CopyWith$Input$ProvinceSortInput(
            local$province, (e) => call(province: e));
  }
}

class _CopyWithStubImpl$Input$MunicipalitySortInput<TRes>
    implements CopyWith$Input$MunicipalitySortInput<TRes> {
  _CopyWithStubImpl$Input$MunicipalitySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? municipalityID,
    Enum$SortEnumType? name,
    Input$ProvinceSortInput? province,
    Enum$SortEnumType? provinceID,
  }) =>
      _res;
  CopyWith$Input$ProvinceSortInput<TRes> get province =>
      CopyWith$Input$ProvinceSortInput.stub(_res);
}

class Input$PermissionOperationFilterInput {
  factory Input$PermissionOperationFilterInput({
    Enum$Permission? eq,
    List<Enum$Permission>? $in,
    Enum$Permission? neq,
    List<Enum$Permission>? nin,
  }) =>
      Input$PermissionOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
      });

  Input$PermissionOperationFilterInput._(this._$data);

  factory Input$PermissionOperationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$Permission((l$eq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$Permission((e as String)))
          .toList();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] =
          l$neq == null ? null : fromJson$Enum$Permission((l$neq as String));
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$Permission((e as String)))
          .toList();
    }
    return Input$PermissionOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$Permission? get eq => (_$data['eq'] as Enum$Permission?);
  List<Enum$Permission>? get $in => (_$data['in'] as List<Enum$Permission>?);
  Enum$Permission? get neq => (_$data['neq'] as Enum$Permission?);
  List<Enum$Permission>? get nin => (_$data['nin'] as List<Enum$Permission>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$Permission(l$eq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$Permission(e)).toList();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$Permission(l$neq);
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] =
          l$nin?.map((e) => toJson$Enum$Permission(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$PermissionOperationFilterInput<
          Input$PermissionOperationFilterInput>
      get copyWith => CopyWith$Input$PermissionOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PermissionOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$$in = $in;
    final l$neq = neq;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PermissionOperationFilterInput<TRes> {
  factory CopyWith$Input$PermissionOperationFilterInput(
    Input$PermissionOperationFilterInput instance,
    TRes Function(Input$PermissionOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PermissionOperationFilterInput;

  factory CopyWith$Input$PermissionOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PermissionOperationFilterInput;

  TRes call({
    Enum$Permission? eq,
    List<Enum$Permission>? $in,
    Enum$Permission? neq,
    List<Enum$Permission>? nin,
  });
}

class _CopyWithImpl$Input$PermissionOperationFilterInput<TRes>
    implements CopyWith$Input$PermissionOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PermissionOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PermissionOperationFilterInput _instance;

  final TRes Function(Input$PermissionOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
  }) =>
      _then(Input$PermissionOperationFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$Permission?),
        if ($in != _undefined) 'in': ($in as List<Enum$Permission>?),
        if (neq != _undefined) 'neq': (neq as Enum$Permission?),
        if (nin != _undefined) 'nin': (nin as List<Enum$Permission>?),
      }));
}

class _CopyWithStubImpl$Input$PermissionOperationFilterInput<TRes>
    implements CopyWith$Input$PermissionOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PermissionOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$Permission? eq,
    List<Enum$Permission>? $in,
    Enum$Permission? neq,
    List<Enum$Permission>? nin,
  }) =>
      _res;
}

class Input$PersonFilterInput {
  factory Input$PersonFilterInput({
    List<Input$PersonFilterInput>? and,
    Input$StringOperationFilterInput? apellidos,
    Input$StringOperationFilterInput? cI,
    Input$BooleanOperationFilterInput? isFamily,
    Input$BooleanOperationFilterInput? isFather,
    Input$BooleanOperationFilterInput? isMother,
    Input$BooleanOperationFilterInput? isSon,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$PersonFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? personID,
    Input$PersonStatusFilterInput? personStatus,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfPersonVariableFilterInput?
        referredPersonVariableValues,
    Input$ComparableNullableOfInt64OperationFilterInput? statusID,
    Input$StringOperationFilterInput? tutorCI,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      Input$PersonFilterInput._({
        if (and != null) r'and': and,
        if (apellidos != null) r'apellidos': apellidos,
        if (cI != null) r'cI': cI,
        if (isFamily != null) r'isFamily': isFamily,
        if (isFather != null) r'isFather': isFather,
        if (isMother != null) r'isMother': isMother,
        if (isSon != null) r'isSon': isSon,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (nombre != null) r'nombre': nombre,
        if (or != null) r'or': or,
        if (personID != null) r'personID': personID,
        if (personStatus != null) r'personStatus': personStatus,
        if (personVariables != null) r'personVariables': personVariables,
        if (referredPersonVariableValues != null)
          r'referredPersonVariableValues': referredPersonVariableValues,
        if (statusID != null) r'statusID': statusID,
        if (tutorCI != null) r'tutorCI': tutorCI,
        if (userPersonMarkers != null) r'userPersonMarkers': userPersonMarkers,
      });

  Input$PersonFilterInput._(this._$data);

  factory Input$PersonFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$PersonFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('apellidos')) {
      final l$apellidos = data['apellidos'];
      result$data['apellidos'] = l$apellidos == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$apellidos as Map<String, dynamic>));
    }
    if (data.containsKey('cI')) {
      final l$cI = data['cI'];
      result$data['cI'] = l$cI == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$cI as Map<String, dynamic>));
    }
    if (data.containsKey('isFamily')) {
      final l$isFamily = data['isFamily'];
      result$data['isFamily'] = l$isFamily == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isFamily as Map<String, dynamic>));
    }
    if (data.containsKey('isFather')) {
      final l$isFather = data['isFather'];
      result$data['isFather'] = l$isFather == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isFather as Map<String, dynamic>));
    }
    if (data.containsKey('isMother')) {
      final l$isMother = data['isMother'];
      result$data['isMother'] = l$isMother == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isMother as Map<String, dynamic>));
    }
    if (data.containsKey('isSon')) {
      final l$isSon = data['isSon'];
      result$data['isSon'] = l$isSon == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isSon as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('nombre')) {
      final l$nombre = data['nombre'];
      result$data['nombre'] = l$nombre == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nombre as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$PersonFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$personID as Map<String, dynamic>));
    }
    if (data.containsKey('personStatus')) {
      final l$personStatus = data['personStatus'];
      result$data['personStatus'] = l$personStatus == null
          ? null
          : Input$PersonStatusFilterInput.fromJson(
              (l$personStatus as Map<String, dynamic>));
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    if (data.containsKey('referredPersonVariableValues')) {
      final l$referredPersonVariableValues =
          data['referredPersonVariableValues'];
      result$data['referredPersonVariableValues'] =
          l$referredPersonVariableValues == null
              ? null
              : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
                  (l$referredPersonVariableValues as Map<String, dynamic>));
    }
    if (data.containsKey('statusID')) {
      final l$statusID = data['statusID'];
      result$data['statusID'] = l$statusID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$statusID as Map<String, dynamic>));
    }
    if (data.containsKey('tutorCI')) {
      final l$tutorCI = data['tutorCI'];
      result$data['tutorCI'] = l$tutorCI == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$tutorCI as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = data['userPersonMarkers'];
      result$data['userPersonMarkers'] = l$userPersonMarkers == null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.fromJson(
              (l$userPersonMarkers as Map<String, dynamic>));
    }
    return Input$PersonFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PersonFilterInput>? get and =>
      (_$data['and'] as List<Input$PersonFilterInput>?);
  Input$StringOperationFilterInput? get apellidos =>
      (_$data['apellidos'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get cI =>
      (_$data['cI'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get isFamily =>
      (_$data['isFamily'] as Input$BooleanOperationFilterInput?);
  Input$BooleanOperationFilterInput? get isFather =>
      (_$data['isFather'] as Input$BooleanOperationFilterInput?);
  Input$BooleanOperationFilterInput? get isMother =>
      (_$data['isMother'] as Input$BooleanOperationFilterInput?);
  Input$BooleanOperationFilterInput? get isSon =>
      (_$data['isSon'] as Input$BooleanOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get nombre =>
      (_$data['nombre'] as Input$StringOperationFilterInput?);
  List<Input$PersonFilterInput>? get or =>
      (_$data['or'] as List<Input$PersonFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get personID =>
      (_$data['personID'] as Input$ComparableInt64OperationFilterInput?);
  Input$PersonStatusFilterInput? get personStatus =>
      (_$data['personStatus'] as Input$PersonStatusFilterInput?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput?
      get referredPersonVariableValues =>
          (_$data['referredPersonVariableValues']
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get statusID =>
      (_$data['statusID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get tutorCI =>
      (_$data['tutorCI'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?
      get userPersonMarkers => (_$data['userPersonMarkers']
          as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('apellidos')) {
      final l$apellidos = apellidos;
      result$data['apellidos'] = l$apellidos?.toJson();
    }
    if (_$data.containsKey('cI')) {
      final l$cI = cI;
      result$data['cI'] = l$cI?.toJson();
    }
    if (_$data.containsKey('isFamily')) {
      final l$isFamily = isFamily;
      result$data['isFamily'] = l$isFamily?.toJson();
    }
    if (_$data.containsKey('isFather')) {
      final l$isFather = isFather;
      result$data['isFather'] = l$isFather?.toJson();
    }
    if (_$data.containsKey('isMother')) {
      final l$isMother = isMother;
      result$data['isMother'] = l$isMother?.toJson();
    }
    if (_$data.containsKey('isSon')) {
      final l$isSon = isSon;
      result$data['isSon'] = l$isSon?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('nombre')) {
      final l$nombre = nombre;
      result$data['nombre'] = l$nombre?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] = l$personID?.toJson();
    }
    if (_$data.containsKey('personStatus')) {
      final l$personStatus = personStatus;
      result$data['personStatus'] = l$personStatus?.toJson();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    if (_$data.containsKey('referredPersonVariableValues')) {
      final l$referredPersonVariableValues = referredPersonVariableValues;
      result$data['referredPersonVariableValues'] =
          l$referredPersonVariableValues?.toJson();
    }
    if (_$data.containsKey('statusID')) {
      final l$statusID = statusID;
      result$data['statusID'] = l$statusID?.toJson();
    }
    if (_$data.containsKey('tutorCI')) {
      final l$tutorCI = tutorCI;
      result$data['tutorCI'] = l$tutorCI?.toJson();
    }
    if (_$data.containsKey('userPersonMarkers')) {
      final l$userPersonMarkers = userPersonMarkers;
      result$data['userPersonMarkers'] = l$userPersonMarkers?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PersonFilterInput<Input$PersonFilterInput> get copyWith =>
      CopyWith$Input$PersonFilterInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$apellidos = apellidos;
    final lOther$apellidos = other.apellidos;
    if (_$data.containsKey('apellidos') !=
        other._$data.containsKey('apellidos')) {
      return false;
    }
    if (l$apellidos != lOther$apellidos) {
      return false;
    }
    final l$cI = cI;
    final lOther$cI = other.cI;
    if (_$data.containsKey('cI') != other._$data.containsKey('cI')) {
      return false;
    }
    if (l$cI != lOther$cI) {
      return false;
    }
    final l$isFamily = isFamily;
    final lOther$isFamily = other.isFamily;
    if (_$data.containsKey('isFamily') !=
        other._$data.containsKey('isFamily')) {
      return false;
    }
    if (l$isFamily != lOther$isFamily) {
      return false;
    }
    final l$isFather = isFather;
    final lOther$isFather = other.isFather;
    if (_$data.containsKey('isFather') !=
        other._$data.containsKey('isFather')) {
      return false;
    }
    if (l$isFather != lOther$isFather) {
      return false;
    }
    final l$isMother = isMother;
    final lOther$isMother = other.isMother;
    if (_$data.containsKey('isMother') !=
        other._$data.containsKey('isMother')) {
      return false;
    }
    if (l$isMother != lOther$isMother) {
      return false;
    }
    final l$isSon = isSon;
    final lOther$isSon = other.isSon;
    if (_$data.containsKey('isSon') != other._$data.containsKey('isSon')) {
      return false;
    }
    if (l$isSon != lOther$isSon) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (_$data.containsKey('nombre') != other._$data.containsKey('nombre')) {
      return false;
    }
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$personStatus = personStatus;
    final lOther$personStatus = other.personStatus;
    if (_$data.containsKey('personStatus') !=
        other._$data.containsKey('personStatus')) {
      return false;
    }
    if (l$personStatus != lOther$personStatus) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    final l$referredPersonVariableValues = referredPersonVariableValues;
    final lOther$referredPersonVariableValues =
        other.referredPersonVariableValues;
    if (_$data.containsKey('referredPersonVariableValues') !=
        other._$data.containsKey('referredPersonVariableValues')) {
      return false;
    }
    if (l$referredPersonVariableValues != lOther$referredPersonVariableValues) {
      return false;
    }
    final l$statusID = statusID;
    final lOther$statusID = other.statusID;
    if (_$data.containsKey('statusID') !=
        other._$data.containsKey('statusID')) {
      return false;
    }
    if (l$statusID != lOther$statusID) {
      return false;
    }
    final l$tutorCI = tutorCI;
    final lOther$tutorCI = other.tutorCI;
    if (_$data.containsKey('tutorCI') != other._$data.containsKey('tutorCI')) {
      return false;
    }
    if (l$tutorCI != lOther$tutorCI) {
      return false;
    }
    final l$userPersonMarkers = userPersonMarkers;
    final lOther$userPersonMarkers = other.userPersonMarkers;
    if (_$data.containsKey('userPersonMarkers') !=
        other._$data.containsKey('userPersonMarkers')) {
      return false;
    }
    if (l$userPersonMarkers != lOther$userPersonMarkers) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$apellidos = apellidos;
    final l$cI = cI;
    final l$isFamily = isFamily;
    final l$isFather = isFather;
    final l$isMother = isMother;
    final l$isSon = isSon;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$nombre = nombre;
    final l$or = or;
    final l$personID = personID;
    final l$personStatus = personStatus;
    final l$personVariables = personVariables;
    final l$referredPersonVariableValues = referredPersonVariableValues;
    final l$statusID = statusID;
    final l$tutorCI = tutorCI;
    final l$userPersonMarkers = userPersonMarkers;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('apellidos') ? l$apellidos : const {},
      _$data.containsKey('cI') ? l$cI : const {},
      _$data.containsKey('isFamily') ? l$isFamily : const {},
      _$data.containsKey('isFather') ? l$isFather : const {},
      _$data.containsKey('isMother') ? l$isMother : const {},
      _$data.containsKey('isSon') ? l$isSon : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('nombre') ? l$nombre : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('personStatus') ? l$personStatus : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
      _$data.containsKey('referredPersonVariableValues')
          ? l$referredPersonVariableValues
          : const {},
      _$data.containsKey('statusID') ? l$statusID : const {},
      _$data.containsKey('tutorCI') ? l$tutorCI : const {},
      _$data.containsKey('userPersonMarkers') ? l$userPersonMarkers : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonFilterInput<TRes> {
  factory CopyWith$Input$PersonFilterInput(
    Input$PersonFilterInput instance,
    TRes Function(Input$PersonFilterInput) then,
  ) = _CopyWithImpl$Input$PersonFilterInput;

  factory CopyWith$Input$PersonFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonFilterInput;

  TRes call({
    List<Input$PersonFilterInput>? and,
    Input$StringOperationFilterInput? apellidos,
    Input$StringOperationFilterInput? cI,
    Input$BooleanOperationFilterInput? isFamily,
    Input$BooleanOperationFilterInput? isFather,
    Input$BooleanOperationFilterInput? isMother,
    Input$BooleanOperationFilterInput? isSon,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$PersonFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? personID,
    Input$PersonStatusFilterInput? personStatus,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfPersonVariableFilterInput?
        referredPersonVariableValues,
    Input$ComparableNullableOfInt64OperationFilterInput? statusID,
    Input$StringOperationFilterInput? tutorCI,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  });
  TRes and(
      Iterable<Input$PersonFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonFilterInput<Input$PersonFilterInput>>?)
          _fn);
  CopyWith$Input$StringOperationFilterInput<TRes> get apellidos;
  CopyWith$Input$StringOperationFilterInput<TRes> get cI;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFamily;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFather;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isMother;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isSon;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get nombre;
  TRes or(
      Iterable<Input$PersonFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonFilterInput<Input$PersonFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personID;
  CopyWith$Input$PersonStatusFilterInput<TRes> get personStatus;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get referredPersonVariableValues;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get statusID;
  CopyWith$Input$StringOperationFilterInput<TRes> get tutorCI;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers;
}

class _CopyWithImpl$Input$PersonFilterInput<TRes>
    implements CopyWith$Input$PersonFilterInput<TRes> {
  _CopyWithImpl$Input$PersonFilterInput(
    this._instance,
    this._then,
  );

  final Input$PersonFilterInput _instance;

  final TRes Function(Input$PersonFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? apellidos = _undefined,
    Object? cI = _undefined,
    Object? isFamily = _undefined,
    Object? isFather = _undefined,
    Object? isMother = _undefined,
    Object? isSon = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? nombre = _undefined,
    Object? or = _undefined,
    Object? personID = _undefined,
    Object? personStatus = _undefined,
    Object? personVariables = _undefined,
    Object? referredPersonVariableValues = _undefined,
    Object? statusID = _undefined,
    Object? tutorCI = _undefined,
    Object? userPersonMarkers = _undefined,
  }) =>
      _then(Input$PersonFilterInput._({
        ..._instance._$data,
        if (and != _undefined) 'and': (and as List<Input$PersonFilterInput>?),
        if (apellidos != _undefined)
          'apellidos': (apellidos as Input$StringOperationFilterInput?),
        if (cI != _undefined) 'cI': (cI as Input$StringOperationFilterInput?),
        if (isFamily != _undefined)
          'isFamily': (isFamily as Input$BooleanOperationFilterInput?),
        if (isFather != _undefined)
          'isFather': (isFather as Input$BooleanOperationFilterInput?),
        if (isMother != _undefined)
          'isMother': (isMother as Input$BooleanOperationFilterInput?),
        if (isSon != _undefined)
          'isSon': (isSon as Input$BooleanOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (nombre != _undefined)
          'nombre': (nombre as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$PersonFilterInput>?),
        if (personID != _undefined)
          'personID': (personID as Input$ComparableInt64OperationFilterInput?),
        if (personStatus != _undefined)
          'personStatus': (personStatus as Input$PersonStatusFilterInput?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
        if (referredPersonVariableValues != _undefined)
          'referredPersonVariableValues': (referredPersonVariableValues
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
        if (statusID != _undefined)
          'statusID': (statusID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (tutorCI != _undefined)
          'tutorCI': (tutorCI as Input$StringOperationFilterInput?),
        if (userPersonMarkers != _undefined)
          'userPersonMarkers': (userPersonMarkers
              as Input$ListFilterInputTypeOfUserPersonMarkerFilterInput?),
      }));
  TRes and(
          Iterable<Input$PersonFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonFilterInput<
                          Input$PersonFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$PersonFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringOperationFilterInput<TRes> get apellidos {
    final local$apellidos = _instance.apellidos;
    return local$apellidos == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$apellidos, (e) => call(apellidos: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get cI {
    final local$cI = _instance.cI;
    return local$cI == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$cI, (e) => call(cI: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFamily {
    final local$isFamily = _instance.isFamily;
    return local$isFamily == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isFamily, (e) => call(isFamily: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFather {
    final local$isFather = _instance.isFather;
    return local$isFather == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isFather, (e) => call(isFather: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isMother {
    final local$isMother = _instance.isMother;
    return local$isMother == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isMother, (e) => call(isMother: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isSon {
    final local$isSon = _instance.isSon;
    return local$isSon == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isSon, (e) => call(isSon: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nombre {
    final local$nombre = _instance.nombre;
    return local$nombre == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nombre, (e) => call(nombre: e));
  }

  TRes or(
          Iterable<Input$PersonFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonFilterInput<
                          Input$PersonFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$PersonFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personID {
    final local$personID = _instance.personID;
    return local$personID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$personID, (e) => call(personID: e));
  }

  CopyWith$Input$PersonStatusFilterInput<TRes> get personStatus {
    final local$personStatus = _instance.personStatus;
    return local$personStatus == null
        ? CopyWith$Input$PersonStatusFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonStatusFilterInput(
            local$personStatus, (e) => call(personStatus: e));
  }

  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }

  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get referredPersonVariableValues {
    final local$referredPersonVariableValues =
        _instance.referredPersonVariableValues;
    return local$referredPersonVariableValues == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$referredPersonVariableValues,
            (e) => call(referredPersonVariableValues: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get statusID {
    final local$statusID = _instance.statusID;
    return local$statusID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$statusID, (e) => call(statusID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get tutorCI {
    final local$tutorCI = _instance.tutorCI;
    return local$tutorCI == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$tutorCI, (e) => call(tutorCI: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers {
    final local$userPersonMarkers = _instance.userPersonMarkers;
    return local$userPersonMarkers == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput(
            local$userPersonMarkers, (e) => call(userPersonMarkers: e));
  }
}

class _CopyWithStubImpl$Input$PersonFilterInput<TRes>
    implements CopyWith$Input$PersonFilterInput<TRes> {
  _CopyWithStubImpl$Input$PersonFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PersonFilterInput>? and,
    Input$StringOperationFilterInput? apellidos,
    Input$StringOperationFilterInput? cI,
    Input$BooleanOperationFilterInput? isFamily,
    Input$BooleanOperationFilterInput? isFather,
    Input$BooleanOperationFilterInput? isMother,
    Input$BooleanOperationFilterInput? isSon,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? nombre,
    List<Input$PersonFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? personID,
    Input$PersonStatusFilterInput? personStatus,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfPersonVariableFilterInput?
        referredPersonVariableValues,
    Input$ComparableNullableOfInt64OperationFilterInput? statusID,
    Input$StringOperationFilterInput? tutorCI,
    Input$ListFilterInputTypeOfUserPersonMarkerFilterInput? userPersonMarkers,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$StringOperationFilterInput<TRes> get apellidos =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get cI =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFamily =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isFather =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isMother =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isSon =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get nombre =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$PersonStatusFilterInput<TRes> get personStatus =>
      CopyWith$Input$PersonStatusFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get referredPersonVariableValues =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get statusID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get tutorCI =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput<TRes>
      get userPersonMarkers =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerFilterInput.stub(
              _res);
}

class Input$PersonSortInput {
  factory Input$PersonSortInput({
    Enum$SortEnumType? apellidos,
    Enum$SortEnumType? cI,
    Enum$SortEnumType? isFamily,
    Enum$SortEnumType? isFather,
    Enum$SortEnumType? isMother,
    Enum$SortEnumType? isSon,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? personID,
    Input$PersonStatusSortInput? personStatus,
    Enum$SortEnumType? statusID,
    Enum$SortEnumType? tutorCI,
  }) =>
      Input$PersonSortInput._({
        if (apellidos != null) r'apellidos': apellidos,
        if (cI != null) r'cI': cI,
        if (isFamily != null) r'isFamily': isFamily,
        if (isFather != null) r'isFather': isFather,
        if (isMother != null) r'isMother': isMother,
        if (isSon != null) r'isSon': isSon,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (nombre != null) r'nombre': nombre,
        if (personID != null) r'personID': personID,
        if (personStatus != null) r'personStatus': personStatus,
        if (statusID != null) r'statusID': statusID,
        if (tutorCI != null) r'tutorCI': tutorCI,
      });

  Input$PersonSortInput._(this._$data);

  factory Input$PersonSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('apellidos')) {
      final l$apellidos = data['apellidos'];
      result$data['apellidos'] = l$apellidos == null
          ? null
          : fromJson$Enum$SortEnumType((l$apellidos as String));
    }
    if (data.containsKey('cI')) {
      final l$cI = data['cI'];
      result$data['cI'] =
          l$cI == null ? null : fromJson$Enum$SortEnumType((l$cI as String));
    }
    if (data.containsKey('isFamily')) {
      final l$isFamily = data['isFamily'];
      result$data['isFamily'] = l$isFamily == null
          ? null
          : fromJson$Enum$SortEnumType((l$isFamily as String));
    }
    if (data.containsKey('isFather')) {
      final l$isFather = data['isFather'];
      result$data['isFather'] = l$isFather == null
          ? null
          : fromJson$Enum$SortEnumType((l$isFather as String));
    }
    if (data.containsKey('isMother')) {
      final l$isMother = data['isMother'];
      result$data['isMother'] = l$isMother == null
          ? null
          : fromJson$Enum$SortEnumType((l$isMother as String));
    }
    if (data.containsKey('isSon')) {
      final l$isSon = data['isSon'];
      result$data['isSon'] = l$isSon == null
          ? null
          : fromJson$Enum$SortEnumType((l$isSon as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('nombre')) {
      final l$nombre = data['nombre'];
      result$data['nombre'] = l$nombre == null
          ? null
          : fromJson$Enum$SortEnumType((l$nombre as String));
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personID as String));
    }
    if (data.containsKey('personStatus')) {
      final l$personStatus = data['personStatus'];
      result$data['personStatus'] = l$personStatus == null
          ? null
          : Input$PersonStatusSortInput.fromJson(
              (l$personStatus as Map<String, dynamic>));
    }
    if (data.containsKey('statusID')) {
      final l$statusID = data['statusID'];
      result$data['statusID'] = l$statusID == null
          ? null
          : fromJson$Enum$SortEnumType((l$statusID as String));
    }
    if (data.containsKey('tutorCI')) {
      final l$tutorCI = data['tutorCI'];
      result$data['tutorCI'] = l$tutorCI == null
          ? null
          : fromJson$Enum$SortEnumType((l$tutorCI as String));
    }
    return Input$PersonSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get apellidos =>
      (_$data['apellidos'] as Enum$SortEnumType?);
  Enum$SortEnumType? get cI => (_$data['cI'] as Enum$SortEnumType?);
  Enum$SortEnumType? get isFamily => (_$data['isFamily'] as Enum$SortEnumType?);
  Enum$SortEnumType? get isFather => (_$data['isFather'] as Enum$SortEnumType?);
  Enum$SortEnumType? get isMother => (_$data['isMother'] as Enum$SortEnumType?);
  Enum$SortEnumType? get isSon => (_$data['isSon'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get nombre => (_$data['nombre'] as Enum$SortEnumType?);
  Enum$SortEnumType? get personID => (_$data['personID'] as Enum$SortEnumType?);
  Input$PersonStatusSortInput? get personStatus =>
      (_$data['personStatus'] as Input$PersonStatusSortInput?);
  Enum$SortEnumType? get statusID => (_$data['statusID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get tutorCI => (_$data['tutorCI'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('apellidos')) {
      final l$apellidos = apellidos;
      result$data['apellidos'] =
          l$apellidos == null ? null : toJson$Enum$SortEnumType(l$apellidos);
    }
    if (_$data.containsKey('cI')) {
      final l$cI = cI;
      result$data['cI'] = l$cI == null ? null : toJson$Enum$SortEnumType(l$cI);
    }
    if (_$data.containsKey('isFamily')) {
      final l$isFamily = isFamily;
      result$data['isFamily'] =
          l$isFamily == null ? null : toJson$Enum$SortEnumType(l$isFamily);
    }
    if (_$data.containsKey('isFather')) {
      final l$isFather = isFather;
      result$data['isFather'] =
          l$isFather == null ? null : toJson$Enum$SortEnumType(l$isFather);
    }
    if (_$data.containsKey('isMother')) {
      final l$isMother = isMother;
      result$data['isMother'] =
          l$isMother == null ? null : toJson$Enum$SortEnumType(l$isMother);
    }
    if (_$data.containsKey('isSon')) {
      final l$isSon = isSon;
      result$data['isSon'] =
          l$isSon == null ? null : toJson$Enum$SortEnumType(l$isSon);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('nombre')) {
      final l$nombre = nombre;
      result$data['nombre'] =
          l$nombre == null ? null : toJson$Enum$SortEnumType(l$nombre);
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] =
          l$personID == null ? null : toJson$Enum$SortEnumType(l$personID);
    }
    if (_$data.containsKey('personStatus')) {
      final l$personStatus = personStatus;
      result$data['personStatus'] = l$personStatus?.toJson();
    }
    if (_$data.containsKey('statusID')) {
      final l$statusID = statusID;
      result$data['statusID'] =
          l$statusID == null ? null : toJson$Enum$SortEnumType(l$statusID);
    }
    if (_$data.containsKey('tutorCI')) {
      final l$tutorCI = tutorCI;
      result$data['tutorCI'] =
          l$tutorCI == null ? null : toJson$Enum$SortEnumType(l$tutorCI);
    }
    return result$data;
  }

  CopyWith$Input$PersonSortInput<Input$PersonSortInput> get copyWith =>
      CopyWith$Input$PersonSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonSortInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$apellidos = apellidos;
    final lOther$apellidos = other.apellidos;
    if (_$data.containsKey('apellidos') !=
        other._$data.containsKey('apellidos')) {
      return false;
    }
    if (l$apellidos != lOther$apellidos) {
      return false;
    }
    final l$cI = cI;
    final lOther$cI = other.cI;
    if (_$data.containsKey('cI') != other._$data.containsKey('cI')) {
      return false;
    }
    if (l$cI != lOther$cI) {
      return false;
    }
    final l$isFamily = isFamily;
    final lOther$isFamily = other.isFamily;
    if (_$data.containsKey('isFamily') !=
        other._$data.containsKey('isFamily')) {
      return false;
    }
    if (l$isFamily != lOther$isFamily) {
      return false;
    }
    final l$isFather = isFather;
    final lOther$isFather = other.isFather;
    if (_$data.containsKey('isFather') !=
        other._$data.containsKey('isFather')) {
      return false;
    }
    if (l$isFather != lOther$isFather) {
      return false;
    }
    final l$isMother = isMother;
    final lOther$isMother = other.isMother;
    if (_$data.containsKey('isMother') !=
        other._$data.containsKey('isMother')) {
      return false;
    }
    if (l$isMother != lOther$isMother) {
      return false;
    }
    final l$isSon = isSon;
    final lOther$isSon = other.isSon;
    if (_$data.containsKey('isSon') != other._$data.containsKey('isSon')) {
      return false;
    }
    if (l$isSon != lOther$isSon) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$nombre = nombre;
    final lOther$nombre = other.nombre;
    if (_$data.containsKey('nombre') != other._$data.containsKey('nombre')) {
      return false;
    }
    if (l$nombre != lOther$nombre) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$personStatus = personStatus;
    final lOther$personStatus = other.personStatus;
    if (_$data.containsKey('personStatus') !=
        other._$data.containsKey('personStatus')) {
      return false;
    }
    if (l$personStatus != lOther$personStatus) {
      return false;
    }
    final l$statusID = statusID;
    final lOther$statusID = other.statusID;
    if (_$data.containsKey('statusID') !=
        other._$data.containsKey('statusID')) {
      return false;
    }
    if (l$statusID != lOther$statusID) {
      return false;
    }
    final l$tutorCI = tutorCI;
    final lOther$tutorCI = other.tutorCI;
    if (_$data.containsKey('tutorCI') != other._$data.containsKey('tutorCI')) {
      return false;
    }
    if (l$tutorCI != lOther$tutorCI) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$apellidos = apellidos;
    final l$cI = cI;
    final l$isFamily = isFamily;
    final l$isFather = isFather;
    final l$isMother = isMother;
    final l$isSon = isSon;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$nombre = nombre;
    final l$personID = personID;
    final l$personStatus = personStatus;
    final l$statusID = statusID;
    final l$tutorCI = tutorCI;
    return Object.hashAll([
      _$data.containsKey('apellidos') ? l$apellidos : const {},
      _$data.containsKey('cI') ? l$cI : const {},
      _$data.containsKey('isFamily') ? l$isFamily : const {},
      _$data.containsKey('isFather') ? l$isFather : const {},
      _$data.containsKey('isMother') ? l$isMother : const {},
      _$data.containsKey('isSon') ? l$isSon : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('nombre') ? l$nombre : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('personStatus') ? l$personStatus : const {},
      _$data.containsKey('statusID') ? l$statusID : const {},
      _$data.containsKey('tutorCI') ? l$tutorCI : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonSortInput<TRes> {
  factory CopyWith$Input$PersonSortInput(
    Input$PersonSortInput instance,
    TRes Function(Input$PersonSortInput) then,
  ) = _CopyWithImpl$Input$PersonSortInput;

  factory CopyWith$Input$PersonSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonSortInput;

  TRes call({
    Enum$SortEnumType? apellidos,
    Enum$SortEnumType? cI,
    Enum$SortEnumType? isFamily,
    Enum$SortEnumType? isFather,
    Enum$SortEnumType? isMother,
    Enum$SortEnumType? isSon,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? personID,
    Input$PersonStatusSortInput? personStatus,
    Enum$SortEnumType? statusID,
    Enum$SortEnumType? tutorCI,
  });
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
  CopyWith$Input$PersonStatusSortInput<TRes> get personStatus;
}

class _CopyWithImpl$Input$PersonSortInput<TRes>
    implements CopyWith$Input$PersonSortInput<TRes> {
  _CopyWithImpl$Input$PersonSortInput(
    this._instance,
    this._then,
  );

  final Input$PersonSortInput _instance;

  final TRes Function(Input$PersonSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? apellidos = _undefined,
    Object? cI = _undefined,
    Object? isFamily = _undefined,
    Object? isFather = _undefined,
    Object? isMother = _undefined,
    Object? isSon = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? nombre = _undefined,
    Object? personID = _undefined,
    Object? personStatus = _undefined,
    Object? statusID = _undefined,
    Object? tutorCI = _undefined,
  }) =>
      _then(Input$PersonSortInput._({
        ..._instance._$data,
        if (apellidos != _undefined)
          'apellidos': (apellidos as Enum$SortEnumType?),
        if (cI != _undefined) 'cI': (cI as Enum$SortEnumType?),
        if (isFamily != _undefined)
          'isFamily': (isFamily as Enum$SortEnumType?),
        if (isFather != _undefined)
          'isFather': (isFather as Enum$SortEnumType?),
        if (isMother != _undefined)
          'isMother': (isMother as Enum$SortEnumType?),
        if (isSon != _undefined) 'isSon': (isSon as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (nombre != _undefined) 'nombre': (nombre as Enum$SortEnumType?),
        if (personID != _undefined)
          'personID': (personID as Enum$SortEnumType?),
        if (personStatus != _undefined)
          'personStatus': (personStatus as Input$PersonStatusSortInput?),
        if (statusID != _undefined)
          'statusID': (statusID as Enum$SortEnumType?),
        if (tutorCI != _undefined) 'tutorCI': (tutorCI as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$PersonStatusSortInput<TRes> get personStatus {
    final local$personStatus = _instance.personStatus;
    return local$personStatus == null
        ? CopyWith$Input$PersonStatusSortInput.stub(_then(_instance))
        : CopyWith$Input$PersonStatusSortInput(
            local$personStatus, (e) => call(personStatus: e));
  }
}

class _CopyWithStubImpl$Input$PersonSortInput<TRes>
    implements CopyWith$Input$PersonSortInput<TRes> {
  _CopyWithStubImpl$Input$PersonSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? apellidos,
    Enum$SortEnumType? cI,
    Enum$SortEnumType? isFamily,
    Enum$SortEnumType? isFather,
    Enum$SortEnumType? isMother,
    Enum$SortEnumType? isSon,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? nombre,
    Enum$SortEnumType? personID,
    Input$PersonStatusSortInput? personStatus,
    Enum$SortEnumType? statusID,
    Enum$SortEnumType? tutorCI,
  }) =>
      _res;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
  CopyWith$Input$PersonStatusSortInput<TRes> get personStatus =>
      CopyWith$Input$PersonStatusSortInput.stub(_res);
}

class Input$PersonStatusFilterInput {
  factory Input$PersonStatusFilterInput({
    List<Input$PersonStatusFilterInput>? and,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonStatusFilterInput>? or,
    Input$ListFilterInputTypeOfPersonFilterInput? people,
    Input$ComparableInt64OperationFilterInput? personStatusID,
    Input$StringOperationFilterInput? status,
  }) =>
      Input$PersonStatusFilterInput._({
        if (and != null) r'and': and,
        if (description != null) r'description': description,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (people != null) r'people': people,
        if (personStatusID != null) r'personStatusID': personStatusID,
        if (status != null) r'status': status,
      });

  Input$PersonStatusFilterInput._(this._$data);

  factory Input$PersonStatusFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PersonStatusFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PersonStatusFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('people')) {
      final l$people = data['people'];
      result$data['people'] = l$people == null
          ? null
          : Input$ListFilterInputTypeOfPersonFilterInput.fromJson(
              (l$people as Map<String, dynamic>));
    }
    if (data.containsKey('personStatusID')) {
      final l$personStatusID = data['personStatusID'];
      result$data['personStatusID'] = l$personStatusID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$personStatusID as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$PersonStatusFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PersonStatusFilterInput>? get and =>
      (_$data['and'] as List<Input$PersonStatusFilterInput>?);
  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$PersonStatusFilterInput>? get or =>
      (_$data['or'] as List<Input$PersonStatusFilterInput>?);
  Input$ListFilterInputTypeOfPersonFilterInput? get people =>
      (_$data['people'] as Input$ListFilterInputTypeOfPersonFilterInput?);
  Input$ComparableInt64OperationFilterInput? get personStatusID =>
      (_$data['personStatusID'] as Input$ComparableInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get status =>
      (_$data['status'] as Input$StringOperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('people')) {
      final l$people = people;
      result$data['people'] = l$people?.toJson();
    }
    if (_$data.containsKey('personStatusID')) {
      final l$personStatusID = personStatusID;
      result$data['personStatusID'] = l$personStatusID?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PersonStatusFilterInput<Input$PersonStatusFilterInput>
      get copyWith => CopyWith$Input$PersonStatusFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonStatusFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$people = people;
    final lOther$people = other.people;
    if (_$data.containsKey('people') != other._$data.containsKey('people')) {
      return false;
    }
    if (l$people != lOther$people) {
      return false;
    }
    final l$personStatusID = personStatusID;
    final lOther$personStatusID = other.personStatusID;
    if (_$data.containsKey('personStatusID') !=
        other._$data.containsKey('personStatusID')) {
      return false;
    }
    if (l$personStatusID != lOther$personStatusID) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$description = description;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$people = people;
    final l$personStatusID = personStatusID;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('people') ? l$people : const {},
      _$data.containsKey('personStatusID') ? l$personStatusID : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonStatusFilterInput<TRes> {
  factory CopyWith$Input$PersonStatusFilterInput(
    Input$PersonStatusFilterInput instance,
    TRes Function(Input$PersonStatusFilterInput) then,
  ) = _CopyWithImpl$Input$PersonStatusFilterInput;

  factory CopyWith$Input$PersonStatusFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonStatusFilterInput;

  TRes call({
    List<Input$PersonStatusFilterInput>? and,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonStatusFilterInput>? or,
    Input$ListFilterInputTypeOfPersonFilterInput? people,
    Input$ComparableInt64OperationFilterInput? personStatusID,
    Input$StringOperationFilterInput? status,
  });
  TRes and(
      Iterable<Input$PersonStatusFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonStatusFilterInput<
                      Input$PersonStatusFilterInput>>?)
          _fn);
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$PersonStatusFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonStatusFilterInput<
                      Input$PersonStatusFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get people;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personStatusID;
  CopyWith$Input$StringOperationFilterInput<TRes> get status;
}

class _CopyWithImpl$Input$PersonStatusFilterInput<TRes>
    implements CopyWith$Input$PersonStatusFilterInput<TRes> {
  _CopyWithImpl$Input$PersonStatusFilterInput(
    this._instance,
    this._then,
  );

  final Input$PersonStatusFilterInput _instance;

  final TRes Function(Input$PersonStatusFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? description = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? people = _undefined,
    Object? personStatusID = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$PersonStatusFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$PersonStatusFilterInput>?),
        if (description != _undefined)
          'description': (description as Input$StringOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$PersonStatusFilterInput>?),
        if (people != _undefined)
          'people': (people as Input$ListFilterInputTypeOfPersonFilterInput?),
        if (personStatusID != _undefined)
          'personStatusID':
              (personStatusID as Input$ComparableInt64OperationFilterInput?),
        if (status != _undefined)
          'status': (status as Input$StringOperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$PersonStatusFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonStatusFilterInput<
                          Input$PersonStatusFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$PersonStatusFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$PersonStatusFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonStatusFilterInput<
                          Input$PersonStatusFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$PersonStatusFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get people {
    final local$people = _instance.people;
    return local$people == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonFilterInput(
            local$people, (e) => call(people: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personStatusID {
    final local$personStatusID = _instance.personStatusID;
    return local$personStatusID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$personStatusID, (e) => call(personStatusID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$PersonStatusFilterInput<TRes>
    implements CopyWith$Input$PersonStatusFilterInput<TRes> {
  _CopyWithStubImpl$Input$PersonStatusFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PersonStatusFilterInput>? and,
    Input$StringOperationFilterInput? description,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonStatusFilterInput>? or,
    Input$ListFilterInputTypeOfPersonFilterInput? people,
    Input$ComparableInt64OperationFilterInput? personStatusID,
    Input$StringOperationFilterInput? status,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfPersonFilterInput<TRes> get people =>
      CopyWith$Input$ListFilterInputTypeOfPersonFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personStatusID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get status =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$PersonStatusSortInput {
  factory Input$PersonStatusSortInput({
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? personStatusID,
    Enum$SortEnumType? status,
  }) =>
      Input$PersonStatusSortInput._({
        if (description != null) r'description': description,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (personStatusID != null) r'personStatusID': personStatusID,
        if (status != null) r'status': status,
      });

  Input$PersonStatusSortInput._(this._$data);

  factory Input$PersonStatusSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('personStatusID')) {
      final l$personStatusID = data['personStatusID'];
      result$data['personStatusID'] = l$personStatusID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personStatusID as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    return Input$PersonStatusSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get personStatusID =>
      (_$data['personStatusID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('personStatusID')) {
      final l$personStatusID = personStatusID;
      result$data['personStatusID'] = l$personStatusID == null
          ? null
          : toJson$Enum$SortEnumType(l$personStatusID);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$SortEnumType(l$status);
    }
    return result$data;
  }

  CopyWith$Input$PersonStatusSortInput<Input$PersonStatusSortInput>
      get copyWith => CopyWith$Input$PersonStatusSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonStatusSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$personStatusID = personStatusID;
    final lOther$personStatusID = other.personStatusID;
    if (_$data.containsKey('personStatusID') !=
        other._$data.containsKey('personStatusID')) {
      return false;
    }
    if (l$personStatusID != lOther$personStatusID) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$personStatusID = personStatusID;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('personStatusID') ? l$personStatusID : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonStatusSortInput<TRes> {
  factory CopyWith$Input$PersonStatusSortInput(
    Input$PersonStatusSortInput instance,
    TRes Function(Input$PersonStatusSortInput) then,
  ) = _CopyWithImpl$Input$PersonStatusSortInput;

  factory CopyWith$Input$PersonStatusSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonStatusSortInput;

  TRes call({
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? personStatusID,
    Enum$SortEnumType? status,
  });
}

class _CopyWithImpl$Input$PersonStatusSortInput<TRes>
    implements CopyWith$Input$PersonStatusSortInput<TRes> {
  _CopyWithImpl$Input$PersonStatusSortInput(
    this._instance,
    this._then,
  );

  final Input$PersonStatusSortInput _instance;

  final TRes Function(Input$PersonStatusSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? description = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? personStatusID = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$PersonStatusSortInput._({
        ..._instance._$data,
        if (description != _undefined)
          'description': (description as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (personStatusID != _undefined)
          'personStatusID': (personStatusID as Enum$SortEnumType?),
        if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$PersonStatusSortInput<TRes>
    implements CopyWith$Input$PersonStatusSortInput<TRes> {
  _CopyWithStubImpl$Input$PersonStatusSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? description,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? personStatusID,
    Enum$SortEnumType? status,
  }) =>
      _res;
}

class Input$PersonVariableFilterInput {
  factory Input$PersonVariableFilterInput({
    List<Input$PersonVariableFilterInput>? and,
    Input$BooleanOperationFilterInput? boolValue,
    Input$StringOperationFilterInput? calculatedValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? calculatedValueTime,
    Input$StringOperationFilterInput? calculatedValueType,
    Input$CohabitantFilterInput? cohabitant,
    Input$ComparableNullableOfInt64OperationFilterInput? cohabitantID,
    Input$BooleanOperationFilterInput? dateTimeValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? decimalValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? doubleValue,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$EnumItemFilterInput? enumItem,
    Input$StringOperationFilterInput? enumValue,
    Input$BooleanOperationFilterInput? fileValue,
    Input$BooleanOperationFilterInput? lastValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? longValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonVariableFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$PersonFilterInput? personValue,
    Input$ComparableNullableOfInt64OperationFilterInput? personValueID,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$RelativeLocationFilterInput? relativeLocation,
    Input$ComparableNullableOfInt64OperationFilterInput? relativeLocationID,
    Input$StringOperationFilterInput? stringValue,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      Input$PersonVariableFilterInput._({
        if (and != null) r'and': and,
        if (boolValue != null) r'boolValue': boolValue,
        if (calculatedValue != null) r'calculatedValue': calculatedValue,
        if (calculatedValueTime != null)
          r'calculatedValueTime': calculatedValueTime,
        if (calculatedValueType != null)
          r'calculatedValueType': calculatedValueType,
        if (cohabitant != null) r'cohabitant': cohabitant,
        if (cohabitantID != null) r'cohabitantID': cohabitantID,
        if (dateTimeValue != null) r'dateTimeValue': dateTimeValue,
        if (decimalValue != null) r'decimalValue': decimalValue,
        if (doubleValue != null) r'doubleValue': doubleValue,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (enumItem != null) r'enumItem': enumItem,
        if (enumValue != null) r'enumValue': enumValue,
        if (fileValue != null) r'fileValue': fileValue,
        if (lastValue != null) r'lastValue': lastValue,
        if (longValue != null) r'longValue': longValue,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (person != null) r'person': person,
        if (personID != null) r'personID': personID,
        if (personValue != null) r'personValue': personValue,
        if (personValueID != null) r'personValueID': personValueID,
        if (personVariableID != null) r'personVariableID': personVariableID,
        if (relativeLocation != null) r'relativeLocation': relativeLocation,
        if (relativeLocationID != null)
          r'relativeLocationID': relativeLocationID,
        if (stringValue != null) r'stringValue': stringValue,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
        if (userPersonMarkerPersonVariables != null)
          r'userPersonMarkerPersonVariables': userPersonMarkerPersonVariables,
        if (variableType != null) r'variableType': variableType,
        if (variableTypeID != null) r'variableTypeID': variableTypeID,
      });

  Input$PersonVariableFilterInput._(this._$data);

  factory Input$PersonVariableFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$PersonVariableFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('boolValue')) {
      final l$boolValue = data['boolValue'];
      result$data['boolValue'] = l$boolValue == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$boolValue as Map<String, dynamic>));
    }
    if (data.containsKey('calculatedValue')) {
      final l$calculatedValue = data['calculatedValue'];
      result$data['calculatedValue'] = l$calculatedValue == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$calculatedValue as Map<String, dynamic>));
    }
    if (data.containsKey('calculatedValueTime')) {
      final l$calculatedValueTime = data['calculatedValueTime'];
      result$data['calculatedValueTime'] = l$calculatedValueTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$calculatedValueTime as Map<String, dynamic>));
    }
    if (data.containsKey('calculatedValueType')) {
      final l$calculatedValueType = data['calculatedValueType'];
      result$data['calculatedValueType'] = l$calculatedValueType == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$calculatedValueType as Map<String, dynamic>));
    }
    if (data.containsKey('cohabitant')) {
      final l$cohabitant = data['cohabitant'];
      result$data['cohabitant'] = l$cohabitant == null
          ? null
          : Input$CohabitantFilterInput.fromJson(
              (l$cohabitant as Map<String, dynamic>));
    }
    if (data.containsKey('cohabitantID')) {
      final l$cohabitantID = data['cohabitantID'];
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$cohabitantID as Map<String, dynamic>));
    }
    if (data.containsKey('dateTimeValue')) {
      final l$dateTimeValue = data['dateTimeValue'];
      result$data['dateTimeValue'] = l$dateTimeValue == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$dateTimeValue as Map<String, dynamic>));
    }
    if (data.containsKey('decimalValue')) {
      final l$decimalValue = data['decimalValue'];
      result$data['decimalValue'] = l$decimalValue == null
          ? null
          : Input$ComparableNullableOfDecimalOperationFilterInput.fromJson(
              (l$decimalValue as Map<String, dynamic>));
    }
    if (data.containsKey('doubleValue')) {
      final l$doubleValue = data['doubleValue'];
      result$data['doubleValue'] = l$doubleValue == null
          ? null
          : Input$ComparableNullableOfDecimalOperationFilterInput.fromJson(
              (l$doubleValue as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$enumGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('enumItem')) {
      final l$enumItem = data['enumItem'];
      result$data['enumItem'] = l$enumItem == null
          ? null
          : Input$EnumItemFilterInput.fromJson(
              (l$enumItem as Map<String, dynamic>));
    }
    if (data.containsKey('enumValue')) {
      final l$enumValue = data['enumValue'];
      result$data['enumValue'] = l$enumValue == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$enumValue as Map<String, dynamic>));
    }
    if (data.containsKey('fileValue')) {
      final l$fileValue = data['fileValue'];
      result$data['fileValue'] = l$fileValue == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$fileValue as Map<String, dynamic>));
    }
    if (data.containsKey('lastValue')) {
      final l$lastValue = data['lastValue'];
      result$data['lastValue'] = l$lastValue == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$lastValue as Map<String, dynamic>));
    }
    if (data.containsKey('longValue')) {
      final l$longValue = data['longValue'];
      result$data['longValue'] = l$longValue == null
          ? null
          : Input$ComparableNullableOfDecimalOperationFilterInput.fromJson(
              (l$longValue as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$PersonVariableFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('person')) {
      final l$person = data['person'];
      result$data['person'] = l$person == null
          ? null
          : Input$PersonFilterInput.fromJson(
              (l$person as Map<String, dynamic>));
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$personID as Map<String, dynamic>));
    }
    if (data.containsKey('personValue')) {
      final l$personValue = data['personValue'];
      result$data['personValue'] = l$personValue == null
          ? null
          : Input$PersonFilterInput.fromJson(
              (l$personValue as Map<String, dynamic>));
    }
    if (data.containsKey('personValueID')) {
      final l$personValueID = data['personValueID'];
      result$data['personValueID'] = l$personValueID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$personValueID as Map<String, dynamic>));
    }
    if (data.containsKey('personVariableID')) {
      final l$personVariableID = data['personVariableID'];
      result$data['personVariableID'] = l$personVariableID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$personVariableID as Map<String, dynamic>));
    }
    if (data.containsKey('relativeLocation')) {
      final l$relativeLocation = data['relativeLocation'];
      result$data['relativeLocation'] = l$relativeLocation == null
          ? null
          : Input$RelativeLocationFilterInput.fromJson(
              (l$relativeLocation as Map<String, dynamic>));
    }
    if (data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = data['relativeLocationID'];
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$relativeLocationID as Map<String, dynamic>));
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = l$stringValue == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stringValue as Map<String, dynamic>));
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkerPersonVariables')) {
      final l$userPersonMarkerPersonVariables =
          data['userPersonMarkerPersonVariables'];
      result$data[
          'userPersonMarkerPersonVariables'] = l$userPersonMarkerPersonVariables ==
              null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
              .fromJson(
                  (l$userPersonMarkerPersonVariables as Map<String, dynamic>));
    }
    if (data.containsKey('variableType')) {
      final l$variableType = data['variableType'];
      result$data['variableType'] = l$variableType == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$variableType as Map<String, dynamic>));
    }
    if (data.containsKey('variableTypeID')) {
      final l$variableTypeID = data['variableTypeID'];
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$variableTypeID as Map<String, dynamic>));
    }
    return Input$PersonVariableFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PersonVariableFilterInput>? get and =>
      (_$data['and'] as List<Input$PersonVariableFilterInput>?);
  Input$BooleanOperationFilterInput? get boolValue =>
      (_$data['boolValue'] as Input$BooleanOperationFilterInput?);
  Input$StringOperationFilterInput? get calculatedValue =>
      (_$data['calculatedValue'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get calculatedValueTime => (_$data['calculatedValueTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get calculatedValueType =>
      (_$data['calculatedValueType'] as Input$StringOperationFilterInput?);
  Input$CohabitantFilterInput? get cohabitant =>
      (_$data['cohabitant'] as Input$CohabitantFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get cohabitantID =>
      (_$data['cohabitantID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$BooleanOperationFilterInput? get dateTimeValue =>
      (_$data['dateTimeValue'] as Input$BooleanOperationFilterInput?);
  Input$ComparableNullableOfDecimalOperationFilterInput? get decimalValue =>
      (_$data['decimalValue']
          as Input$ComparableNullableOfDecimalOperationFilterInput?);
  Input$ComparableNullableOfDecimalOperationFilterInput? get doubleValue =>
      (_$data['doubleValue']
          as Input$ComparableNullableOfDecimalOperationFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get enumGroupID =>
      (_$data['enumGroupID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$EnumItemFilterInput? get enumItem =>
      (_$data['enumItem'] as Input$EnumItemFilterInput?);
  Input$StringOperationFilterInput? get enumValue =>
      (_$data['enumValue'] as Input$StringOperationFilterInput?);
  Input$BooleanOperationFilterInput? get fileValue =>
      (_$data['fileValue'] as Input$BooleanOperationFilterInput?);
  Input$BooleanOperationFilterInput? get lastValue =>
      (_$data['lastValue'] as Input$BooleanOperationFilterInput?);
  Input$ComparableNullableOfDecimalOperationFilterInput? get longValue =>
      (_$data['longValue']
          as Input$ComparableNullableOfDecimalOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$PersonVariableFilterInput>? get or =>
      (_$data['or'] as List<Input$PersonVariableFilterInput>?);
  Input$PersonFilterInput? get person =>
      (_$data['person'] as Input$PersonFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get personID =>
      (_$data['personID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$PersonFilterInput? get personValue =>
      (_$data['personValue'] as Input$PersonFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get personValueID =>
      (_$data['personValueID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get personVariableID =>
      (_$data['personVariableID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$RelativeLocationFilterInput? get relativeLocation =>
      (_$data['relativeLocation'] as Input$RelativeLocationFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get relativeLocationID =>
      (_$data['relativeLocationID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get stringValue =>
      (_$data['stringValue'] as Input$StringOperationFilterInput?);
  Input$TerritoryFilterInput? get territory =>
      (_$data['territory'] as Input$TerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
      get userPersonMarkerPersonVariables => (_$data[
              'userPersonMarkerPersonVariables']
          as Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?);
  Input$VariableTypeFilterInput? get variableType =>
      (_$data['variableType'] as Input$VariableTypeFilterInput?);
  Input$ComparableInt64OperationFilterInput? get variableTypeID =>
      (_$data['variableTypeID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('boolValue')) {
      final l$boolValue = boolValue;
      result$data['boolValue'] = l$boolValue?.toJson();
    }
    if (_$data.containsKey('calculatedValue')) {
      final l$calculatedValue = calculatedValue;
      result$data['calculatedValue'] = l$calculatedValue?.toJson();
    }
    if (_$data.containsKey('calculatedValueTime')) {
      final l$calculatedValueTime = calculatedValueTime;
      result$data['calculatedValueTime'] = l$calculatedValueTime?.toJson();
    }
    if (_$data.containsKey('calculatedValueType')) {
      final l$calculatedValueType = calculatedValueType;
      result$data['calculatedValueType'] = l$calculatedValueType?.toJson();
    }
    if (_$data.containsKey('cohabitant')) {
      final l$cohabitant = cohabitant;
      result$data['cohabitant'] = l$cohabitant?.toJson();
    }
    if (_$data.containsKey('cohabitantID')) {
      final l$cohabitantID = cohabitantID;
      result$data['cohabitantID'] = l$cohabitantID?.toJson();
    }
    if (_$data.containsKey('dateTimeValue')) {
      final l$dateTimeValue = dateTimeValue;
      result$data['dateTimeValue'] = l$dateTimeValue?.toJson();
    }
    if (_$data.containsKey('decimalValue')) {
      final l$decimalValue = decimalValue;
      result$data['decimalValue'] = l$decimalValue?.toJson();
    }
    if (_$data.containsKey('doubleValue')) {
      final l$doubleValue = doubleValue;
      result$data['doubleValue'] = l$doubleValue?.toJson();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID?.toJson();
    }
    if (_$data.containsKey('enumItem')) {
      final l$enumItem = enumItem;
      result$data['enumItem'] = l$enumItem?.toJson();
    }
    if (_$data.containsKey('enumValue')) {
      final l$enumValue = enumValue;
      result$data['enumValue'] = l$enumValue?.toJson();
    }
    if (_$data.containsKey('fileValue')) {
      final l$fileValue = fileValue;
      result$data['fileValue'] = l$fileValue?.toJson();
    }
    if (_$data.containsKey('lastValue')) {
      final l$lastValue = lastValue;
      result$data['lastValue'] = l$lastValue?.toJson();
    }
    if (_$data.containsKey('longValue')) {
      final l$longValue = longValue;
      result$data['longValue'] = l$longValue?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('person')) {
      final l$person = person;
      result$data['person'] = l$person?.toJson();
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] = l$personID?.toJson();
    }
    if (_$data.containsKey('personValue')) {
      final l$personValue = personValue;
      result$data['personValue'] = l$personValue?.toJson();
    }
    if (_$data.containsKey('personValueID')) {
      final l$personValueID = personValueID;
      result$data['personValueID'] = l$personValueID?.toJson();
    }
    if (_$data.containsKey('personVariableID')) {
      final l$personVariableID = personVariableID;
      result$data['personVariableID'] = l$personVariableID?.toJson();
    }
    if (_$data.containsKey('relativeLocation')) {
      final l$relativeLocation = relativeLocation;
      result$data['relativeLocation'] = l$relativeLocation?.toJson();
    }
    if (_$data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = relativeLocationID;
      result$data['relativeLocationID'] = l$relativeLocationID?.toJson();
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue?.toJson();
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    if (_$data.containsKey('userPersonMarkerPersonVariables')) {
      final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
      result$data['userPersonMarkerPersonVariables'] =
          l$userPersonMarkerPersonVariables?.toJson();
    }
    if (_$data.containsKey('variableType')) {
      final l$variableType = variableType;
      result$data['variableType'] = l$variableType?.toJson();
    }
    if (_$data.containsKey('variableTypeID')) {
      final l$variableTypeID = variableTypeID;
      result$data['variableTypeID'] = l$variableTypeID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PersonVariableFilterInput<Input$PersonVariableFilterInput>
      get copyWith => CopyWith$Input$PersonVariableFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonVariableFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$boolValue = boolValue;
    final lOther$boolValue = other.boolValue;
    if (_$data.containsKey('boolValue') !=
        other._$data.containsKey('boolValue')) {
      return false;
    }
    if (l$boolValue != lOther$boolValue) {
      return false;
    }
    final l$calculatedValue = calculatedValue;
    final lOther$calculatedValue = other.calculatedValue;
    if (_$data.containsKey('calculatedValue') !=
        other._$data.containsKey('calculatedValue')) {
      return false;
    }
    if (l$calculatedValue != lOther$calculatedValue) {
      return false;
    }
    final l$calculatedValueTime = calculatedValueTime;
    final lOther$calculatedValueTime = other.calculatedValueTime;
    if (_$data.containsKey('calculatedValueTime') !=
        other._$data.containsKey('calculatedValueTime')) {
      return false;
    }
    if (l$calculatedValueTime != lOther$calculatedValueTime) {
      return false;
    }
    final l$calculatedValueType = calculatedValueType;
    final lOther$calculatedValueType = other.calculatedValueType;
    if (_$data.containsKey('calculatedValueType') !=
        other._$data.containsKey('calculatedValueType')) {
      return false;
    }
    if (l$calculatedValueType != lOther$calculatedValueType) {
      return false;
    }
    final l$cohabitant = cohabitant;
    final lOther$cohabitant = other.cohabitant;
    if (_$data.containsKey('cohabitant') !=
        other._$data.containsKey('cohabitant')) {
      return false;
    }
    if (l$cohabitant != lOther$cohabitant) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (_$data.containsKey('cohabitantID') !=
        other._$data.containsKey('cohabitantID')) {
      return false;
    }
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$dateTimeValue = dateTimeValue;
    final lOther$dateTimeValue = other.dateTimeValue;
    if (_$data.containsKey('dateTimeValue') !=
        other._$data.containsKey('dateTimeValue')) {
      return false;
    }
    if (l$dateTimeValue != lOther$dateTimeValue) {
      return false;
    }
    final l$decimalValue = decimalValue;
    final lOther$decimalValue = other.decimalValue;
    if (_$data.containsKey('decimalValue') !=
        other._$data.containsKey('decimalValue')) {
      return false;
    }
    if (l$decimalValue != lOther$decimalValue) {
      return false;
    }
    final l$doubleValue = doubleValue;
    final lOther$doubleValue = other.doubleValue;
    if (_$data.containsKey('doubleValue') !=
        other._$data.containsKey('doubleValue')) {
      return false;
    }
    if (l$doubleValue != lOther$doubleValue) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$enumItem = enumItem;
    final lOther$enumItem = other.enumItem;
    if (_$data.containsKey('enumItem') !=
        other._$data.containsKey('enumItem')) {
      return false;
    }
    if (l$enumItem != lOther$enumItem) {
      return false;
    }
    final l$enumValue = enumValue;
    final lOther$enumValue = other.enumValue;
    if (_$data.containsKey('enumValue') !=
        other._$data.containsKey('enumValue')) {
      return false;
    }
    if (l$enumValue != lOther$enumValue) {
      return false;
    }
    final l$fileValue = fileValue;
    final lOther$fileValue = other.fileValue;
    if (_$data.containsKey('fileValue') !=
        other._$data.containsKey('fileValue')) {
      return false;
    }
    if (l$fileValue != lOther$fileValue) {
      return false;
    }
    final l$lastValue = lastValue;
    final lOther$lastValue = other.lastValue;
    if (_$data.containsKey('lastValue') !=
        other._$data.containsKey('lastValue')) {
      return false;
    }
    if (l$lastValue != lOther$lastValue) {
      return false;
    }
    final l$longValue = longValue;
    final lOther$longValue = other.longValue;
    if (_$data.containsKey('longValue') !=
        other._$data.containsKey('longValue')) {
      return false;
    }
    if (l$longValue != lOther$longValue) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$person = person;
    final lOther$person = other.person;
    if (_$data.containsKey('person') != other._$data.containsKey('person')) {
      return false;
    }
    if (l$person != lOther$person) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$personValue = personValue;
    final lOther$personValue = other.personValue;
    if (_$data.containsKey('personValue') !=
        other._$data.containsKey('personValue')) {
      return false;
    }
    if (l$personValue != lOther$personValue) {
      return false;
    }
    final l$personValueID = personValueID;
    final lOther$personValueID = other.personValueID;
    if (_$data.containsKey('personValueID') !=
        other._$data.containsKey('personValueID')) {
      return false;
    }
    if (l$personValueID != lOther$personValueID) {
      return false;
    }
    final l$personVariableID = personVariableID;
    final lOther$personVariableID = other.personVariableID;
    if (_$data.containsKey('personVariableID') !=
        other._$data.containsKey('personVariableID')) {
      return false;
    }
    if (l$personVariableID != lOther$personVariableID) {
      return false;
    }
    final l$relativeLocation = relativeLocation;
    final lOther$relativeLocation = other.relativeLocation;
    if (_$data.containsKey('relativeLocation') !=
        other._$data.containsKey('relativeLocation')) {
      return false;
    }
    if (l$relativeLocation != lOther$relativeLocation) {
      return false;
    }
    final l$relativeLocationID = relativeLocationID;
    final lOther$relativeLocationID = other.relativeLocationID;
    if (_$data.containsKey('relativeLocationID') !=
        other._$data.containsKey('relativeLocationID')) {
      return false;
    }
    if (l$relativeLocationID != lOther$relativeLocationID) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
    final lOther$userPersonMarkerPersonVariables =
        other.userPersonMarkerPersonVariables;
    if (_$data.containsKey('userPersonMarkerPersonVariables') !=
        other._$data.containsKey('userPersonMarkerPersonVariables')) {
      return false;
    }
    if (l$userPersonMarkerPersonVariables !=
        lOther$userPersonMarkerPersonVariables) {
      return false;
    }
    final l$variableType = variableType;
    final lOther$variableType = other.variableType;
    if (_$data.containsKey('variableType') !=
        other._$data.containsKey('variableType')) {
      return false;
    }
    if (l$variableType != lOther$variableType) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (_$data.containsKey('variableTypeID') !=
        other._$data.containsKey('variableTypeID')) {
      return false;
    }
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$boolValue = boolValue;
    final l$calculatedValue = calculatedValue;
    final l$calculatedValueTime = calculatedValueTime;
    final l$calculatedValueType = calculatedValueType;
    final l$cohabitant = cohabitant;
    final l$cohabitantID = cohabitantID;
    final l$dateTimeValue = dateTimeValue;
    final l$decimalValue = decimalValue;
    final l$doubleValue = doubleValue;
    final l$enumGroupID = enumGroupID;
    final l$enumItem = enumItem;
    final l$enumValue = enumValue;
    final l$fileValue = fileValue;
    final l$lastValue = lastValue;
    final l$longValue = longValue;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$person = person;
    final l$personID = personID;
    final l$personValue = personValue;
    final l$personValueID = personValueID;
    final l$personVariableID = personVariableID;
    final l$relativeLocation = relativeLocation;
    final l$relativeLocationID = relativeLocationID;
    final l$stringValue = stringValue;
    final l$territory = territory;
    final l$territoryID = territoryID;
    final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
    final l$variableType = variableType;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('boolValue') ? l$boolValue : const {},
      _$data.containsKey('calculatedValue') ? l$calculatedValue : const {},
      _$data.containsKey('calculatedValueTime')
          ? l$calculatedValueTime
          : const {},
      _$data.containsKey('calculatedValueType')
          ? l$calculatedValueType
          : const {},
      _$data.containsKey('cohabitant') ? l$cohabitant : const {},
      _$data.containsKey('cohabitantID') ? l$cohabitantID : const {},
      _$data.containsKey('dateTimeValue') ? l$dateTimeValue : const {},
      _$data.containsKey('decimalValue') ? l$decimalValue : const {},
      _$data.containsKey('doubleValue') ? l$doubleValue : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('enumItem') ? l$enumItem : const {},
      _$data.containsKey('enumValue') ? l$enumValue : const {},
      _$data.containsKey('fileValue') ? l$fileValue : const {},
      _$data.containsKey('lastValue') ? l$lastValue : const {},
      _$data.containsKey('longValue') ? l$longValue : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('person') ? l$person : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('personValue') ? l$personValue : const {},
      _$data.containsKey('personValueID') ? l$personValueID : const {},
      _$data.containsKey('personVariableID') ? l$personVariableID : const {},
      _$data.containsKey('relativeLocation') ? l$relativeLocation : const {},
      _$data.containsKey('relativeLocationID')
          ? l$relativeLocationID
          : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
      _$data.containsKey('userPersonMarkerPersonVariables')
          ? l$userPersonMarkerPersonVariables
          : const {},
      _$data.containsKey('variableType') ? l$variableType : const {},
      _$data.containsKey('variableTypeID') ? l$variableTypeID : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonVariableFilterInput<TRes> {
  factory CopyWith$Input$PersonVariableFilterInput(
    Input$PersonVariableFilterInput instance,
    TRes Function(Input$PersonVariableFilterInput) then,
  ) = _CopyWithImpl$Input$PersonVariableFilterInput;

  factory CopyWith$Input$PersonVariableFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonVariableFilterInput;

  TRes call({
    List<Input$PersonVariableFilterInput>? and,
    Input$BooleanOperationFilterInput? boolValue,
    Input$StringOperationFilterInput? calculatedValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? calculatedValueTime,
    Input$StringOperationFilterInput? calculatedValueType,
    Input$CohabitantFilterInput? cohabitant,
    Input$ComparableNullableOfInt64OperationFilterInput? cohabitantID,
    Input$BooleanOperationFilterInput? dateTimeValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? decimalValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? doubleValue,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$EnumItemFilterInput? enumItem,
    Input$StringOperationFilterInput? enumValue,
    Input$BooleanOperationFilterInput? fileValue,
    Input$BooleanOperationFilterInput? lastValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? longValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonVariableFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$PersonFilterInput? personValue,
    Input$ComparableNullableOfInt64OperationFilterInput? personValueID,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$RelativeLocationFilterInput? relativeLocation,
    Input$ComparableNullableOfInt64OperationFilterInput? relativeLocationID,
    Input$StringOperationFilterInput? stringValue,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  });
  TRes and(
      Iterable<Input$PersonVariableFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonVariableFilterInput<
                      Input$PersonVariableFilterInput>>?)
          _fn);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get boolValue;
  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValue;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get calculatedValueTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValueType;
  CopyWith$Input$CohabitantFilterInput<TRes> get cohabitant;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get cohabitantID;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get dateTimeValue;
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get decimalValue;
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get doubleValue;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID;
  CopyWith$Input$EnumItemFilterInput<TRes> get enumItem;
  CopyWith$Input$StringOperationFilterInput<TRes> get enumValue;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get fileValue;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get lastValue;
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get longValue;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$PersonVariableFilterInput>? Function(
              Iterable<
                  CopyWith$Input$PersonVariableFilterInput<
                      Input$PersonVariableFilterInput>>?)
          _fn);
  CopyWith$Input$PersonFilterInput<TRes> get person;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID;
  CopyWith$Input$PersonFilterInput<TRes> get personValue;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personValueID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personVariableID;
  CopyWith$Input$RelativeLocationFilterInput<TRes> get relativeLocation;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get relativeLocationID;
  CopyWith$Input$StringOperationFilterInput<TRes> get stringValue;
  CopyWith$Input$TerritoryFilterInput<TRes> get territory;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
      TRes> get userPersonMarkerPersonVariables;
  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID;
}

class _CopyWithImpl$Input$PersonVariableFilterInput<TRes>
    implements CopyWith$Input$PersonVariableFilterInput<TRes> {
  _CopyWithImpl$Input$PersonVariableFilterInput(
    this._instance,
    this._then,
  );

  final Input$PersonVariableFilterInput _instance;

  final TRes Function(Input$PersonVariableFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? boolValue = _undefined,
    Object? calculatedValue = _undefined,
    Object? calculatedValueTime = _undefined,
    Object? calculatedValueType = _undefined,
    Object? cohabitant = _undefined,
    Object? cohabitantID = _undefined,
    Object? dateTimeValue = _undefined,
    Object? decimalValue = _undefined,
    Object? doubleValue = _undefined,
    Object? enumGroupID = _undefined,
    Object? enumItem = _undefined,
    Object? enumValue = _undefined,
    Object? fileValue = _undefined,
    Object? lastValue = _undefined,
    Object? longValue = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? person = _undefined,
    Object? personID = _undefined,
    Object? personValue = _undefined,
    Object? personValueID = _undefined,
    Object? personVariableID = _undefined,
    Object? relativeLocation = _undefined,
    Object? relativeLocationID = _undefined,
    Object? stringValue = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
    Object? userPersonMarkerPersonVariables = _undefined,
    Object? variableType = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$PersonVariableFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$PersonVariableFilterInput>?),
        if (boolValue != _undefined)
          'boolValue': (boolValue as Input$BooleanOperationFilterInput?),
        if (calculatedValue != _undefined)
          'calculatedValue':
              (calculatedValue as Input$StringOperationFilterInput?),
        if (calculatedValueTime != _undefined)
          'calculatedValueTime': (calculatedValueTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (calculatedValueType != _undefined)
          'calculatedValueType':
              (calculatedValueType as Input$StringOperationFilterInput?),
        if (cohabitant != _undefined)
          'cohabitant': (cohabitant as Input$CohabitantFilterInput?),
        if (cohabitantID != _undefined)
          'cohabitantID': (cohabitantID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (dateTimeValue != _undefined)
          'dateTimeValue':
              (dateTimeValue as Input$BooleanOperationFilterInput?),
        if (decimalValue != _undefined)
          'decimalValue': (decimalValue
              as Input$ComparableNullableOfDecimalOperationFilterInput?),
        if (doubleValue != _undefined)
          'doubleValue': (doubleValue
              as Input$ComparableNullableOfDecimalOperationFilterInput?),
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (enumItem != _undefined)
          'enumItem': (enumItem as Input$EnumItemFilterInput?),
        if (enumValue != _undefined)
          'enumValue': (enumValue as Input$StringOperationFilterInput?),
        if (fileValue != _undefined)
          'fileValue': (fileValue as Input$BooleanOperationFilterInput?),
        if (lastValue != _undefined)
          'lastValue': (lastValue as Input$BooleanOperationFilterInput?),
        if (longValue != _undefined)
          'longValue': (longValue
              as Input$ComparableNullableOfDecimalOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$PersonVariableFilterInput>?),
        if (person != _undefined)
          'person': (person as Input$PersonFilterInput?),
        if (personID != _undefined)
          'personID': (personID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (personValue != _undefined)
          'personValue': (personValue as Input$PersonFilterInput?),
        if (personValueID != _undefined)
          'personValueID': (personValueID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (personVariableID != _undefined)
          'personVariableID':
              (personVariableID as Input$ComparableInt64OperationFilterInput?),
        if (relativeLocation != _undefined)
          'relativeLocation':
              (relativeLocation as Input$RelativeLocationFilterInput?),
        if (relativeLocationID != _undefined)
          'relativeLocationID': (relativeLocationID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (stringValue != _undefined)
          'stringValue': (stringValue as Input$StringOperationFilterInput?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritoryFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
        if (userPersonMarkerPersonVariables != _undefined)
          'userPersonMarkerPersonVariables': (userPersonMarkerPersonVariables
              as Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?),
        if (variableType != _undefined)
          'variableType': (variableType as Input$VariableTypeFilterInput?),
        if (variableTypeID != _undefined)
          'variableTypeID':
              (variableTypeID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$PersonVariableFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonVariableFilterInput<
                          Input$PersonVariableFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$PersonVariableFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$BooleanOperationFilterInput<TRes> get boolValue {
    final local$boolValue = _instance.boolValue;
    return local$boolValue == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$boolValue, (e) => call(boolValue: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValue {
    final local$calculatedValue = _instance.calculatedValue;
    return local$calculatedValue == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$calculatedValue, (e) => call(calculatedValue: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get calculatedValueTime {
    final local$calculatedValueTime = _instance.calculatedValueTime;
    return local$calculatedValueTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$calculatedValueTime, (e) => call(calculatedValueTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValueType {
    final local$calculatedValueType = _instance.calculatedValueType;
    return local$calculatedValueType == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$calculatedValueType, (e) => call(calculatedValueType: e));
  }

  CopyWith$Input$CohabitantFilterInput<TRes> get cohabitant {
    final local$cohabitant = _instance.cohabitant;
    return local$cohabitant == null
        ? CopyWith$Input$CohabitantFilterInput.stub(_then(_instance))
        : CopyWith$Input$CohabitantFilterInput(
            local$cohabitant, (e) => call(cohabitant: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get cohabitantID {
    final local$cohabitantID = _instance.cohabitantID;
    return local$cohabitantID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$cohabitantID, (e) => call(cohabitantID: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get dateTimeValue {
    final local$dateTimeValue = _instance.dateTimeValue;
    return local$dateTimeValue == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$dateTimeValue, (e) => call(dateTimeValue: e));
  }

  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get decimalValue {
    final local$decimalValue = _instance.decimalValue;
    return local$decimalValue == null
        ? CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput(
            local$decimalValue, (e) => call(decimalValue: e));
  }

  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get doubleValue {
    final local$doubleValue = _instance.doubleValue;
    return local$doubleValue == null
        ? CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput(
            local$doubleValue, (e) => call(doubleValue: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID {
    final local$enumGroupID = _instance.enumGroupID;
    return local$enumGroupID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$enumGroupID, (e) => call(enumGroupID: e));
  }

  CopyWith$Input$EnumItemFilterInput<TRes> get enumItem {
    final local$enumItem = _instance.enumItem;
    return local$enumItem == null
        ? CopyWith$Input$EnumItemFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumItemFilterInput(
            local$enumItem, (e) => call(enumItem: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get enumValue {
    final local$enumValue = _instance.enumValue;
    return local$enumValue == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$enumValue, (e) => call(enumValue: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get fileValue {
    final local$fileValue = _instance.fileValue;
    return local$fileValue == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$fileValue, (e) => call(fileValue: e));
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get lastValue {
    final local$lastValue = _instance.lastValue;
    return local$lastValue == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$lastValue, (e) => call(lastValue: e));
  }

  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get longValue {
    final local$longValue = _instance.longValue;
    return local$longValue == null
        ? CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput(
            local$longValue, (e) => call(longValue: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$PersonVariableFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$PersonVariableFilterInput<
                          Input$PersonVariableFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$PersonVariableFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$PersonFilterInput<TRes> get person {
    final local$person = _instance.person;
    return local$person == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(
            local$person, (e) => call(person: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID {
    final local$personID = _instance.personID;
    return local$personID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$personID, (e) => call(personID: e));
  }

  CopyWith$Input$PersonFilterInput<TRes> get personValue {
    final local$personValue = _instance.personValue;
    return local$personValue == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(
            local$personValue, (e) => call(personValue: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personValueID {
    final local$personValueID = _instance.personValueID;
    return local$personValueID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$personValueID, (e) => call(personValueID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get personVariableID {
    final local$personVariableID = _instance.personVariableID;
    return local$personVariableID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$personVariableID, (e) => call(personVariableID: e));
  }

  CopyWith$Input$RelativeLocationFilterInput<TRes> get relativeLocation {
    final local$relativeLocation = _instance.relativeLocation;
    return local$relativeLocation == null
        ? CopyWith$Input$RelativeLocationFilterInput.stub(_then(_instance))
        : CopyWith$Input$RelativeLocationFilterInput(
            local$relativeLocation, (e) => call(relativeLocation: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get relativeLocationID {
    final local$relativeLocationID = _instance.relativeLocationID;
    return local$relativeLocationID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$relativeLocationID, (e) => call(relativeLocationID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stringValue {
    final local$stringValue = _instance.stringValue;
    return local$stringValue == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stringValue, (e) => call(stringValue: e));
  }

  CopyWith$Input$TerritoryFilterInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
      TRes> get userPersonMarkerPersonVariables {
    final local$userPersonMarkerPersonVariables =
        _instance.userPersonMarkerPersonVariables;
    return local$userPersonMarkerPersonVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
            local$userPersonMarkerPersonVariables,
            (e) => call(userPersonMarkerPersonVariables: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType {
    final local$variableType = _instance.variableType;
    return local$variableType == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$variableType, (e) => call(variableType: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID {
    final local$variableTypeID = _instance.variableTypeID;
    return local$variableTypeID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$variableTypeID, (e) => call(variableTypeID: e));
  }
}

class _CopyWithStubImpl$Input$PersonVariableFilterInput<TRes>
    implements CopyWith$Input$PersonVariableFilterInput<TRes> {
  _CopyWithStubImpl$Input$PersonVariableFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PersonVariableFilterInput>? and,
    Input$BooleanOperationFilterInput? boolValue,
    Input$StringOperationFilterInput? calculatedValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? calculatedValueTime,
    Input$StringOperationFilterInput? calculatedValueType,
    Input$CohabitantFilterInput? cohabitant,
    Input$ComparableNullableOfInt64OperationFilterInput? cohabitantID,
    Input$BooleanOperationFilterInput? dateTimeValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? decimalValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? doubleValue,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$EnumItemFilterInput? enumItem,
    Input$StringOperationFilterInput? enumValue,
    Input$BooleanOperationFilterInput? fileValue,
    Input$BooleanOperationFilterInput? lastValue,
    Input$ComparableNullableOfDecimalOperationFilterInput? longValue,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$PersonVariableFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$PersonFilterInput? personValue,
    Input$ComparableNullableOfInt64OperationFilterInput? personValueID,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$RelativeLocationFilterInput? relativeLocation,
    Input$ComparableNullableOfInt64OperationFilterInput? relativeLocationID,
    Input$StringOperationFilterInput? stringValue,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get boolValue =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValue =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get calculatedValueTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get calculatedValueType =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$CohabitantFilterInput<TRes> get cohabitant =>
      CopyWith$Input$CohabitantFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get cohabitantID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get dateTimeValue =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get decimalValue =>
          CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
              _res);
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get doubleValue =>
          CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
              _res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$EnumItemFilterInput<TRes> get enumItem =>
      CopyWith$Input$EnumItemFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get enumValue =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get fileValue =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$BooleanOperationFilterInput<TRes> get lastValue =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput<TRes>
      get longValue =>
          CopyWith$Input$ComparableNullableOfDecimalOperationFilterInput.stub(
              _res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$PersonFilterInput<TRes> get person =>
      CopyWith$Input$PersonFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$PersonFilterInput<TRes> get personValue =>
      CopyWith$Input$PersonFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personValueID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get personVariableID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$RelativeLocationFilterInput<TRes> get relativeLocation =>
      CopyWith$Input$RelativeLocationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get relativeLocationID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get stringValue =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$TerritoryFilterInput<TRes> get territory =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
          TRes>
      get userPersonMarkerPersonVariables =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
              .stub(_res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$PersonVariableSortInput {
  factory Input$PersonVariableSortInput({
    Enum$SortEnumType? boolValue,
    Enum$SortEnumType? calculatedValue,
    Enum$SortEnumType? calculatedValueTime,
    Enum$SortEnumType? calculatedValueType,
    Input$CohabitantSortInput? cohabitant,
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? dateTimeValue,
    Enum$SortEnumType? decimalValue,
    Enum$SortEnumType? doubleValue,
    Enum$SortEnumType? enumGroupID,
    Input$EnumItemSortInput? enumItem,
    Enum$SortEnumType? enumValue,
    Enum$SortEnumType? fileValue,
    Enum$SortEnumType? lastValue,
    Enum$SortEnumType? longValue,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Input$PersonSortInput? personValue,
    Enum$SortEnumType? personValueID,
    Enum$SortEnumType? personVariableID,
    Input$RelativeLocationSortInput? relativeLocation,
    Enum$SortEnumType? relativeLocationID,
    Enum$SortEnumType? stringValue,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
    Input$VariableTypeSortInput? variableType,
    Enum$SortEnumType? variableTypeID,
  }) =>
      Input$PersonVariableSortInput._({
        if (boolValue != null) r'boolValue': boolValue,
        if (calculatedValue != null) r'calculatedValue': calculatedValue,
        if (calculatedValueTime != null)
          r'calculatedValueTime': calculatedValueTime,
        if (calculatedValueType != null)
          r'calculatedValueType': calculatedValueType,
        if (cohabitant != null) r'cohabitant': cohabitant,
        if (cohabitantID != null) r'cohabitantID': cohabitantID,
        if (dateTimeValue != null) r'dateTimeValue': dateTimeValue,
        if (decimalValue != null) r'decimalValue': decimalValue,
        if (doubleValue != null) r'doubleValue': doubleValue,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (enumItem != null) r'enumItem': enumItem,
        if (enumValue != null) r'enumValue': enumValue,
        if (fileValue != null) r'fileValue': fileValue,
        if (lastValue != null) r'lastValue': lastValue,
        if (longValue != null) r'longValue': longValue,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (person != null) r'person': person,
        if (personID != null) r'personID': personID,
        if (personValue != null) r'personValue': personValue,
        if (personValueID != null) r'personValueID': personValueID,
        if (personVariableID != null) r'personVariableID': personVariableID,
        if (relativeLocation != null) r'relativeLocation': relativeLocation,
        if (relativeLocationID != null)
          r'relativeLocationID': relativeLocationID,
        if (stringValue != null) r'stringValue': stringValue,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
        if (variableType != null) r'variableType': variableType,
        if (variableTypeID != null) r'variableTypeID': variableTypeID,
      });

  Input$PersonVariableSortInput._(this._$data);

  factory Input$PersonVariableSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('boolValue')) {
      final l$boolValue = data['boolValue'];
      result$data['boolValue'] = l$boolValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$boolValue as String));
    }
    if (data.containsKey('calculatedValue')) {
      final l$calculatedValue = data['calculatedValue'];
      result$data['calculatedValue'] = l$calculatedValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$calculatedValue as String));
    }
    if (data.containsKey('calculatedValueTime')) {
      final l$calculatedValueTime = data['calculatedValueTime'];
      result$data['calculatedValueTime'] = l$calculatedValueTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$calculatedValueTime as String));
    }
    if (data.containsKey('calculatedValueType')) {
      final l$calculatedValueType = data['calculatedValueType'];
      result$data['calculatedValueType'] = l$calculatedValueType == null
          ? null
          : fromJson$Enum$SortEnumType((l$calculatedValueType as String));
    }
    if (data.containsKey('cohabitant')) {
      final l$cohabitant = data['cohabitant'];
      result$data['cohabitant'] = l$cohabitant == null
          ? null
          : Input$CohabitantSortInput.fromJson(
              (l$cohabitant as Map<String, dynamic>));
    }
    if (data.containsKey('cohabitantID')) {
      final l$cohabitantID = data['cohabitantID'];
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : fromJson$Enum$SortEnumType((l$cohabitantID as String));
    }
    if (data.containsKey('dateTimeValue')) {
      final l$dateTimeValue = data['dateTimeValue'];
      result$data['dateTimeValue'] = l$dateTimeValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$dateTimeValue as String));
    }
    if (data.containsKey('decimalValue')) {
      final l$decimalValue = data['decimalValue'];
      result$data['decimalValue'] = l$decimalValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$decimalValue as String));
    }
    if (data.containsKey('doubleValue')) {
      final l$doubleValue = data['doubleValue'];
      result$data['doubleValue'] = l$doubleValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$doubleValue as String));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : fromJson$Enum$SortEnumType((l$enumGroupID as String));
    }
    if (data.containsKey('enumItem')) {
      final l$enumItem = data['enumItem'];
      result$data['enumItem'] = l$enumItem == null
          ? null
          : Input$EnumItemSortInput.fromJson(
              (l$enumItem as Map<String, dynamic>));
    }
    if (data.containsKey('enumValue')) {
      final l$enumValue = data['enumValue'];
      result$data['enumValue'] = l$enumValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$enumValue as String));
    }
    if (data.containsKey('fileValue')) {
      final l$fileValue = data['fileValue'];
      result$data['fileValue'] = l$fileValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$fileValue as String));
    }
    if (data.containsKey('lastValue')) {
      final l$lastValue = data['lastValue'];
      result$data['lastValue'] = l$lastValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$lastValue as String));
    }
    if (data.containsKey('longValue')) {
      final l$longValue = data['longValue'];
      result$data['longValue'] = l$longValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$longValue as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('person')) {
      final l$person = data['person'];
      result$data['person'] = l$person == null
          ? null
          : Input$PersonSortInput.fromJson((l$person as Map<String, dynamic>));
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personID as String));
    }
    if (data.containsKey('personValue')) {
      final l$personValue = data['personValue'];
      result$data['personValue'] = l$personValue == null
          ? null
          : Input$PersonSortInput.fromJson(
              (l$personValue as Map<String, dynamic>));
    }
    if (data.containsKey('personValueID')) {
      final l$personValueID = data['personValueID'];
      result$data['personValueID'] = l$personValueID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personValueID as String));
    }
    if (data.containsKey('personVariableID')) {
      final l$personVariableID = data['personVariableID'];
      result$data['personVariableID'] = l$personVariableID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personVariableID as String));
    }
    if (data.containsKey('relativeLocation')) {
      final l$relativeLocation = data['relativeLocation'];
      result$data['relativeLocation'] = l$relativeLocation == null
          ? null
          : Input$RelativeLocationSortInput.fromJson(
              (l$relativeLocation as Map<String, dynamic>));
    }
    if (data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = data['relativeLocationID'];
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : fromJson$Enum$SortEnumType((l$relativeLocationID as String));
    }
    if (data.containsKey('stringValue')) {
      final l$stringValue = data['stringValue'];
      result$data['stringValue'] = l$stringValue == null
          ? null
          : fromJson$Enum$SortEnumType((l$stringValue as String));
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritorySortInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : fromJson$Enum$SortEnumType((l$territoryID as String));
    }
    if (data.containsKey('variableType')) {
      final l$variableType = data['variableType'];
      result$data['variableType'] = l$variableType == null
          ? null
          : Input$VariableTypeSortInput.fromJson(
              (l$variableType as Map<String, dynamic>));
    }
    if (data.containsKey('variableTypeID')) {
      final l$variableTypeID = data['variableTypeID'];
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : fromJson$Enum$SortEnumType((l$variableTypeID as String));
    }
    return Input$PersonVariableSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get boolValue =>
      (_$data['boolValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get calculatedValue =>
      (_$data['calculatedValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get calculatedValueTime =>
      (_$data['calculatedValueTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get calculatedValueType =>
      (_$data['calculatedValueType'] as Enum$SortEnumType?);
  Input$CohabitantSortInput? get cohabitant =>
      (_$data['cohabitant'] as Input$CohabitantSortInput?);
  Enum$SortEnumType? get cohabitantID =>
      (_$data['cohabitantID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get dateTimeValue =>
      (_$data['dateTimeValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get decimalValue =>
      (_$data['decimalValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get doubleValue =>
      (_$data['doubleValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get enumGroupID =>
      (_$data['enumGroupID'] as Enum$SortEnumType?);
  Input$EnumItemSortInput? get enumItem =>
      (_$data['enumItem'] as Input$EnumItemSortInput?);
  Enum$SortEnumType? get enumValue =>
      (_$data['enumValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get fileValue =>
      (_$data['fileValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get lastValue =>
      (_$data['lastValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get longValue =>
      (_$data['longValue'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Input$PersonSortInput? get person =>
      (_$data['person'] as Input$PersonSortInput?);
  Enum$SortEnumType? get personID => (_$data['personID'] as Enum$SortEnumType?);
  Input$PersonSortInput? get personValue =>
      (_$data['personValue'] as Input$PersonSortInput?);
  Enum$SortEnumType? get personValueID =>
      (_$data['personValueID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get personVariableID =>
      (_$data['personVariableID'] as Enum$SortEnumType?);
  Input$RelativeLocationSortInput? get relativeLocation =>
      (_$data['relativeLocation'] as Input$RelativeLocationSortInput?);
  Enum$SortEnumType? get relativeLocationID =>
      (_$data['relativeLocationID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get stringValue =>
      (_$data['stringValue'] as Enum$SortEnumType?);
  Input$TerritorySortInput? get territory =>
      (_$data['territory'] as Input$TerritorySortInput?);
  Enum$SortEnumType? get territoryID =>
      (_$data['territoryID'] as Enum$SortEnumType?);
  Input$VariableTypeSortInput? get variableType =>
      (_$data['variableType'] as Input$VariableTypeSortInput?);
  Enum$SortEnumType? get variableTypeID =>
      (_$data['variableTypeID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('boolValue')) {
      final l$boolValue = boolValue;
      result$data['boolValue'] =
          l$boolValue == null ? null : toJson$Enum$SortEnumType(l$boolValue);
    }
    if (_$data.containsKey('calculatedValue')) {
      final l$calculatedValue = calculatedValue;
      result$data['calculatedValue'] = l$calculatedValue == null
          ? null
          : toJson$Enum$SortEnumType(l$calculatedValue);
    }
    if (_$data.containsKey('calculatedValueTime')) {
      final l$calculatedValueTime = calculatedValueTime;
      result$data['calculatedValueTime'] = l$calculatedValueTime == null
          ? null
          : toJson$Enum$SortEnumType(l$calculatedValueTime);
    }
    if (_$data.containsKey('calculatedValueType')) {
      final l$calculatedValueType = calculatedValueType;
      result$data['calculatedValueType'] = l$calculatedValueType == null
          ? null
          : toJson$Enum$SortEnumType(l$calculatedValueType);
    }
    if (_$data.containsKey('cohabitant')) {
      final l$cohabitant = cohabitant;
      result$data['cohabitant'] = l$cohabitant?.toJson();
    }
    if (_$data.containsKey('cohabitantID')) {
      final l$cohabitantID = cohabitantID;
      result$data['cohabitantID'] = l$cohabitantID == null
          ? null
          : toJson$Enum$SortEnumType(l$cohabitantID);
    }
    if (_$data.containsKey('dateTimeValue')) {
      final l$dateTimeValue = dateTimeValue;
      result$data['dateTimeValue'] = l$dateTimeValue == null
          ? null
          : toJson$Enum$SortEnumType(l$dateTimeValue);
    }
    if (_$data.containsKey('decimalValue')) {
      final l$decimalValue = decimalValue;
      result$data['decimalValue'] = l$decimalValue == null
          ? null
          : toJson$Enum$SortEnumType(l$decimalValue);
    }
    if (_$data.containsKey('doubleValue')) {
      final l$doubleValue = doubleValue;
      result$data['doubleValue'] = l$doubleValue == null
          ? null
          : toJson$Enum$SortEnumType(l$doubleValue);
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : toJson$Enum$SortEnumType(l$enumGroupID);
    }
    if (_$data.containsKey('enumItem')) {
      final l$enumItem = enumItem;
      result$data['enumItem'] = l$enumItem?.toJson();
    }
    if (_$data.containsKey('enumValue')) {
      final l$enumValue = enumValue;
      result$data['enumValue'] =
          l$enumValue == null ? null : toJson$Enum$SortEnumType(l$enumValue);
    }
    if (_$data.containsKey('fileValue')) {
      final l$fileValue = fileValue;
      result$data['fileValue'] =
          l$fileValue == null ? null : toJson$Enum$SortEnumType(l$fileValue);
    }
    if (_$data.containsKey('lastValue')) {
      final l$lastValue = lastValue;
      result$data['lastValue'] =
          l$lastValue == null ? null : toJson$Enum$SortEnumType(l$lastValue);
    }
    if (_$data.containsKey('longValue')) {
      final l$longValue = longValue;
      result$data['longValue'] =
          l$longValue == null ? null : toJson$Enum$SortEnumType(l$longValue);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('person')) {
      final l$person = person;
      result$data['person'] = l$person?.toJson();
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] =
          l$personID == null ? null : toJson$Enum$SortEnumType(l$personID);
    }
    if (_$data.containsKey('personValue')) {
      final l$personValue = personValue;
      result$data['personValue'] = l$personValue?.toJson();
    }
    if (_$data.containsKey('personValueID')) {
      final l$personValueID = personValueID;
      result$data['personValueID'] = l$personValueID == null
          ? null
          : toJson$Enum$SortEnumType(l$personValueID);
    }
    if (_$data.containsKey('personVariableID')) {
      final l$personVariableID = personVariableID;
      result$data['personVariableID'] = l$personVariableID == null
          ? null
          : toJson$Enum$SortEnumType(l$personVariableID);
    }
    if (_$data.containsKey('relativeLocation')) {
      final l$relativeLocation = relativeLocation;
      result$data['relativeLocation'] = l$relativeLocation?.toJson();
    }
    if (_$data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = relativeLocationID;
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : toJson$Enum$SortEnumType(l$relativeLocationID);
    }
    if (_$data.containsKey('stringValue')) {
      final l$stringValue = stringValue;
      result$data['stringValue'] = l$stringValue == null
          ? null
          : toJson$Enum$SortEnumType(l$stringValue);
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID == null
          ? null
          : toJson$Enum$SortEnumType(l$territoryID);
    }
    if (_$data.containsKey('variableType')) {
      final l$variableType = variableType;
      result$data['variableType'] = l$variableType?.toJson();
    }
    if (_$data.containsKey('variableTypeID')) {
      final l$variableTypeID = variableTypeID;
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : toJson$Enum$SortEnumType(l$variableTypeID);
    }
    return result$data;
  }

  CopyWith$Input$PersonVariableSortInput<Input$PersonVariableSortInput>
      get copyWith => CopyWith$Input$PersonVariableSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PersonVariableSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$boolValue = boolValue;
    final lOther$boolValue = other.boolValue;
    if (_$data.containsKey('boolValue') !=
        other._$data.containsKey('boolValue')) {
      return false;
    }
    if (l$boolValue != lOther$boolValue) {
      return false;
    }
    final l$calculatedValue = calculatedValue;
    final lOther$calculatedValue = other.calculatedValue;
    if (_$data.containsKey('calculatedValue') !=
        other._$data.containsKey('calculatedValue')) {
      return false;
    }
    if (l$calculatedValue != lOther$calculatedValue) {
      return false;
    }
    final l$calculatedValueTime = calculatedValueTime;
    final lOther$calculatedValueTime = other.calculatedValueTime;
    if (_$data.containsKey('calculatedValueTime') !=
        other._$data.containsKey('calculatedValueTime')) {
      return false;
    }
    if (l$calculatedValueTime != lOther$calculatedValueTime) {
      return false;
    }
    final l$calculatedValueType = calculatedValueType;
    final lOther$calculatedValueType = other.calculatedValueType;
    if (_$data.containsKey('calculatedValueType') !=
        other._$data.containsKey('calculatedValueType')) {
      return false;
    }
    if (l$calculatedValueType != lOther$calculatedValueType) {
      return false;
    }
    final l$cohabitant = cohabitant;
    final lOther$cohabitant = other.cohabitant;
    if (_$data.containsKey('cohabitant') !=
        other._$data.containsKey('cohabitant')) {
      return false;
    }
    if (l$cohabitant != lOther$cohabitant) {
      return false;
    }
    final l$cohabitantID = cohabitantID;
    final lOther$cohabitantID = other.cohabitantID;
    if (_$data.containsKey('cohabitantID') !=
        other._$data.containsKey('cohabitantID')) {
      return false;
    }
    if (l$cohabitantID != lOther$cohabitantID) {
      return false;
    }
    final l$dateTimeValue = dateTimeValue;
    final lOther$dateTimeValue = other.dateTimeValue;
    if (_$data.containsKey('dateTimeValue') !=
        other._$data.containsKey('dateTimeValue')) {
      return false;
    }
    if (l$dateTimeValue != lOther$dateTimeValue) {
      return false;
    }
    final l$decimalValue = decimalValue;
    final lOther$decimalValue = other.decimalValue;
    if (_$data.containsKey('decimalValue') !=
        other._$data.containsKey('decimalValue')) {
      return false;
    }
    if (l$decimalValue != lOther$decimalValue) {
      return false;
    }
    final l$doubleValue = doubleValue;
    final lOther$doubleValue = other.doubleValue;
    if (_$data.containsKey('doubleValue') !=
        other._$data.containsKey('doubleValue')) {
      return false;
    }
    if (l$doubleValue != lOther$doubleValue) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$enumItem = enumItem;
    final lOther$enumItem = other.enumItem;
    if (_$data.containsKey('enumItem') !=
        other._$data.containsKey('enumItem')) {
      return false;
    }
    if (l$enumItem != lOther$enumItem) {
      return false;
    }
    final l$enumValue = enumValue;
    final lOther$enumValue = other.enumValue;
    if (_$data.containsKey('enumValue') !=
        other._$data.containsKey('enumValue')) {
      return false;
    }
    if (l$enumValue != lOther$enumValue) {
      return false;
    }
    final l$fileValue = fileValue;
    final lOther$fileValue = other.fileValue;
    if (_$data.containsKey('fileValue') !=
        other._$data.containsKey('fileValue')) {
      return false;
    }
    if (l$fileValue != lOther$fileValue) {
      return false;
    }
    final l$lastValue = lastValue;
    final lOther$lastValue = other.lastValue;
    if (_$data.containsKey('lastValue') !=
        other._$data.containsKey('lastValue')) {
      return false;
    }
    if (l$lastValue != lOther$lastValue) {
      return false;
    }
    final l$longValue = longValue;
    final lOther$longValue = other.longValue;
    if (_$data.containsKey('longValue') !=
        other._$data.containsKey('longValue')) {
      return false;
    }
    if (l$longValue != lOther$longValue) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$person = person;
    final lOther$person = other.person;
    if (_$data.containsKey('person') != other._$data.containsKey('person')) {
      return false;
    }
    if (l$person != lOther$person) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$personValue = personValue;
    final lOther$personValue = other.personValue;
    if (_$data.containsKey('personValue') !=
        other._$data.containsKey('personValue')) {
      return false;
    }
    if (l$personValue != lOther$personValue) {
      return false;
    }
    final l$personValueID = personValueID;
    final lOther$personValueID = other.personValueID;
    if (_$data.containsKey('personValueID') !=
        other._$data.containsKey('personValueID')) {
      return false;
    }
    if (l$personValueID != lOther$personValueID) {
      return false;
    }
    final l$personVariableID = personVariableID;
    final lOther$personVariableID = other.personVariableID;
    if (_$data.containsKey('personVariableID') !=
        other._$data.containsKey('personVariableID')) {
      return false;
    }
    if (l$personVariableID != lOther$personVariableID) {
      return false;
    }
    final l$relativeLocation = relativeLocation;
    final lOther$relativeLocation = other.relativeLocation;
    if (_$data.containsKey('relativeLocation') !=
        other._$data.containsKey('relativeLocation')) {
      return false;
    }
    if (l$relativeLocation != lOther$relativeLocation) {
      return false;
    }
    final l$relativeLocationID = relativeLocationID;
    final lOther$relativeLocationID = other.relativeLocationID;
    if (_$data.containsKey('relativeLocationID') !=
        other._$data.containsKey('relativeLocationID')) {
      return false;
    }
    if (l$relativeLocationID != lOther$relativeLocationID) {
      return false;
    }
    final l$stringValue = stringValue;
    final lOther$stringValue = other.stringValue;
    if (_$data.containsKey('stringValue') !=
        other._$data.containsKey('stringValue')) {
      return false;
    }
    if (l$stringValue != lOther$stringValue) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$variableType = variableType;
    final lOther$variableType = other.variableType;
    if (_$data.containsKey('variableType') !=
        other._$data.containsKey('variableType')) {
      return false;
    }
    if (l$variableType != lOther$variableType) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (_$data.containsKey('variableTypeID') !=
        other._$data.containsKey('variableTypeID')) {
      return false;
    }
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$boolValue = boolValue;
    final l$calculatedValue = calculatedValue;
    final l$calculatedValueTime = calculatedValueTime;
    final l$calculatedValueType = calculatedValueType;
    final l$cohabitant = cohabitant;
    final l$cohabitantID = cohabitantID;
    final l$dateTimeValue = dateTimeValue;
    final l$decimalValue = decimalValue;
    final l$doubleValue = doubleValue;
    final l$enumGroupID = enumGroupID;
    final l$enumItem = enumItem;
    final l$enumValue = enumValue;
    final l$fileValue = fileValue;
    final l$lastValue = lastValue;
    final l$longValue = longValue;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$person = person;
    final l$personID = personID;
    final l$personValue = personValue;
    final l$personValueID = personValueID;
    final l$personVariableID = personVariableID;
    final l$relativeLocation = relativeLocation;
    final l$relativeLocationID = relativeLocationID;
    final l$stringValue = stringValue;
    final l$territory = territory;
    final l$territoryID = territoryID;
    final l$variableType = variableType;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('boolValue') ? l$boolValue : const {},
      _$data.containsKey('calculatedValue') ? l$calculatedValue : const {},
      _$data.containsKey('calculatedValueTime')
          ? l$calculatedValueTime
          : const {},
      _$data.containsKey('calculatedValueType')
          ? l$calculatedValueType
          : const {},
      _$data.containsKey('cohabitant') ? l$cohabitant : const {},
      _$data.containsKey('cohabitantID') ? l$cohabitantID : const {},
      _$data.containsKey('dateTimeValue') ? l$dateTimeValue : const {},
      _$data.containsKey('decimalValue') ? l$decimalValue : const {},
      _$data.containsKey('doubleValue') ? l$doubleValue : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('enumItem') ? l$enumItem : const {},
      _$data.containsKey('enumValue') ? l$enumValue : const {},
      _$data.containsKey('fileValue') ? l$fileValue : const {},
      _$data.containsKey('lastValue') ? l$lastValue : const {},
      _$data.containsKey('longValue') ? l$longValue : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('person') ? l$person : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('personValue') ? l$personValue : const {},
      _$data.containsKey('personValueID') ? l$personValueID : const {},
      _$data.containsKey('personVariableID') ? l$personVariableID : const {},
      _$data.containsKey('relativeLocation') ? l$relativeLocation : const {},
      _$data.containsKey('relativeLocationID')
          ? l$relativeLocationID
          : const {},
      _$data.containsKey('stringValue') ? l$stringValue : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
      _$data.containsKey('variableType') ? l$variableType : const {},
      _$data.containsKey('variableTypeID') ? l$variableTypeID : const {},
    ]);
  }
}

abstract class CopyWith$Input$PersonVariableSortInput<TRes> {
  factory CopyWith$Input$PersonVariableSortInput(
    Input$PersonVariableSortInput instance,
    TRes Function(Input$PersonVariableSortInput) then,
  ) = _CopyWithImpl$Input$PersonVariableSortInput;

  factory CopyWith$Input$PersonVariableSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PersonVariableSortInput;

  TRes call({
    Enum$SortEnumType? boolValue,
    Enum$SortEnumType? calculatedValue,
    Enum$SortEnumType? calculatedValueTime,
    Enum$SortEnumType? calculatedValueType,
    Input$CohabitantSortInput? cohabitant,
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? dateTimeValue,
    Enum$SortEnumType? decimalValue,
    Enum$SortEnumType? doubleValue,
    Enum$SortEnumType? enumGroupID,
    Input$EnumItemSortInput? enumItem,
    Enum$SortEnumType? enumValue,
    Enum$SortEnumType? fileValue,
    Enum$SortEnumType? lastValue,
    Enum$SortEnumType? longValue,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Input$PersonSortInput? personValue,
    Enum$SortEnumType? personValueID,
    Enum$SortEnumType? personVariableID,
    Input$RelativeLocationSortInput? relativeLocation,
    Enum$SortEnumType? relativeLocationID,
    Enum$SortEnumType? stringValue,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
    Input$VariableTypeSortInput? variableType,
    Enum$SortEnumType? variableTypeID,
  });
  CopyWith$Input$CohabitantSortInput<TRes> get cohabitant;
  CopyWith$Input$EnumItemSortInput<TRes> get enumItem;
  CopyWith$Input$PersonSortInput<TRes> get person;
  CopyWith$Input$PersonSortInput<TRes> get personValue;
  CopyWith$Input$RelativeLocationSortInput<TRes> get relativeLocation;
  CopyWith$Input$TerritorySortInput<TRes> get territory;
  CopyWith$Input$VariableTypeSortInput<TRes> get variableType;
}

class _CopyWithImpl$Input$PersonVariableSortInput<TRes>
    implements CopyWith$Input$PersonVariableSortInput<TRes> {
  _CopyWithImpl$Input$PersonVariableSortInput(
    this._instance,
    this._then,
  );

  final Input$PersonVariableSortInput _instance;

  final TRes Function(Input$PersonVariableSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? boolValue = _undefined,
    Object? calculatedValue = _undefined,
    Object? calculatedValueTime = _undefined,
    Object? calculatedValueType = _undefined,
    Object? cohabitant = _undefined,
    Object? cohabitantID = _undefined,
    Object? dateTimeValue = _undefined,
    Object? decimalValue = _undefined,
    Object? doubleValue = _undefined,
    Object? enumGroupID = _undefined,
    Object? enumItem = _undefined,
    Object? enumValue = _undefined,
    Object? fileValue = _undefined,
    Object? lastValue = _undefined,
    Object? longValue = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? person = _undefined,
    Object? personID = _undefined,
    Object? personValue = _undefined,
    Object? personValueID = _undefined,
    Object? personVariableID = _undefined,
    Object? relativeLocation = _undefined,
    Object? relativeLocationID = _undefined,
    Object? stringValue = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
    Object? variableType = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$PersonVariableSortInput._({
        ..._instance._$data,
        if (boolValue != _undefined)
          'boolValue': (boolValue as Enum$SortEnumType?),
        if (calculatedValue != _undefined)
          'calculatedValue': (calculatedValue as Enum$SortEnumType?),
        if (calculatedValueTime != _undefined)
          'calculatedValueTime': (calculatedValueTime as Enum$SortEnumType?),
        if (calculatedValueType != _undefined)
          'calculatedValueType': (calculatedValueType as Enum$SortEnumType?),
        if (cohabitant != _undefined)
          'cohabitant': (cohabitant as Input$CohabitantSortInput?),
        if (cohabitantID != _undefined)
          'cohabitantID': (cohabitantID as Enum$SortEnumType?),
        if (dateTimeValue != _undefined)
          'dateTimeValue': (dateTimeValue as Enum$SortEnumType?),
        if (decimalValue != _undefined)
          'decimalValue': (decimalValue as Enum$SortEnumType?),
        if (doubleValue != _undefined)
          'doubleValue': (doubleValue as Enum$SortEnumType?),
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID as Enum$SortEnumType?),
        if (enumItem != _undefined)
          'enumItem': (enumItem as Input$EnumItemSortInput?),
        if (enumValue != _undefined)
          'enumValue': (enumValue as Enum$SortEnumType?),
        if (fileValue != _undefined)
          'fileValue': (fileValue as Enum$SortEnumType?),
        if (lastValue != _undefined)
          'lastValue': (lastValue as Enum$SortEnumType?),
        if (longValue != _undefined)
          'longValue': (longValue as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (person != _undefined) 'person': (person as Input$PersonSortInput?),
        if (personID != _undefined)
          'personID': (personID as Enum$SortEnumType?),
        if (personValue != _undefined)
          'personValue': (personValue as Input$PersonSortInput?),
        if (personValueID != _undefined)
          'personValueID': (personValueID as Enum$SortEnumType?),
        if (personVariableID != _undefined)
          'personVariableID': (personVariableID as Enum$SortEnumType?),
        if (relativeLocation != _undefined)
          'relativeLocation':
              (relativeLocation as Input$RelativeLocationSortInput?),
        if (relativeLocationID != _undefined)
          'relativeLocationID': (relativeLocationID as Enum$SortEnumType?),
        if (stringValue != _undefined)
          'stringValue': (stringValue as Enum$SortEnumType?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritorySortInput?),
        if (territoryID != _undefined)
          'territoryID': (territoryID as Enum$SortEnumType?),
        if (variableType != _undefined)
          'variableType': (variableType as Input$VariableTypeSortInput?),
        if (variableTypeID != _undefined)
          'variableTypeID': (variableTypeID as Enum$SortEnumType?),
      }));
  CopyWith$Input$CohabitantSortInput<TRes> get cohabitant {
    final local$cohabitant = _instance.cohabitant;
    return local$cohabitant == null
        ? CopyWith$Input$CohabitantSortInput.stub(_then(_instance))
        : CopyWith$Input$CohabitantSortInput(
            local$cohabitant, (e) => call(cohabitant: e));
  }

  CopyWith$Input$EnumItemSortInput<TRes> get enumItem {
    final local$enumItem = _instance.enumItem;
    return local$enumItem == null
        ? CopyWith$Input$EnumItemSortInput.stub(_then(_instance))
        : CopyWith$Input$EnumItemSortInput(
            local$enumItem, (e) => call(enumItem: e));
  }

  CopyWith$Input$PersonSortInput<TRes> get person {
    final local$person = _instance.person;
    return local$person == null
        ? CopyWith$Input$PersonSortInput.stub(_then(_instance))
        : CopyWith$Input$PersonSortInput(local$person, (e) => call(person: e));
  }

  CopyWith$Input$PersonSortInput<TRes> get personValue {
    final local$personValue = _instance.personValue;
    return local$personValue == null
        ? CopyWith$Input$PersonSortInput.stub(_then(_instance))
        : CopyWith$Input$PersonSortInput(
            local$personValue, (e) => call(personValue: e));
  }

  CopyWith$Input$RelativeLocationSortInput<TRes> get relativeLocation {
    final local$relativeLocation = _instance.relativeLocation;
    return local$relativeLocation == null
        ? CopyWith$Input$RelativeLocationSortInput.stub(_then(_instance))
        : CopyWith$Input$RelativeLocationSortInput(
            local$relativeLocation, (e) => call(relativeLocation: e));
  }

  CopyWith$Input$TerritorySortInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritorySortInput.stub(_then(_instance))
        : CopyWith$Input$TerritorySortInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$VariableTypeSortInput<TRes> get variableType {
    final local$variableType = _instance.variableType;
    return local$variableType == null
        ? CopyWith$Input$VariableTypeSortInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeSortInput(
            local$variableType, (e) => call(variableType: e));
  }
}

class _CopyWithStubImpl$Input$PersonVariableSortInput<TRes>
    implements CopyWith$Input$PersonVariableSortInput<TRes> {
  _CopyWithStubImpl$Input$PersonVariableSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? boolValue,
    Enum$SortEnumType? calculatedValue,
    Enum$SortEnumType? calculatedValueTime,
    Enum$SortEnumType? calculatedValueType,
    Input$CohabitantSortInput? cohabitant,
    Enum$SortEnumType? cohabitantID,
    Enum$SortEnumType? dateTimeValue,
    Enum$SortEnumType? decimalValue,
    Enum$SortEnumType? doubleValue,
    Enum$SortEnumType? enumGroupID,
    Input$EnumItemSortInput? enumItem,
    Enum$SortEnumType? enumValue,
    Enum$SortEnumType? fileValue,
    Enum$SortEnumType? lastValue,
    Enum$SortEnumType? longValue,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Input$PersonSortInput? personValue,
    Enum$SortEnumType? personValueID,
    Enum$SortEnumType? personVariableID,
    Input$RelativeLocationSortInput? relativeLocation,
    Enum$SortEnumType? relativeLocationID,
    Enum$SortEnumType? stringValue,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
    Input$VariableTypeSortInput? variableType,
    Enum$SortEnumType? variableTypeID,
  }) =>
      _res;
  CopyWith$Input$CohabitantSortInput<TRes> get cohabitant =>
      CopyWith$Input$CohabitantSortInput.stub(_res);
  CopyWith$Input$EnumItemSortInput<TRes> get enumItem =>
      CopyWith$Input$EnumItemSortInput.stub(_res);
  CopyWith$Input$PersonSortInput<TRes> get person =>
      CopyWith$Input$PersonSortInput.stub(_res);
  CopyWith$Input$PersonSortInput<TRes> get personValue =>
      CopyWith$Input$PersonSortInput.stub(_res);
  CopyWith$Input$RelativeLocationSortInput<TRes> get relativeLocation =>
      CopyWith$Input$RelativeLocationSortInput.stub(_res);
  CopyWith$Input$TerritorySortInput<TRes> get territory =>
      CopyWith$Input$TerritorySortInput.stub(_res);
  CopyWith$Input$VariableTypeSortInput<TRes> get variableType =>
      CopyWith$Input$VariableTypeSortInput.stub(_res);
}

class Input$ProvinceFilterInput {
  factory Input$ProvinceFilterInput({
    List<Input$ProvinceFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ListFilterInputTypeOfMunicipalityFilterInput? municipalities,
    Input$StringOperationFilterInput? name,
    List<Input$ProvinceFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? provinceID,
  }) =>
      Input$ProvinceFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (municipalities != null) r'municipalities': municipalities,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (provinceID != null) r'provinceID': provinceID,
      });

  Input$ProvinceFilterInput._(this._$data);

  factory Input$ProvinceFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$ProvinceFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('municipalities')) {
      final l$municipalities = data['municipalities'];
      result$data['municipalities'] = l$municipalities == null
          ? null
          : Input$ListFilterInputTypeOfMunicipalityFilterInput.fromJson(
              (l$municipalities as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$ProvinceFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('provinceID')) {
      final l$provinceID = data['provinceID'];
      result$data['provinceID'] = l$provinceID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$provinceID as Map<String, dynamic>));
    }
    return Input$ProvinceFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProvinceFilterInput>? get and =>
      (_$data['and'] as List<Input$ProvinceFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfMunicipalityFilterInput? get municipalities =>
      (_$data['municipalities']
          as Input$ListFilterInputTypeOfMunicipalityFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$ProvinceFilterInput>? get or =>
      (_$data['or'] as List<Input$ProvinceFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get provinceID =>
      (_$data['provinceID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('municipalities')) {
      final l$municipalities = municipalities;
      result$data['municipalities'] = l$municipalities?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('provinceID')) {
      final l$provinceID = provinceID;
      result$data['provinceID'] = l$provinceID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProvinceFilterInput<Input$ProvinceFilterInput> get copyWith =>
      CopyWith$Input$ProvinceFilterInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProvinceFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$municipalities = municipalities;
    final lOther$municipalities = other.municipalities;
    if (_$data.containsKey('municipalities') !=
        other._$data.containsKey('municipalities')) {
      return false;
    }
    if (l$municipalities != lOther$municipalities) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (_$data.containsKey('provinceID') !=
        other._$data.containsKey('provinceID')) {
      return false;
    }
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$municipalities = municipalities;
    final l$name = name;
    final l$or = or;
    final l$provinceID = provinceID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('municipalities') ? l$municipalities : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('provinceID') ? l$provinceID : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProvinceFilterInput<TRes> {
  factory CopyWith$Input$ProvinceFilterInput(
    Input$ProvinceFilterInput instance,
    TRes Function(Input$ProvinceFilterInput) then,
  ) = _CopyWithImpl$Input$ProvinceFilterInput;

  factory CopyWith$Input$ProvinceFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProvinceFilterInput;

  TRes call({
    List<Input$ProvinceFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ListFilterInputTypeOfMunicipalityFilterInput? municipalities,
    Input$StringOperationFilterInput? name,
    List<Input$ProvinceFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? provinceID,
  });
  TRes and(
      Iterable<Input$ProvinceFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ProvinceFilterInput<
                      Input$ProvinceFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes>
      get municipalities;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$ProvinceFilterInput>? Function(
              Iterable<
                  CopyWith$Input$ProvinceFilterInput<
                      Input$ProvinceFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID;
}

class _CopyWithImpl$Input$ProvinceFilterInput<TRes>
    implements CopyWith$Input$ProvinceFilterInput<TRes> {
  _CopyWithImpl$Input$ProvinceFilterInput(
    this._instance,
    this._then,
  );

  final Input$ProvinceFilterInput _instance;

  final TRes Function(Input$ProvinceFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? municipalities = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$ProvinceFilterInput._({
        ..._instance._$data,
        if (and != _undefined) 'and': (and as List<Input$ProvinceFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (municipalities != _undefined)
          'municipalities': (municipalities
              as Input$ListFilterInputTypeOfMunicipalityFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$ProvinceFilterInput>?),
        if (provinceID != _undefined)
          'provinceID':
              (provinceID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$ProvinceFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ProvinceFilterInput<
                          Input$ProvinceFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$ProvinceFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes>
      get municipalities {
    final local$municipalities = _instance.municipalities;
    return local$municipalities == null
        ? CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput(
            local$municipalities, (e) => call(municipalities: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$ProvinceFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$ProvinceFilterInput<
                          Input$ProvinceFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$ProvinceFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID {
    final local$provinceID = _instance.provinceID;
    return local$provinceID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$provinceID, (e) => call(provinceID: e));
  }
}

class _CopyWithStubImpl$Input$ProvinceFilterInput<TRes>
    implements CopyWith$Input$ProvinceFilterInput<TRes> {
  _CopyWithStubImpl$Input$ProvinceFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ProvinceFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$ListFilterInputTypeOfMunicipalityFilterInput? municipalities,
    Input$StringOperationFilterInput? name,
    List<Input$ProvinceFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? provinceID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput<TRes>
      get municipalities =>
          CopyWith$Input$ListFilterInputTypeOfMunicipalityFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get provinceID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$ProvinceSortInput {
  factory Input$ProvinceSortInput({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? provinceID,
  }) =>
      Input$ProvinceSortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (provinceID != null) r'provinceID': provinceID,
      });

  Input$ProvinceSortInput._(this._$data);

  factory Input$ProvinceSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('provinceID')) {
      final l$provinceID = data['provinceID'];
      result$data['provinceID'] = l$provinceID == null
          ? null
          : fromJson$Enum$SortEnumType((l$provinceID as String));
    }
    return Input$ProvinceSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Enum$SortEnumType? get provinceID =>
      (_$data['provinceID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('provinceID')) {
      final l$provinceID = provinceID;
      result$data['provinceID'] =
          l$provinceID == null ? null : toJson$Enum$SortEnumType(l$provinceID);
    }
    return result$data;
  }

  CopyWith$Input$ProvinceSortInput<Input$ProvinceSortInput> get copyWith =>
      CopyWith$Input$ProvinceSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProvinceSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$provinceID = provinceID;
    final lOther$provinceID = other.provinceID;
    if (_$data.containsKey('provinceID') !=
        other._$data.containsKey('provinceID')) {
      return false;
    }
    if (l$provinceID != lOther$provinceID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$provinceID = provinceID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('provinceID') ? l$provinceID : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProvinceSortInput<TRes> {
  factory CopyWith$Input$ProvinceSortInput(
    Input$ProvinceSortInput instance,
    TRes Function(Input$ProvinceSortInput) then,
  ) = _CopyWithImpl$Input$ProvinceSortInput;

  factory CopyWith$Input$ProvinceSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProvinceSortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? provinceID,
  });
}

class _CopyWithImpl$Input$ProvinceSortInput<TRes>
    implements CopyWith$Input$ProvinceSortInput<TRes> {
  _CopyWithImpl$Input$ProvinceSortInput(
    this._instance,
    this._then,
  );

  final Input$ProvinceSortInput _instance;

  final TRes Function(Input$ProvinceSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? provinceID = _undefined,
  }) =>
      _then(Input$ProvinceSortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (provinceID != _undefined)
          'provinceID': (provinceID as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$ProvinceSortInput<TRes>
    implements CopyWith$Input$ProvinceSortInput<TRes> {
  _CopyWithStubImpl$Input$ProvinceSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? provinceID,
  }) =>
      _res;
}

class Input$RelativeLocationFilterInput {
  factory Input$RelativeLocationFilterInput({
    List<Input$RelativeLocationFilterInput>? and,
    Input$AreaFilterInput? area,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$RelativeLocationFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ComparableInt64OperationFilterInput? relativeLocationID,
  }) =>
      Input$RelativeLocationFilterInput._({
        if (and != null) r'and': and,
        if (area != null) r'area': area,
        if (areaID != null) r'areaID': areaID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (personVariables != null) r'personVariables': personVariables,
        if (relativeLocationID != null)
          r'relativeLocationID': relativeLocationID,
      });

  Input$RelativeLocationFilterInput._(this._$data);

  factory Input$RelativeLocationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$RelativeLocationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('area')) {
      final l$area = data['area'];
      result$data['area'] = l$area == null
          ? null
          : Input$AreaFilterInput.fromJson((l$area as Map<String, dynamic>));
    }
    if (data.containsKey('areaID')) {
      final l$areaID = data['areaID'];
      result$data['areaID'] = l$areaID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$areaID as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$RelativeLocationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    if (data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = data['relativeLocationID'];
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$relativeLocationID as Map<String, dynamic>));
    }
    return Input$RelativeLocationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RelativeLocationFilterInput>? get and =>
      (_$data['and'] as List<Input$RelativeLocationFilterInput>?);
  Input$AreaFilterInput? get area => (_$data['area'] as Input$AreaFilterInput?);
  Input$ComparableInt64OperationFilterInput? get areaID =>
      (_$data['areaID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$RelativeLocationFilterInput>? get or =>
      (_$data['or'] as List<Input$RelativeLocationFilterInput>?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Input$ComparableInt64OperationFilterInput? get relativeLocationID =>
      (_$data['relativeLocationID']
          as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('area')) {
      final l$area = area;
      result$data['area'] = l$area?.toJson();
    }
    if (_$data.containsKey('areaID')) {
      final l$areaID = areaID;
      result$data['areaID'] = l$areaID?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    if (_$data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = relativeLocationID;
      result$data['relativeLocationID'] = l$relativeLocationID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RelativeLocationFilterInput<Input$RelativeLocationFilterInput>
      get copyWith => CopyWith$Input$RelativeLocationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RelativeLocationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$area = area;
    final lOther$area = other.area;
    if (_$data.containsKey('area') != other._$data.containsKey('area')) {
      return false;
    }
    if (l$area != lOther$area) {
      return false;
    }
    final l$areaID = areaID;
    final lOther$areaID = other.areaID;
    if (_$data.containsKey('areaID') != other._$data.containsKey('areaID')) {
      return false;
    }
    if (l$areaID != lOther$areaID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    final l$relativeLocationID = relativeLocationID;
    final lOther$relativeLocationID = other.relativeLocationID;
    if (_$data.containsKey('relativeLocationID') !=
        other._$data.containsKey('relativeLocationID')) {
      return false;
    }
    if (l$relativeLocationID != lOther$relativeLocationID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$area = area;
    final l$areaID = areaID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$personVariables = personVariables;
    final l$relativeLocationID = relativeLocationID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('area') ? l$area : const {},
      _$data.containsKey('areaID') ? l$areaID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
      _$data.containsKey('relativeLocationID')
          ? l$relativeLocationID
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RelativeLocationFilterInput<TRes> {
  factory CopyWith$Input$RelativeLocationFilterInput(
    Input$RelativeLocationFilterInput instance,
    TRes Function(Input$RelativeLocationFilterInput) then,
  ) = _CopyWithImpl$Input$RelativeLocationFilterInput;

  factory CopyWith$Input$RelativeLocationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RelativeLocationFilterInput;

  TRes call({
    List<Input$RelativeLocationFilterInput>? and,
    Input$AreaFilterInput? area,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$RelativeLocationFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ComparableInt64OperationFilterInput? relativeLocationID,
  });
  TRes and(
      Iterable<Input$RelativeLocationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$RelativeLocationFilterInput<
                      Input$RelativeLocationFilterInput>>?)
          _fn);
  CopyWith$Input$AreaFilterInput<TRes> get area;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$RelativeLocationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$RelativeLocationFilterInput<
                      Input$RelativeLocationFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get relativeLocationID;
}

class _CopyWithImpl$Input$RelativeLocationFilterInput<TRes>
    implements CopyWith$Input$RelativeLocationFilterInput<TRes> {
  _CopyWithImpl$Input$RelativeLocationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RelativeLocationFilterInput _instance;

  final TRes Function(Input$RelativeLocationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? area = _undefined,
    Object? areaID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? personVariables = _undefined,
    Object? relativeLocationID = _undefined,
  }) =>
      _then(Input$RelativeLocationFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$RelativeLocationFilterInput>?),
        if (area != _undefined) 'area': (area as Input$AreaFilterInput?),
        if (areaID != _undefined)
          'areaID': (areaID as Input$ComparableInt64OperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$RelativeLocationFilterInput>?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
        if (relativeLocationID != _undefined)
          'relativeLocationID': (relativeLocationID
              as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$RelativeLocationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$RelativeLocationFilterInput<
                          Input$RelativeLocationFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$RelativeLocationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$AreaFilterInput<TRes> get area {
    final local$area = _instance.area;
    return local$area == null
        ? CopyWith$Input$AreaFilterInput.stub(_then(_instance))
        : CopyWith$Input$AreaFilterInput(local$area, (e) => call(area: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID {
    final local$areaID = _instance.areaID;
    return local$areaID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$areaID, (e) => call(areaID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$RelativeLocationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$RelativeLocationFilterInput<
                          Input$RelativeLocationFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$RelativeLocationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get relativeLocationID {
    final local$relativeLocationID = _instance.relativeLocationID;
    return local$relativeLocationID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$relativeLocationID, (e) => call(relativeLocationID: e));
  }
}

class _CopyWithStubImpl$Input$RelativeLocationFilterInput<TRes>
    implements CopyWith$Input$RelativeLocationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RelativeLocationFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RelativeLocationFilterInput>? and,
    Input$AreaFilterInput? area,
    Input$ComparableInt64OperationFilterInput? areaID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$RelativeLocationFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ComparableInt64OperationFilterInput? relativeLocationID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$AreaFilterInput<TRes> get area =>
      CopyWith$Input$AreaFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get areaID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get relativeLocationID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$RelativeLocationSortInput {
  factory Input$RelativeLocationSortInput({
    Input$AreaSortInput? area,
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? relativeLocationID,
  }) =>
      Input$RelativeLocationSortInput._({
        if (area != null) r'area': area,
        if (areaID != null) r'areaID': areaID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (relativeLocationID != null)
          r'relativeLocationID': relativeLocationID,
      });

  Input$RelativeLocationSortInput._(this._$data);

  factory Input$RelativeLocationSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('area')) {
      final l$area = data['area'];
      result$data['area'] = l$area == null
          ? null
          : Input$AreaSortInput.fromJson((l$area as Map<String, dynamic>));
    }
    if (data.containsKey('areaID')) {
      final l$areaID = data['areaID'];
      result$data['areaID'] = l$areaID == null
          ? null
          : fromJson$Enum$SortEnumType((l$areaID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = data['relativeLocationID'];
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : fromJson$Enum$SortEnumType((l$relativeLocationID as String));
    }
    return Input$RelativeLocationSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AreaSortInput? get area => (_$data['area'] as Input$AreaSortInput?);
  Enum$SortEnumType? get areaID => (_$data['areaID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Enum$SortEnumType? get relativeLocationID =>
      (_$data['relativeLocationID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('area')) {
      final l$area = area;
      result$data['area'] = l$area?.toJson();
    }
    if (_$data.containsKey('areaID')) {
      final l$areaID = areaID;
      result$data['areaID'] =
          l$areaID == null ? null : toJson$Enum$SortEnumType(l$areaID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('relativeLocationID')) {
      final l$relativeLocationID = relativeLocationID;
      result$data['relativeLocationID'] = l$relativeLocationID == null
          ? null
          : toJson$Enum$SortEnumType(l$relativeLocationID);
    }
    return result$data;
  }

  CopyWith$Input$RelativeLocationSortInput<Input$RelativeLocationSortInput>
      get copyWith => CopyWith$Input$RelativeLocationSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RelativeLocationSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$area = area;
    final lOther$area = other.area;
    if (_$data.containsKey('area') != other._$data.containsKey('area')) {
      return false;
    }
    if (l$area != lOther$area) {
      return false;
    }
    final l$areaID = areaID;
    final lOther$areaID = other.areaID;
    if (_$data.containsKey('areaID') != other._$data.containsKey('areaID')) {
      return false;
    }
    if (l$areaID != lOther$areaID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$relativeLocationID = relativeLocationID;
    final lOther$relativeLocationID = other.relativeLocationID;
    if (_$data.containsKey('relativeLocationID') !=
        other._$data.containsKey('relativeLocationID')) {
      return false;
    }
    if (l$relativeLocationID != lOther$relativeLocationID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$area = area;
    final l$areaID = areaID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$relativeLocationID = relativeLocationID;
    return Object.hashAll([
      _$data.containsKey('area') ? l$area : const {},
      _$data.containsKey('areaID') ? l$areaID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('relativeLocationID')
          ? l$relativeLocationID
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RelativeLocationSortInput<TRes> {
  factory CopyWith$Input$RelativeLocationSortInput(
    Input$RelativeLocationSortInput instance,
    TRes Function(Input$RelativeLocationSortInput) then,
  ) = _CopyWithImpl$Input$RelativeLocationSortInput;

  factory CopyWith$Input$RelativeLocationSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RelativeLocationSortInput;

  TRes call({
    Input$AreaSortInput? area,
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? relativeLocationID,
  });
  CopyWith$Input$AreaSortInput<TRes> get area;
}

class _CopyWithImpl$Input$RelativeLocationSortInput<TRes>
    implements CopyWith$Input$RelativeLocationSortInput<TRes> {
  _CopyWithImpl$Input$RelativeLocationSortInput(
    this._instance,
    this._then,
  );

  final Input$RelativeLocationSortInput _instance;

  final TRes Function(Input$RelativeLocationSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? area = _undefined,
    Object? areaID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? relativeLocationID = _undefined,
  }) =>
      _then(Input$RelativeLocationSortInput._({
        ..._instance._$data,
        if (area != _undefined) 'area': (area as Input$AreaSortInput?),
        if (areaID != _undefined) 'areaID': (areaID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (relativeLocationID != _undefined)
          'relativeLocationID': (relativeLocationID as Enum$SortEnumType?),
      }));
  CopyWith$Input$AreaSortInput<TRes> get area {
    final local$area = _instance.area;
    return local$area == null
        ? CopyWith$Input$AreaSortInput.stub(_then(_instance))
        : CopyWith$Input$AreaSortInput(local$area, (e) => call(area: e));
  }
}

class _CopyWithStubImpl$Input$RelativeLocationSortInput<TRes>
    implements CopyWith$Input$RelativeLocationSortInput<TRes> {
  _CopyWithStubImpl$Input$RelativeLocationSortInput(this._res);

  TRes _res;

  call({
    Input$AreaSortInput? area,
    Enum$SortEnumType? areaID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? relativeLocationID,
  }) =>
      _res;
  CopyWith$Input$AreaSortInput<TRes> get area =>
      CopyWith$Input$AreaSortInput.stub(_res);
}

class Input$RolePermissionFilterInput {
  factory Input$RolePermissionFilterInput({
    List<Input$RolePermissionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$RolePermissionFilterInput>? or,
    Input$PermissionOperationFilterInput? permission,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
  }) =>
      Input$RolePermissionFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (permission != null) r'permission': permission,
        if (role != null) r'role': role,
        if (roleID != null) r'roleID': roleID,
      });

  Input$RolePermissionFilterInput._(this._$data);

  factory Input$RolePermissionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$RolePermissionFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$RolePermissionFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('permission')) {
      final l$permission = data['permission'];
      result$data['permission'] = l$permission == null
          ? null
          : Input$PermissionOperationFilterInput.fromJson(
              (l$permission as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleID')) {
      final l$roleID = data['roleID'];
      result$data['roleID'] = l$roleID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$roleID as Map<String, dynamic>));
    }
    return Input$RolePermissionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RolePermissionFilterInput>? get and =>
      (_$data['and'] as List<Input$RolePermissionFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$RolePermissionFilterInput>? get or =>
      (_$data['or'] as List<Input$RolePermissionFilterInput>?);
  Input$PermissionOperationFilterInput? get permission =>
      (_$data['permission'] as Input$PermissionOperationFilterInput?);
  Input$ApplicationRoleFilterInput? get role =>
      (_$data['role'] as Input$ApplicationRoleFilterInput?);
  Input$StringOperationFilterInput? get roleID =>
      (_$data['roleID'] as Input$StringOperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('permission')) {
      final l$permission = permission;
      result$data['permission'] = l$permission?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleID')) {
      final l$roleID = roleID;
      result$data['roleID'] = l$roleID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RolePermissionFilterInput<Input$RolePermissionFilterInput>
      get copyWith => CopyWith$Input$RolePermissionFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RolePermissionFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (_$data.containsKey('permission') !=
        other._$data.containsKey('permission')) {
      return false;
    }
    if (l$permission != lOther$permission) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (_$data.containsKey('roleID') != other._$data.containsKey('roleID')) {
      return false;
    }
    if (l$roleID != lOther$roleID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$permission = permission;
    final l$role = role;
    final l$roleID = roleID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('permission') ? l$permission : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleID') ? l$roleID : const {},
    ]);
  }
}

abstract class CopyWith$Input$RolePermissionFilterInput<TRes> {
  factory CopyWith$Input$RolePermissionFilterInput(
    Input$RolePermissionFilterInput instance,
    TRes Function(Input$RolePermissionFilterInput) then,
  ) = _CopyWithImpl$Input$RolePermissionFilterInput;

  factory CopyWith$Input$RolePermissionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RolePermissionFilterInput;

  TRes call({
    List<Input$RolePermissionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$RolePermissionFilterInput>? or,
    Input$PermissionOperationFilterInput? permission,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
  });
  TRes and(
      Iterable<Input$RolePermissionFilterInput>? Function(
              Iterable<
                  CopyWith$Input$RolePermissionFilterInput<
                      Input$RolePermissionFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$RolePermissionFilterInput>? Function(
              Iterable<
                  CopyWith$Input$RolePermissionFilterInput<
                      Input$RolePermissionFilterInput>>?)
          _fn);
  CopyWith$Input$PermissionOperationFilterInput<TRes> get permission;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role;
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID;
}

class _CopyWithImpl$Input$RolePermissionFilterInput<TRes>
    implements CopyWith$Input$RolePermissionFilterInput<TRes> {
  _CopyWithImpl$Input$RolePermissionFilterInput(
    this._instance,
    this._then,
  );

  final Input$RolePermissionFilterInput _instance;

  final TRes Function(Input$RolePermissionFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? permission = _undefined,
    Object? role = _undefined,
    Object? roleID = _undefined,
  }) =>
      _then(Input$RolePermissionFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$RolePermissionFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$RolePermissionFilterInput>?),
        if (permission != _undefined)
          'permission': (permission as Input$PermissionOperationFilterInput?),
        if (role != _undefined)
          'role': (role as Input$ApplicationRoleFilterInput?),
        if (roleID != _undefined)
          'roleID': (roleID as Input$StringOperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$RolePermissionFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$RolePermissionFilterInput<
                          Input$RolePermissionFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$RolePermissionFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$RolePermissionFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$RolePermissionFilterInput<
                          Input$RolePermissionFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$RolePermissionFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$PermissionOperationFilterInput<TRes> get permission {
    final local$permission = _instance.permission;
    return local$permission == null
        ? CopyWith$Input$PermissionOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$PermissionOperationFilterInput(
            local$permission, (e) => call(permission: e));
  }

  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get roleID {
    final local$roleID = _instance.roleID;
    return local$roleID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$roleID, (e) => call(roleID: e));
  }
}

class _CopyWithStubImpl$Input$RolePermissionFilterInput<TRes>
    implements CopyWith$Input$RolePermissionFilterInput<TRes> {
  _CopyWithStubImpl$Input$RolePermissionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RolePermissionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$RolePermissionFilterInput>? or,
    Input$PermissionOperationFilterInput? permission,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$PermissionOperationFilterInput<TRes> get permission =>
      CopyWith$Input$PermissionOperationFilterInput.stub(_res);
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$RolePermissionSortInput {
  factory Input$RolePermissionSortInput({
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? permission,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
  }) =>
      Input$RolePermissionSortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (permission != null) r'permission': permission,
        if (role != null) r'role': role,
        if (roleID != null) r'roleID': roleID,
      });

  Input$RolePermissionSortInput._(this._$data);

  factory Input$RolePermissionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('permission')) {
      final l$permission = data['permission'];
      result$data['permission'] = l$permission == null
          ? null
          : fromJson$Enum$SortEnumType((l$permission as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ApplicationRoleSortInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleID')) {
      final l$roleID = data['roleID'];
      result$data['roleID'] = l$roleID == null
          ? null
          : fromJson$Enum$SortEnumType((l$roleID as String));
    }
    return Input$RolePermissionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get permission =>
      (_$data['permission'] as Enum$SortEnumType?);
  Input$ApplicationRoleSortInput? get role =>
      (_$data['role'] as Input$ApplicationRoleSortInput?);
  Enum$SortEnumType? get roleID => (_$data['roleID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('permission')) {
      final l$permission = permission;
      result$data['permission'] =
          l$permission == null ? null : toJson$Enum$SortEnumType(l$permission);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleID')) {
      final l$roleID = roleID;
      result$data['roleID'] =
          l$roleID == null ? null : toJson$Enum$SortEnumType(l$roleID);
    }
    return result$data;
  }

  CopyWith$Input$RolePermissionSortInput<Input$RolePermissionSortInput>
      get copyWith => CopyWith$Input$RolePermissionSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RolePermissionSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (_$data.containsKey('permission') !=
        other._$data.containsKey('permission')) {
      return false;
    }
    if (l$permission != lOther$permission) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (_$data.containsKey('roleID') != other._$data.containsKey('roleID')) {
      return false;
    }
    if (l$roleID != lOther$roleID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$permission = permission;
    final l$role = role;
    final l$roleID = roleID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('permission') ? l$permission : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleID') ? l$roleID : const {},
    ]);
  }
}

abstract class CopyWith$Input$RolePermissionSortInput<TRes> {
  factory CopyWith$Input$RolePermissionSortInput(
    Input$RolePermissionSortInput instance,
    TRes Function(Input$RolePermissionSortInput) then,
  ) = _CopyWithImpl$Input$RolePermissionSortInput;

  factory CopyWith$Input$RolePermissionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RolePermissionSortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? permission,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
  });
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
  CopyWith$Input$ApplicationRoleSortInput<TRes> get role;
}

class _CopyWithImpl$Input$RolePermissionSortInput<TRes>
    implements CopyWith$Input$RolePermissionSortInput<TRes> {
  _CopyWithImpl$Input$RolePermissionSortInput(
    this._instance,
    this._then,
  );

  final Input$RolePermissionSortInput _instance;

  final TRes Function(Input$RolePermissionSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? permission = _undefined,
    Object? role = _undefined,
    Object? roleID = _undefined,
  }) =>
      _then(Input$RolePermissionSortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (permission != _undefined)
          'permission': (permission as Enum$SortEnumType?),
        if (role != _undefined)
          'role': (role as Input$ApplicationRoleSortInput?),
        if (roleID != _undefined) 'roleID': (roleID as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$ApplicationRoleSortInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ApplicationRoleSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleSortInput(
            local$role, (e) => call(role: e));
  }
}

class _CopyWithStubImpl$Input$RolePermissionSortInput<TRes>
    implements CopyWith$Input$RolePermissionSortInput<TRes> {
  _CopyWithStubImpl$Input$RolePermissionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? permission,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
  }) =>
      _res;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
  CopyWith$Input$ApplicationRoleSortInput<TRes> get role =>
      CopyWith$Input$ApplicationRoleSortInput.stub(_res);
}

class Input$SectionFilterInput {
  factory Input$SectionFilterInput({
    List<Input$SectionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$SectionFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfTerritoryFilterInput? territories,
  }) =>
      Input$SectionFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (sectionID != null) r'sectionID': sectionID,
        if (territories != null) r'territories': territories,
      });

  Input$SectionFilterInput._(this._$data);

  factory Input$SectionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$SectionFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$SectionFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('sectionID')) {
      final l$sectionID = data['sectionID'];
      result$data['sectionID'] = l$sectionID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$sectionID as Map<String, dynamic>));
    }
    if (data.containsKey('territories')) {
      final l$territories = data['territories'];
      result$data['territories'] = l$territories == null
          ? null
          : Input$ListFilterInputTypeOfTerritoryFilterInput.fromJson(
              (l$territories as Map<String, dynamic>));
    }
    return Input$SectionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SectionFilterInput>? get and =>
      (_$data['and'] as List<Input$SectionFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$SectionFilterInput>? get or =>
      (_$data['or'] as List<Input$SectionFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get sectionID =>
      (_$data['sectionID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfTerritoryFilterInput? get territories =>
      (_$data['territories']
          as Input$ListFilterInputTypeOfTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('sectionID')) {
      final l$sectionID = sectionID;
      result$data['sectionID'] = l$sectionID?.toJson();
    }
    if (_$data.containsKey('territories')) {
      final l$territories = territories;
      result$data['territories'] = l$territories?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SectionFilterInput<Input$SectionFilterInput> get copyWith =>
      CopyWith$Input$SectionFilterInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SectionFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (_$data.containsKey('sectionID') !=
        other._$data.containsKey('sectionID')) {
      return false;
    }
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    final l$territories = territories;
    final lOther$territories = other.territories;
    if (_$data.containsKey('territories') !=
        other._$data.containsKey('territories')) {
      return false;
    }
    if (l$territories != lOther$territories) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$sectionID = sectionID;
    final l$territories = territories;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('sectionID') ? l$sectionID : const {},
      _$data.containsKey('territories') ? l$territories : const {},
    ]);
  }
}

abstract class CopyWith$Input$SectionFilterInput<TRes> {
  factory CopyWith$Input$SectionFilterInput(
    Input$SectionFilterInput instance,
    TRes Function(Input$SectionFilterInput) then,
  ) = _CopyWithImpl$Input$SectionFilterInput;

  factory CopyWith$Input$SectionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SectionFilterInput;

  TRes call({
    List<Input$SectionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$SectionFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfTerritoryFilterInput? territories,
  });
  TRes and(
      Iterable<Input$SectionFilterInput>? Function(
              Iterable<
                  CopyWith$Input$SectionFilterInput<Input$SectionFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$SectionFilterInput>? Function(
              Iterable<
                  CopyWith$Input$SectionFilterInput<Input$SectionFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID;
  CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes>
      get territories;
}

class _CopyWithImpl$Input$SectionFilterInput<TRes>
    implements CopyWith$Input$SectionFilterInput<TRes> {
  _CopyWithImpl$Input$SectionFilterInput(
    this._instance,
    this._then,
  );

  final Input$SectionFilterInput _instance;

  final TRes Function(Input$SectionFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? sectionID = _undefined,
    Object? territories = _undefined,
  }) =>
      _then(Input$SectionFilterInput._({
        ..._instance._$data,
        if (and != _undefined) 'and': (and as List<Input$SectionFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$SectionFilterInput>?),
        if (sectionID != _undefined)
          'sectionID':
              (sectionID as Input$ComparableInt64OperationFilterInput?),
        if (territories != _undefined)
          'territories':
              (territories as Input$ListFilterInputTypeOfTerritoryFilterInput?),
      }));
  TRes and(
          Iterable<Input$SectionFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$SectionFilterInput<
                          Input$SectionFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map((e) => CopyWith$Input$SectionFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$SectionFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$SectionFilterInput<
                          Input$SectionFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$SectionFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID {
    final local$sectionID = _instance.sectionID;
    return local$sectionID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$sectionID, (e) => call(sectionID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes>
      get territories {
    final local$territories = _instance.territories;
    return local$territories == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput(
            local$territories, (e) => call(territories: e));
  }
}

class _CopyWithStubImpl$Input$SectionFilterInput<TRes>
    implements CopyWith$Input$SectionFilterInput<TRes> {
  _CopyWithStubImpl$Input$SectionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SectionFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$SectionFilterInput>? or,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfTerritoryFilterInput? territories,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput<TRes>
      get territories =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryFilterInput.stub(_res);
}

class Input$SectionSortInput {
  factory Input$SectionSortInput({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? sectionID,
  }) =>
      Input$SectionSortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (sectionID != null) r'sectionID': sectionID,
      });

  Input$SectionSortInput._(this._$data);

  factory Input$SectionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('sectionID')) {
      final l$sectionID = data['sectionID'];
      result$data['sectionID'] = l$sectionID == null
          ? null
          : fromJson$Enum$SortEnumType((l$sectionID as String));
    }
    return Input$SectionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Enum$SortEnumType? get sectionID =>
      (_$data['sectionID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('sectionID')) {
      final l$sectionID = sectionID;
      result$data['sectionID'] =
          l$sectionID == null ? null : toJson$Enum$SortEnumType(l$sectionID);
    }
    return result$data;
  }

  CopyWith$Input$SectionSortInput<Input$SectionSortInput> get copyWith =>
      CopyWith$Input$SectionSortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SectionSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (_$data.containsKey('sectionID') !=
        other._$data.containsKey('sectionID')) {
      return false;
    }
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$sectionID = sectionID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sectionID') ? l$sectionID : const {},
    ]);
  }
}

abstract class CopyWith$Input$SectionSortInput<TRes> {
  factory CopyWith$Input$SectionSortInput(
    Input$SectionSortInput instance,
    TRes Function(Input$SectionSortInput) then,
  ) = _CopyWithImpl$Input$SectionSortInput;

  factory CopyWith$Input$SectionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SectionSortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? sectionID,
  });
}

class _CopyWithImpl$Input$SectionSortInput<TRes>
    implements CopyWith$Input$SectionSortInput<TRes> {
  _CopyWithImpl$Input$SectionSortInput(
    this._instance,
    this._then,
  );

  final Input$SectionSortInput _instance;

  final TRes Function(Input$SectionSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? sectionID = _undefined,
  }) =>
      _then(Input$SectionSortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (sectionID != _undefined)
          'sectionID': (sectionID as Enum$SortEnumType?),
      }));
}

class _CopyWithStubImpl$Input$SectionSortInput<TRes>
    implements CopyWith$Input$SectionSortInput<TRes> {
  _CopyWithStubImpl$Input$SectionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? sectionID,
  }) =>
      _res;
}

class Input$StringOperationFilterInput {
  factory Input$StringOperationFilterInput({
    List<Input$StringOperationFilterInput>? and,
    String? contains,
    String? endsWith,
    String? eq,
    List<String?>? $in,
    String? ncontains,
    String? nendsWith,
    String? neq,
    List<String?>? nin,
    String? nstartsWith,
    List<Input$StringOperationFilterInput>? or,
    String? startsWith,
  }) =>
      Input$StringOperationFilterInput._({
        if (and != null) r'and': and,
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (eq != null) r'eq': eq,
        if ($in != null) r'in': $in,
        if (ncontains != null) r'ncontains': ncontains,
        if (nendsWith != null) r'nendsWith': nendsWith,
        if (neq != null) r'neq': neq,
        if (nin != null) r'nin': nin,
        if (nstartsWith != null) r'nstartsWith': nstartsWith,
        if (or != null) r'or': or,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringOperationFilterInput._(this._$data);

  factory Input$StringOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$StringOperationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('ncontains')) {
      final l$ncontains = data['ncontains'];
      result$data['ncontains'] = (l$ncontains as String?);
    }
    if (data.containsKey('nendsWith')) {
      final l$nendsWith = data['nendsWith'];
      result$data['nendsWith'] = (l$nendsWith as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] =
          (l$nin as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('nstartsWith')) {
      final l$nstartsWith = data['nstartsWith'];
      result$data['nstartsWith'] = (l$nstartsWith as String?);
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$StringOperationFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$StringOperationFilterInput>? get and =>
      (_$data['and'] as List<Input$StringOperationFilterInput>?);
  String? get contains => (_$data['contains'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  String? get eq => (_$data['eq'] as String?);
  List<String?>? get $in => (_$data['in'] as List<String?>?);
  String? get ncontains => (_$data['ncontains'] as String?);
  String? get nendsWith => (_$data['nendsWith'] as String?);
  String? get neq => (_$data['neq'] as String?);
  List<String?>? get nin => (_$data['nin'] as List<String?>?);
  String? get nstartsWith => (_$data['nstartsWith'] as String?);
  List<Input$StringOperationFilterInput>? get or =>
      (_$data['or'] as List<Input$StringOperationFilterInput>?);
  String? get startsWith => (_$data['startsWith'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('ncontains')) {
      final l$ncontains = ncontains;
      result$data['ncontains'] = l$ncontains;
    }
    if (_$data.containsKey('nendsWith')) {
      final l$nendsWith = nendsWith;
      result$data['nendsWith'] = l$nendsWith;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('nstartsWith')) {
      final l$nstartsWith = nstartsWith;
      result$data['nstartsWith'] = l$nstartsWith;
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringOperationFilterInput<Input$StringOperationFilterInput>
      get copyWith => CopyWith$Input$StringOperationFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringOperationFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$ncontains = ncontains;
    final lOther$ncontains = other.ncontains;
    if (_$data.containsKey('ncontains') !=
        other._$data.containsKey('ncontains')) {
      return false;
    }
    if (l$ncontains != lOther$ncontains) {
      return false;
    }
    final l$nendsWith = nendsWith;
    final lOther$nendsWith = other.nendsWith;
    if (_$data.containsKey('nendsWith') !=
        other._$data.containsKey('nendsWith')) {
      return false;
    }
    if (l$nendsWith != lOther$nendsWith) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$nstartsWith = nstartsWith;
    final lOther$nstartsWith = other.nstartsWith;
    if (_$data.containsKey('nstartsWith') !=
        other._$data.containsKey('nstartsWith')) {
      return false;
    }
    if (l$nstartsWith != lOther$nstartsWith) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$eq = eq;
    final l$$in = $in;
    final l$ncontains = ncontains;
    final l$nendsWith = nendsWith;
    final l$neq = neq;
    final l$nin = nin;
    final l$nstartsWith = nstartsWith;
    final l$or = or;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('ncontains') ? l$ncontains : const {},
      _$data.containsKey('nendsWith') ? l$nendsWith : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('nin')
          ? l$nin == null
              ? null
              : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('nstartsWith') ? l$nstartsWith : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringOperationFilterInput<TRes> {
  factory CopyWith$Input$StringOperationFilterInput(
    Input$StringOperationFilterInput instance,
    TRes Function(Input$StringOperationFilterInput) then,
  ) = _CopyWithImpl$Input$StringOperationFilterInput;

  factory CopyWith$Input$StringOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringOperationFilterInput;

  TRes call({
    List<Input$StringOperationFilterInput>? and,
    String? contains,
    String? endsWith,
    String? eq,
    List<String?>? $in,
    String? ncontains,
    String? nendsWith,
    String? neq,
    List<String?>? nin,
    String? nstartsWith,
    List<Input$StringOperationFilterInput>? or,
    String? startsWith,
  });
  TRes and(
      Iterable<Input$StringOperationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$StringOperationFilterInput<
                      Input$StringOperationFilterInput>>?)
          _fn);
  TRes or(
      Iterable<Input$StringOperationFilterInput>? Function(
              Iterable<
                  CopyWith$Input$StringOperationFilterInput<
                      Input$StringOperationFilterInput>>?)
          _fn);
}

class _CopyWithImpl$Input$StringOperationFilterInput<TRes>
    implements CopyWith$Input$StringOperationFilterInput<TRes> {
  _CopyWithImpl$Input$StringOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$StringOperationFilterInput _instance;

  final TRes Function(Input$StringOperationFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? eq = _undefined,
    Object? $in = _undefined,
    Object? ncontains = _undefined,
    Object? nendsWith = _undefined,
    Object? neq = _undefined,
    Object? nin = _undefined,
    Object? nstartsWith = _undefined,
    Object? or = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringOperationFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$StringOperationFilterInput>?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (eq != _undefined) 'eq': (eq as String?),
        if ($in != _undefined) 'in': ($in as List<String?>?),
        if (ncontains != _undefined) 'ncontains': (ncontains as String?),
        if (nendsWith != _undefined) 'nendsWith': (nendsWith as String?),
        if (neq != _undefined) 'neq': (neq as String?),
        if (nin != _undefined) 'nin': (nin as List<String?>?),
        if (nstartsWith != _undefined) 'nstartsWith': (nstartsWith as String?),
        if (or != _undefined)
          'or': (or as List<Input$StringOperationFilterInput>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));
  TRes and(
          Iterable<Input$StringOperationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$StringOperationFilterInput<
                          Input$StringOperationFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$StringOperationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes or(
          Iterable<Input$StringOperationFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$StringOperationFilterInput<
                          Input$StringOperationFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$StringOperationFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$StringOperationFilterInput<TRes>
    implements CopyWith$Input$StringOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$StringOperationFilterInput(this._res);

  TRes _res;

  call({
    List<Input$StringOperationFilterInput>? and,
    String? contains,
    String? endsWith,
    String? eq,
    List<String?>? $in,
    String? ncontains,
    String? nendsWith,
    String? neq,
    List<String?>? nin,
    String? nstartsWith,
    List<Input$StringOperationFilterInput>? or,
    String? startsWith,
  }) =>
      _res;
  and(_fn) => _res;
  or(_fn) => _res;
}

class Input$SuscriptionTerritoryFilterInput {
  factory Input$SuscriptionTerritoryFilterInput({
    List<Input$SuscriptionTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$SuscriptionTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      Input$SuscriptionTerritoryFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
        if (variableType != null) r'variableType': variableType,
        if (variableTypeID != null) r'variableTypeID': variableTypeID,
      });

  Input$SuscriptionTerritoryFilterInput._(this._$data);

  factory Input$SuscriptionTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$SuscriptionTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$SuscriptionTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    if (data.containsKey('variableType')) {
      final l$variableType = data['variableType'];
      result$data['variableType'] = l$variableType == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$variableType as Map<String, dynamic>));
    }
    if (data.containsKey('variableTypeID')) {
      final l$variableTypeID = data['variableTypeID'];
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$variableTypeID as Map<String, dynamic>));
    }
    return Input$SuscriptionTerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SuscriptionTerritoryFilterInput>? get and =>
      (_$data['and'] as List<Input$SuscriptionTerritoryFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$SuscriptionTerritoryFilterInput>? get or =>
      (_$data['or'] as List<Input$SuscriptionTerritoryFilterInput>?);
  Input$TerritoryFilterInput? get territory =>
      (_$data['territory'] as Input$TerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Input$VariableTypeFilterInput? get variableType =>
      (_$data['variableType'] as Input$VariableTypeFilterInput?);
  Input$ComparableInt64OperationFilterInput? get variableTypeID =>
      (_$data['variableTypeID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    if (_$data.containsKey('variableType')) {
      final l$variableType = variableType;
      result$data['variableType'] = l$variableType?.toJson();
    }
    if (_$data.containsKey('variableTypeID')) {
      final l$variableTypeID = variableTypeID;
      result$data['variableTypeID'] = l$variableTypeID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SuscriptionTerritoryFilterInput<
          Input$SuscriptionTerritoryFilterInput>
      get copyWith => CopyWith$Input$SuscriptionTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SuscriptionTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$variableType = variableType;
    final lOther$variableType = other.variableType;
    if (_$data.containsKey('variableType') !=
        other._$data.containsKey('variableType')) {
      return false;
    }
    if (l$variableType != lOther$variableType) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (_$data.containsKey('variableTypeID') !=
        other._$data.containsKey('variableTypeID')) {
      return false;
    }
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$territory = territory;
    final l$territoryID = territoryID;
    final l$variableType = variableType;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
      _$data.containsKey('variableType') ? l$variableType : const {},
      _$data.containsKey('variableTypeID') ? l$variableTypeID : const {},
    ]);
  }
}

abstract class CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> {
  factory CopyWith$Input$SuscriptionTerritoryFilterInput(
    Input$SuscriptionTerritoryFilterInput instance,
    TRes Function(Input$SuscriptionTerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$SuscriptionTerritoryFilterInput;

  factory CopyWith$Input$SuscriptionTerritoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SuscriptionTerritoryFilterInput;

  TRes call({
    List<Input$SuscriptionTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$SuscriptionTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  });
  TRes and(
      Iterable<Input$SuscriptionTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$SuscriptionTerritoryFilterInput<
                      Input$SuscriptionTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$SuscriptionTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$SuscriptionTerritoryFilterInput<
                      Input$SuscriptionTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$TerritoryFilterInput<TRes> get territory;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID;
}

class _CopyWithImpl$Input$SuscriptionTerritoryFilterInput<TRes>
    implements CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$SuscriptionTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$SuscriptionTerritoryFilterInput _instance;

  final TRes Function(Input$SuscriptionTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
    Object? variableType = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$SuscriptionTerritoryFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$SuscriptionTerritoryFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$SuscriptionTerritoryFilterInput>?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritoryFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
        if (variableType != _undefined)
          'variableType': (variableType as Input$VariableTypeFilterInput?),
        if (variableTypeID != _undefined)
          'variableTypeID':
              (variableTypeID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$SuscriptionTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$SuscriptionTerritoryFilterInput<
                          Input$SuscriptionTerritoryFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$SuscriptionTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$SuscriptionTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$SuscriptionTerritoryFilterInput<
                          Input$SuscriptionTerritoryFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$SuscriptionTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$TerritoryFilterInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType {
    final local$variableType = _instance.variableType;
    return local$variableType == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$variableType, (e) => call(variableType: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID {
    final local$variableTypeID = _instance.variableTypeID;
    return local$variableTypeID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$variableTypeID, (e) => call(variableTypeID: e));
  }
}

class _CopyWithStubImpl$Input$SuscriptionTerritoryFilterInput<TRes>
    implements CopyWith$Input$SuscriptionTerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$SuscriptionTerritoryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SuscriptionTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$SuscriptionTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$VariableTypeFilterInput? variableType,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$TerritoryFilterInput<TRes> get territory =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get variableType =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$TerritoryFilterInput {
  factory Input$TerritoryFilterInput({
    List<Input$TerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRole,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  }) =>
      Input$TerritoryFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (personVariables != null) r'personVariables': personVariables,
        if (section != null) r'section': section,
        if (sectionID != null) r'sectionID': sectionID,
        if (suscriptionTerritories != null)
          r'suscriptionTerritories': suscriptionTerritories,
        if (territoryGroupTerritories != null)
          r'territoryGroupTerritories': territoryGroupTerritories,
        if (territoryID != null) r'territoryID': territoryID,
        if (territoryRole != null) r'territoryRole': territoryRole,
        if (userTerritories != null) r'userTerritories': userTerritories,
      });

  Input$TerritoryFilterInput._(this._$data);

  factory Input$TerritoryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$TerritoryFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$TerritoryFilterInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    if (data.containsKey('section')) {
      final l$section = data['section'];
      result$data['section'] = l$section == null
          ? null
          : Input$SectionFilterInput.fromJson(
              (l$section as Map<String, dynamic>));
    }
    if (data.containsKey('sectionID')) {
      final l$sectionID = data['sectionID'];
      result$data['sectionID'] = l$sectionID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$sectionID as Map<String, dynamic>));
    }
    if (data.containsKey('suscriptionTerritories')) {
      final l$suscriptionTerritories = data['suscriptionTerritories'];
      result$data['suscriptionTerritories'] = l$suscriptionTerritories == null
          ? null
          : Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput.fromJson(
              (l$suscriptionTerritories as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupTerritories')) {
      final l$territoryGroupTerritories = data['territoryGroupTerritories'];
      result$data['territoryGroupTerritories'] = l$territoryGroupTerritories ==
              null
          ? null
          : Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
              .fromJson((l$territoryGroupTerritories as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    if (data.containsKey('territoryRole')) {
      final l$territoryRole = data['territoryRole'];
      result$data['territoryRole'] = l$territoryRole == null
          ? null
          : Input$ListFilterInputTypeOfTerritoryRoleFilterInput.fromJson(
              (l$territoryRole as Map<String, dynamic>));
    }
    if (data.containsKey('userTerritories')) {
      final l$userTerritories = data['userTerritories'];
      result$data['userTerritories'] = l$userTerritories == null
          ? null
          : Input$ListFilterInputTypeOfUserTerritoryFilterInput.fromJson(
              (l$userTerritories as Map<String, dynamic>));
    }
    return Input$TerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TerritoryFilterInput>? get and =>
      (_$data['and'] as List<Input$TerritoryFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$TerritoryFilterInput>? get or =>
      (_$data['or'] as List<Input$TerritoryFilterInput>?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Input$SectionFilterInput? get section =>
      (_$data['section'] as Input$SectionFilterInput?);
  Input$ComparableInt64OperationFilterInput? get sectionID =>
      (_$data['sectionID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
      get suscriptionTerritories => (_$data['suscriptionTerritories']
          as Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?);
  Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
      get territoryGroupTerritories => (_$data['territoryGroupTerritories']
          as Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfTerritoryRoleFilterInput? get territoryRole =>
      (_$data['territoryRole']
          as Input$ListFilterInputTypeOfTerritoryRoleFilterInput?);
  Input$ListFilterInputTypeOfUserTerritoryFilterInput? get userTerritories =>
      (_$data['userTerritories']
          as Input$ListFilterInputTypeOfUserTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    if (_$data.containsKey('section')) {
      final l$section = section;
      result$data['section'] = l$section?.toJson();
    }
    if (_$data.containsKey('sectionID')) {
      final l$sectionID = sectionID;
      result$data['sectionID'] = l$sectionID?.toJson();
    }
    if (_$data.containsKey('suscriptionTerritories')) {
      final l$suscriptionTerritories = suscriptionTerritories;
      result$data['suscriptionTerritories'] =
          l$suscriptionTerritories?.toJson();
    }
    if (_$data.containsKey('territoryGroupTerritories')) {
      final l$territoryGroupTerritories = territoryGroupTerritories;
      result$data['territoryGroupTerritories'] =
          l$territoryGroupTerritories?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    if (_$data.containsKey('territoryRole')) {
      final l$territoryRole = territoryRole;
      result$data['territoryRole'] = l$territoryRole?.toJson();
    }
    if (_$data.containsKey('userTerritories')) {
      final l$userTerritories = userTerritories;
      result$data['userTerritories'] = l$userTerritories?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TerritoryFilterInput<Input$TerritoryFilterInput>
      get copyWith => CopyWith$Input$TerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    final l$section = section;
    final lOther$section = other.section;
    if (_$data.containsKey('section') != other._$data.containsKey('section')) {
      return false;
    }
    if (l$section != lOther$section) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (_$data.containsKey('sectionID') !=
        other._$data.containsKey('sectionID')) {
      return false;
    }
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    final l$suscriptionTerritories = suscriptionTerritories;
    final lOther$suscriptionTerritories = other.suscriptionTerritories;
    if (_$data.containsKey('suscriptionTerritories') !=
        other._$data.containsKey('suscriptionTerritories')) {
      return false;
    }
    if (l$suscriptionTerritories != lOther$suscriptionTerritories) {
      return false;
    }
    final l$territoryGroupTerritories = territoryGroupTerritories;
    final lOther$territoryGroupTerritories = other.territoryGroupTerritories;
    if (_$data.containsKey('territoryGroupTerritories') !=
        other._$data.containsKey('territoryGroupTerritories')) {
      return false;
    }
    if (l$territoryGroupTerritories != lOther$territoryGroupTerritories) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$territoryRole = territoryRole;
    final lOther$territoryRole = other.territoryRole;
    if (_$data.containsKey('territoryRole') !=
        other._$data.containsKey('territoryRole')) {
      return false;
    }
    if (l$territoryRole != lOther$territoryRole) {
      return false;
    }
    final l$userTerritories = userTerritories;
    final lOther$userTerritories = other.userTerritories;
    if (_$data.containsKey('userTerritories') !=
        other._$data.containsKey('userTerritories')) {
      return false;
    }
    if (l$userTerritories != lOther$userTerritories) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$personVariables = personVariables;
    final l$section = section;
    final l$sectionID = sectionID;
    final l$suscriptionTerritories = suscriptionTerritories;
    final l$territoryGroupTerritories = territoryGroupTerritories;
    final l$territoryID = territoryID;
    final l$territoryRole = territoryRole;
    final l$userTerritories = userTerritories;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
      _$data.containsKey('section') ? l$section : const {},
      _$data.containsKey('sectionID') ? l$sectionID : const {},
      _$data.containsKey('suscriptionTerritories')
          ? l$suscriptionTerritories
          : const {},
      _$data.containsKey('territoryGroupTerritories')
          ? l$territoryGroupTerritories
          : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
      _$data.containsKey('territoryRole') ? l$territoryRole : const {},
      _$data.containsKey('userTerritories') ? l$userTerritories : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryFilterInput<TRes> {
  factory CopyWith$Input$TerritoryFilterInput(
    Input$TerritoryFilterInput instance,
    TRes Function(Input$TerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$TerritoryFilterInput;

  factory CopyWith$Input$TerritoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryFilterInput;

  TRes call({
    List<Input$TerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRole,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  });
  TRes and(
      Iterable<Input$TerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryFilterInput<
                      Input$TerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$TerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryFilterInput<
                      Input$TerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
  CopyWith$Input$SectionFilterInput<TRes> get section;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID;
  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories;
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRole;
  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories;
}

class _CopyWithImpl$Input$TerritoryFilterInput<TRes>
    implements CopyWith$Input$TerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$TerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryFilterInput _instance;

  final TRes Function(Input$TerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? personVariables = _undefined,
    Object? section = _undefined,
    Object? sectionID = _undefined,
    Object? suscriptionTerritories = _undefined,
    Object? territoryGroupTerritories = _undefined,
    Object? territoryID = _undefined,
    Object? territoryRole = _undefined,
    Object? userTerritories = _undefined,
  }) =>
      _then(Input$TerritoryFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$TerritoryFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined) 'or': (or as List<Input$TerritoryFilterInput>?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
        if (section != _undefined)
          'section': (section as Input$SectionFilterInput?),
        if (sectionID != _undefined)
          'sectionID':
              (sectionID as Input$ComparableInt64OperationFilterInput?),
        if (suscriptionTerritories != _undefined)
          'suscriptionTerritories': (suscriptionTerritories
              as Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?),
        if (territoryGroupTerritories != _undefined)
          'territoryGroupTerritories': (territoryGroupTerritories
              as Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
        if (territoryRole != _undefined)
          'territoryRole': (territoryRole
              as Input$ListFilterInputTypeOfTerritoryRoleFilterInput?),
        if (userTerritories != _undefined)
          'userTerritories': (userTerritories
              as Input$ListFilterInputTypeOfUserTerritoryFilterInput?),
      }));
  TRes and(
          Iterable<Input$TerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryFilterInput<
                          Input$TerritoryFilterInput>>?)
              _fn) =>
      call(
          and:
              _fn(_instance.and?.map((e) => CopyWith$Input$TerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$TerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryFilterInput<
                          Input$TerritoryFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map((e) => CopyWith$Input$TerritoryFilterInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }

  CopyWith$Input$SectionFilterInput<TRes> get section {
    final local$section = _instance.section;
    return local$section == null
        ? CopyWith$Input$SectionFilterInput.stub(_then(_instance))
        : CopyWith$Input$SectionFilterInput(
            local$section, (e) => call(section: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID {
    final local$sectionID = _instance.sectionID;
    return local$sectionID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$sectionID, (e) => call(sectionID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories {
    final local$suscriptionTerritories = _instance.suscriptionTerritories;
    return local$suscriptionTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
            local$suscriptionTerritories,
            (e) => call(suscriptionTerritories: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories {
    final local$territoryGroupTerritories = _instance.territoryGroupTerritories;
    return local$territoryGroupTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
            local$territoryGroupTerritories,
            (e) => call(territoryGroupTerritories: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRole {
    final local$territoryRole = _instance.territoryRole;
    return local$territoryRole == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput(
            local$territoryRole, (e) => call(territoryRole: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories {
    final local$userTerritories = _instance.userTerritories;
    return local$userTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput(
            local$userTerritories, (e) => call(userTerritories: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryFilterInput<TRes>
    implements CopyWith$Input$TerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryFilterInput>? or,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ListFilterInputTypeOfTerritoryRoleFilterInput? territoryRole,
    Input$ListFilterInputTypeOfUserTerritoryFilterInput? userTerritories,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
  CopyWith$Input$SectionFilterInput<TRes> get section =>
      CopyWith$Input$SectionFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories =>
          CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput
              .stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
              .stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput<TRes>
      get territoryRole =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryRoleFilterInput.stub(
              _res);
  CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput<TRes>
      get userTerritories =>
          CopyWith$Input$ListFilterInputTypeOfUserTerritoryFilterInput.stub(
              _res);
}

class Input$TerritoryGroupFilterInput {
  factory Input$TerritoryGroupFilterInput({
    List<Input$TerritoryGroupFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryGroupFilterInput>? or,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
  }) =>
      Input$TerritoryGroupFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (section != null) r'section': section,
        if (sectionID != null) r'sectionID': sectionID,
        if (territoryGroupID != null) r'territoryGroupID': territoryGroupID,
        if (territoryGroupRoles != null)
          r'territoryGroupRoles': territoryGroupRoles,
        if (territoryGroupTerritories != null)
          r'territoryGroupTerritories': territoryGroupTerritories,
      });

  Input$TerritoryGroupFilterInput._(this._$data);

  factory Input$TerritoryGroupFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('section')) {
      final l$section = data['section'];
      result$data['section'] = l$section == null
          ? null
          : Input$SectionFilterInput.fromJson(
              (l$section as Map<String, dynamic>));
    }
    if (data.containsKey('sectionID')) {
      final l$sectionID = data['sectionID'];
      result$data['sectionID'] = l$sectionID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$sectionID as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = data['territoryGroupID'];
      result$data['territoryGroupID'] = l$territoryGroupID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupRoles')) {
      final l$territoryGroupRoles = data['territoryGroupRoles'];
      result$data['territoryGroupRoles'] = l$territoryGroupRoles == null
          ? null
          : Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput.fromJson(
              (l$territoryGroupRoles as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupTerritories')) {
      final l$territoryGroupTerritories = data['territoryGroupTerritories'];
      result$data['territoryGroupTerritories'] = l$territoryGroupTerritories ==
              null
          ? null
          : Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
              .fromJson((l$territoryGroupTerritories as Map<String, dynamic>));
    }
    return Input$TerritoryGroupFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TerritoryGroupFilterInput>? get and =>
      (_$data['and'] as List<Input$TerritoryGroupFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$TerritoryGroupFilterInput>? get or =>
      (_$data['or'] as List<Input$TerritoryGroupFilterInput>?);
  Input$SectionFilterInput? get section =>
      (_$data['section'] as Input$SectionFilterInput?);
  Input$ComparableInt64OperationFilterInput? get sectionID =>
      (_$data['sectionID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryGroupID =>
      (_$data['territoryGroupID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
      get territoryGroupRoles => (_$data['territoryGroupRoles']
          as Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?);
  Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
      get territoryGroupTerritories => (_$data['territoryGroupTerritories']
          as Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('section')) {
      final l$section = section;
      result$data['section'] = l$section?.toJson();
    }
    if (_$data.containsKey('sectionID')) {
      final l$sectionID = sectionID;
      result$data['sectionID'] = l$sectionID?.toJson();
    }
    if (_$data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = territoryGroupID;
      result$data['territoryGroupID'] = l$territoryGroupID?.toJson();
    }
    if (_$data.containsKey('territoryGroupRoles')) {
      final l$territoryGroupRoles = territoryGroupRoles;
      result$data['territoryGroupRoles'] = l$territoryGroupRoles?.toJson();
    }
    if (_$data.containsKey('territoryGroupTerritories')) {
      final l$territoryGroupTerritories = territoryGroupTerritories;
      result$data['territoryGroupTerritories'] =
          l$territoryGroupTerritories?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TerritoryGroupFilterInput<Input$TerritoryGroupFilterInput>
      get copyWith => CopyWith$Input$TerritoryGroupFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryGroupFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$section = section;
    final lOther$section = other.section;
    if (_$data.containsKey('section') != other._$data.containsKey('section')) {
      return false;
    }
    if (l$section != lOther$section) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (_$data.containsKey('sectionID') !=
        other._$data.containsKey('sectionID')) {
      return false;
    }
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    final l$territoryGroupID = territoryGroupID;
    final lOther$territoryGroupID = other.territoryGroupID;
    if (_$data.containsKey('territoryGroupID') !=
        other._$data.containsKey('territoryGroupID')) {
      return false;
    }
    if (l$territoryGroupID != lOther$territoryGroupID) {
      return false;
    }
    final l$territoryGroupRoles = territoryGroupRoles;
    final lOther$territoryGroupRoles = other.territoryGroupRoles;
    if (_$data.containsKey('territoryGroupRoles') !=
        other._$data.containsKey('territoryGroupRoles')) {
      return false;
    }
    if (l$territoryGroupRoles != lOther$territoryGroupRoles) {
      return false;
    }
    final l$territoryGroupTerritories = territoryGroupTerritories;
    final lOther$territoryGroupTerritories = other.territoryGroupTerritories;
    if (_$data.containsKey('territoryGroupTerritories') !=
        other._$data.containsKey('territoryGroupTerritories')) {
      return false;
    }
    if (l$territoryGroupTerritories != lOther$territoryGroupTerritories) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$section = section;
    final l$sectionID = sectionID;
    final l$territoryGroupID = territoryGroupID;
    final l$territoryGroupRoles = territoryGroupRoles;
    final l$territoryGroupTerritories = territoryGroupTerritories;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('section') ? l$section : const {},
      _$data.containsKey('sectionID') ? l$sectionID : const {},
      _$data.containsKey('territoryGroupID') ? l$territoryGroupID : const {},
      _$data.containsKey('territoryGroupRoles')
          ? l$territoryGroupRoles
          : const {},
      _$data.containsKey('territoryGroupTerritories')
          ? l$territoryGroupTerritories
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryGroupFilterInput<TRes> {
  factory CopyWith$Input$TerritoryGroupFilterInput(
    Input$TerritoryGroupFilterInput instance,
    TRes Function(Input$TerritoryGroupFilterInput) then,
  ) = _CopyWithImpl$Input$TerritoryGroupFilterInput;

  factory CopyWith$Input$TerritoryGroupFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryGroupFilterInput;

  TRes call({
    List<Input$TerritoryGroupFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryGroupFilterInput>? or,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
  });
  TRes and(
      Iterable<Input$TerritoryGroupFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupFilterInput<
                      Input$TerritoryGroupFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$TerritoryGroupFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupFilterInput<
                      Input$TerritoryGroupFilterInput>>?)
          _fn);
  CopyWith$Input$SectionFilterInput<TRes> get section;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryGroupID;
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles;
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories;
}

class _CopyWithImpl$Input$TerritoryGroupFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupFilterInput<TRes> {
  _CopyWithImpl$Input$TerritoryGroupFilterInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryGroupFilterInput _instance;

  final TRes Function(Input$TerritoryGroupFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? section = _undefined,
    Object? sectionID = _undefined,
    Object? territoryGroupID = _undefined,
    Object? territoryGroupRoles = _undefined,
    Object? territoryGroupTerritories = _undefined,
  }) =>
      _then(Input$TerritoryGroupFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$TerritoryGroupFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$TerritoryGroupFilterInput>?),
        if (section != _undefined)
          'section': (section as Input$SectionFilterInput?),
        if (sectionID != _undefined)
          'sectionID':
              (sectionID as Input$ComparableInt64OperationFilterInput?),
        if (territoryGroupID != _undefined)
          'territoryGroupID':
              (territoryGroupID as Input$ComparableInt64OperationFilterInput?),
        if (territoryGroupRoles != _undefined)
          'territoryGroupRoles': (territoryGroupRoles
              as Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?),
        if (territoryGroupTerritories != _undefined)
          'territoryGroupTerritories': (territoryGroupTerritories
              as Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?),
      }));
  TRes and(
          Iterable<Input$TerritoryGroupFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupFilterInput<
                          Input$TerritoryGroupFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$TerritoryGroupFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$TerritoryGroupFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupFilterInput<
                          Input$TerritoryGroupFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$TerritoryGroupFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$SectionFilterInput<TRes> get section {
    final local$section = _instance.section;
    return local$section == null
        ? CopyWith$Input$SectionFilterInput.stub(_then(_instance))
        : CopyWith$Input$SectionFilterInput(
            local$section, (e) => call(section: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID {
    final local$sectionID = _instance.sectionID;
    return local$sectionID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$sectionID, (e) => call(sectionID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID {
    final local$territoryGroupID = _instance.territoryGroupID;
    return local$territoryGroupID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryGroupID, (e) => call(territoryGroupID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles {
    final local$territoryGroupRoles = _instance.territoryGroupRoles;
    return local$territoryGroupRoles == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput(
            local$territoryGroupRoles, (e) => call(territoryGroupRoles: e));
  }

  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories {
    final local$territoryGroupTerritories = _instance.territoryGroupTerritories;
    return local$territoryGroupTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput(
            local$territoryGroupTerritories,
            (e) => call(territoryGroupTerritories: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryGroupFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupFilterInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryGroupFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TerritoryGroupFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$TerritoryGroupFilterInput>? or,
    Input$SectionFilterInput? section,
    Input$ComparableInt64OperationFilterInput? sectionID,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput?
        territoryGroupRoles,
    Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput?
        territoryGroupTerritories,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$SectionFilterInput<TRes> get section =>
      CopyWith$Input$SectionFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get sectionID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput<TRes>
      get territoryGroupRoles =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupRoleFilterInput
              .stub(_res);
  CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput<TRes>
      get territoryGroupTerritories =>
          CopyWith$Input$ListFilterInputTypeOfTerritoryGroupTerritoryFilterInput
              .stub(_res);
}

class Input$TerritoryGroupRoleFilterInput {
  factory Input$TerritoryGroupRoleFilterInput({
    List<Input$TerritoryGroupRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
  }) =>
      Input$TerritoryGroupRoleFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (role != null) r'role': role,
        if (roleID != null) r'roleID': roleID,
        if (territoryGroup != null) r'territoryGroup': territoryGroup,
        if (territoryGroupID != null) r'territoryGroupID': territoryGroupID,
      });

  Input$TerritoryGroupRoleFilterInput._(this._$data);

  factory Input$TerritoryGroupRoleFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleID')) {
      final l$roleID = data['roleID'];
      result$data['roleID'] = l$roleID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$roleID as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroup')) {
      final l$territoryGroup = data['territoryGroup'];
      result$data['territoryGroup'] = l$territoryGroup == null
          ? null
          : Input$TerritoryGroupFilterInput.fromJson(
              (l$territoryGroup as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = data['territoryGroupID'];
      result$data['territoryGroupID'] = l$territoryGroupID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryGroupID as Map<String, dynamic>));
    }
    return Input$TerritoryGroupRoleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TerritoryGroupRoleFilterInput>? get and =>
      (_$data['and'] as List<Input$TerritoryGroupRoleFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$TerritoryGroupRoleFilterInput>? get or =>
      (_$data['or'] as List<Input$TerritoryGroupRoleFilterInput>?);
  Input$ApplicationRoleFilterInput? get role =>
      (_$data['role'] as Input$ApplicationRoleFilterInput?);
  Input$StringOperationFilterInput? get roleID =>
      (_$data['roleID'] as Input$StringOperationFilterInput?);
  Input$TerritoryGroupFilterInput? get territoryGroup =>
      (_$data['territoryGroup'] as Input$TerritoryGroupFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryGroupID =>
      (_$data['territoryGroupID']
          as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleID')) {
      final l$roleID = roleID;
      result$data['roleID'] = l$roleID?.toJson();
    }
    if (_$data.containsKey('territoryGroup')) {
      final l$territoryGroup = territoryGroup;
      result$data['territoryGroup'] = l$territoryGroup?.toJson();
    }
    if (_$data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = territoryGroupID;
      result$data['territoryGroupID'] = l$territoryGroupID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TerritoryGroupRoleFilterInput<
          Input$TerritoryGroupRoleFilterInput>
      get copyWith => CopyWith$Input$TerritoryGroupRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryGroupRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (_$data.containsKey('roleID') != other._$data.containsKey('roleID')) {
      return false;
    }
    if (l$roleID != lOther$roleID) {
      return false;
    }
    final l$territoryGroup = territoryGroup;
    final lOther$territoryGroup = other.territoryGroup;
    if (_$data.containsKey('territoryGroup') !=
        other._$data.containsKey('territoryGroup')) {
      return false;
    }
    if (l$territoryGroup != lOther$territoryGroup) {
      return false;
    }
    final l$territoryGroupID = territoryGroupID;
    final lOther$territoryGroupID = other.territoryGroupID;
    if (_$data.containsKey('territoryGroupID') !=
        other._$data.containsKey('territoryGroupID')) {
      return false;
    }
    if (l$territoryGroupID != lOther$territoryGroupID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$role = role;
    final l$roleID = roleID;
    final l$territoryGroup = territoryGroup;
    final l$territoryGroupID = territoryGroupID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleID') ? l$roleID : const {},
      _$data.containsKey('territoryGroup') ? l$territoryGroup : const {},
      _$data.containsKey('territoryGroupID') ? l$territoryGroupID : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> {
  factory CopyWith$Input$TerritoryGroupRoleFilterInput(
    Input$TerritoryGroupRoleFilterInput instance,
    TRes Function(Input$TerritoryGroupRoleFilterInput) then,
  ) = _CopyWithImpl$Input$TerritoryGroupRoleFilterInput;

  factory CopyWith$Input$TerritoryGroupRoleFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryGroupRoleFilterInput;

  TRes call({
    List<Input$TerritoryGroupRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
  });
  TRes and(
      Iterable<Input$TerritoryGroupRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupRoleFilterInput<
                      Input$TerritoryGroupRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$TerritoryGroupRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupRoleFilterInput<
                      Input$TerritoryGroupRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role;
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID;
  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryGroupID;
}

class _CopyWithImpl$Input$TerritoryGroupRoleFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> {
  _CopyWithImpl$Input$TerritoryGroupRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryGroupRoleFilterInput _instance;

  final TRes Function(Input$TerritoryGroupRoleFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? role = _undefined,
    Object? roleID = _undefined,
    Object? territoryGroup = _undefined,
    Object? territoryGroupID = _undefined,
  }) =>
      _then(Input$TerritoryGroupRoleFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$TerritoryGroupRoleFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$TerritoryGroupRoleFilterInput>?),
        if (role != _undefined)
          'role': (role as Input$ApplicationRoleFilterInput?),
        if (roleID != _undefined)
          'roleID': (roleID as Input$StringOperationFilterInput?),
        if (territoryGroup != _undefined)
          'territoryGroup':
              (territoryGroup as Input$TerritoryGroupFilterInput?),
        if (territoryGroupID != _undefined)
          'territoryGroupID':
              (territoryGroupID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$TerritoryGroupRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupRoleFilterInput<
                          Input$TerritoryGroupRoleFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$TerritoryGroupRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$TerritoryGroupRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupRoleFilterInput<
                          Input$TerritoryGroupRoleFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$TerritoryGroupRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get roleID {
    final local$roleID = _instance.roleID;
    return local$roleID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$roleID, (e) => call(roleID: e));
  }

  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup {
    final local$territoryGroup = _instance.territoryGroup;
    return local$territoryGroup == null
        ? CopyWith$Input$TerritoryGroupFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryGroupFilterInput(
            local$territoryGroup, (e) => call(territoryGroup: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID {
    final local$territoryGroupID = _instance.territoryGroupID;
    return local$territoryGroupID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryGroupID, (e) => call(territoryGroupID: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryGroupRoleFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupRoleFilterInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryGroupRoleFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TerritoryGroupRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup =>
      CopyWith$Input$TerritoryGroupFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$TerritoryGroupTerritoryFilterInput {
  factory Input$TerritoryGroupTerritoryFilterInput({
    List<Input$TerritoryGroupTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ComparableInt64OperationFilterInput? territoryID,
  }) =>
      Input$TerritoryGroupTerritoryFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (territory != null) r'territory': territory,
        if (territoryGroup != null) r'territoryGroup': territoryGroup,
        if (territoryGroupID != null) r'territoryGroupID': territoryGroupID,
        if (territoryID != null) r'territoryID': territoryID,
      });

  Input$TerritoryGroupTerritoryFilterInput._(this._$data);

  factory Input$TerritoryGroupTerritoryFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TerritoryGroupTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroup')) {
      final l$territoryGroup = data['territoryGroup'];
      result$data['territoryGroup'] = l$territoryGroup == null
          ? null
          : Input$TerritoryGroupFilterInput.fromJson(
              (l$territoryGroup as Map<String, dynamic>));
    }
    if (data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = data['territoryGroupID'];
      result$data['territoryGroupID'] = l$territoryGroupID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    return Input$TerritoryGroupTerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TerritoryGroupTerritoryFilterInput>? get and =>
      (_$data['and'] as List<Input$TerritoryGroupTerritoryFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$TerritoryGroupTerritoryFilterInput>? get or =>
      (_$data['or'] as List<Input$TerritoryGroupTerritoryFilterInput>?);
  Input$TerritoryFilterInput? get territory =>
      (_$data['territory'] as Input$TerritoryFilterInput?);
  Input$TerritoryGroupFilterInput? get territoryGroup =>
      (_$data['territoryGroup'] as Input$TerritoryGroupFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryGroupID =>
      (_$data['territoryGroupID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryGroup')) {
      final l$territoryGroup = territoryGroup;
      result$data['territoryGroup'] = l$territoryGroup?.toJson();
    }
    if (_$data.containsKey('territoryGroupID')) {
      final l$territoryGroupID = territoryGroupID;
      result$data['territoryGroupID'] = l$territoryGroupID?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TerritoryGroupTerritoryFilterInput<
          Input$TerritoryGroupTerritoryFilterInput>
      get copyWith => CopyWith$Input$TerritoryGroupTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryGroupTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryGroup = territoryGroup;
    final lOther$territoryGroup = other.territoryGroup;
    if (_$data.containsKey('territoryGroup') !=
        other._$data.containsKey('territoryGroup')) {
      return false;
    }
    if (l$territoryGroup != lOther$territoryGroup) {
      return false;
    }
    final l$territoryGroupID = territoryGroupID;
    final lOther$territoryGroupID = other.territoryGroupID;
    if (_$data.containsKey('territoryGroupID') !=
        other._$data.containsKey('territoryGroupID')) {
      return false;
    }
    if (l$territoryGroupID != lOther$territoryGroupID) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$territory = territory;
    final l$territoryGroup = territoryGroup;
    final l$territoryGroupID = territoryGroupID;
    final l$territoryID = territoryID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryGroup') ? l$territoryGroup : const {},
      _$data.containsKey('territoryGroupID') ? l$territoryGroupID : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> {
  factory CopyWith$Input$TerritoryGroupTerritoryFilterInput(
    Input$TerritoryGroupTerritoryFilterInput instance,
    TRes Function(Input$TerritoryGroupTerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$TerritoryGroupTerritoryFilterInput;

  factory CopyWith$Input$TerritoryGroupTerritoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryGroupTerritoryFilterInput;

  TRes call({
    List<Input$TerritoryGroupTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ComparableInt64OperationFilterInput? territoryID,
  });
  TRes and(
      Iterable<Input$TerritoryGroupTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupTerritoryFilterInput<
                      Input$TerritoryGroupTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$TerritoryGroupTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryGroupTerritoryFilterInput<
                      Input$TerritoryGroupTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$TerritoryFilterInput<TRes> get territory;
  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryGroupID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
}

class _CopyWithImpl$Input$TerritoryGroupTerritoryFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$TerritoryGroupTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryGroupTerritoryFilterInput _instance;

  final TRes Function(Input$TerritoryGroupTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? territory = _undefined,
    Object? territoryGroup = _undefined,
    Object? territoryGroupID = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$TerritoryGroupTerritoryFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$TerritoryGroupTerritoryFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$TerritoryGroupTerritoryFilterInput>?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritoryFilterInput?),
        if (territoryGroup != _undefined)
          'territoryGroup':
              (territoryGroup as Input$TerritoryGroupFilterInput?),
        if (territoryGroupID != _undefined)
          'territoryGroupID':
              (territoryGroupID as Input$ComparableInt64OperationFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$TerritoryGroupTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupTerritoryFilterInput<
                          Input$TerritoryGroupTerritoryFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$TerritoryGroupTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$TerritoryGroupTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryGroupTerritoryFilterInput<
                          Input$TerritoryGroupTerritoryFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$TerritoryGroupTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$TerritoryFilterInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup {
    final local$territoryGroup = _instance.territoryGroup;
    return local$territoryGroup == null
        ? CopyWith$Input$TerritoryGroupFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryGroupFilterInput(
            local$territoryGroup, (e) => call(territoryGroup: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID {
    final local$territoryGroupID = _instance.territoryGroupID;
    return local$territoryGroupID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryGroupID, (e) => call(territoryGroupID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryGroupTerritoryFilterInput<TRes>
    implements CopyWith$Input$TerritoryGroupTerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryGroupTerritoryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TerritoryGroupTerritoryFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryGroupTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$TerritoryGroupFilterInput? territoryGroup,
    Input$ComparableInt64OperationFilterInput? territoryGroupID,
    Input$ComparableInt64OperationFilterInput? territoryID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$TerritoryFilterInput<TRes> get territory =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$TerritoryGroupFilterInput<TRes> get territoryGroup =>
      CopyWith$Input$TerritoryGroupFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get territoryGroupID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$TerritoryRoleFilterInput {
  factory Input$TerritoryRoleFilterInput({
    List<Input$TerritoryRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
  }) =>
      Input$TerritoryRoleFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (role != null) r'role': role,
        if (roleID != null) r'roleID': roleID,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
      });

  Input$TerritoryRoleFilterInput._(this._$data);

  factory Input$TerritoryRoleFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$TerritoryRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$TerritoryRoleFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ApplicationRoleFilterInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleID')) {
      final l$roleID = data['roleID'];
      result$data['roleID'] = l$roleID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$roleID as Map<String, dynamic>));
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    return Input$TerritoryRoleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TerritoryRoleFilterInput>? get and =>
      (_$data['and'] as List<Input$TerritoryRoleFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$TerritoryRoleFilterInput>? get or =>
      (_$data['or'] as List<Input$TerritoryRoleFilterInput>?);
  Input$ApplicationRoleFilterInput? get role =>
      (_$data['role'] as Input$ApplicationRoleFilterInput?);
  Input$StringOperationFilterInput? get roleID =>
      (_$data['roleID'] as Input$StringOperationFilterInput?);
  Input$TerritoryFilterInput? get territory =>
      (_$data['territory'] as Input$TerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleID')) {
      final l$roleID = roleID;
      result$data['roleID'] = l$roleID?.toJson();
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TerritoryRoleFilterInput<Input$TerritoryRoleFilterInput>
      get copyWith => CopyWith$Input$TerritoryRoleFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryRoleFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (_$data.containsKey('roleID') != other._$data.containsKey('roleID')) {
      return false;
    }
    if (l$roleID != lOther$roleID) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$role = role;
    final l$roleID = roleID;
    final l$territory = territory;
    final l$territoryID = territoryID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleID') ? l$roleID : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryRoleFilterInput<TRes> {
  factory CopyWith$Input$TerritoryRoleFilterInput(
    Input$TerritoryRoleFilterInput instance,
    TRes Function(Input$TerritoryRoleFilterInput) then,
  ) = _CopyWithImpl$Input$TerritoryRoleFilterInput;

  factory CopyWith$Input$TerritoryRoleFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryRoleFilterInput;

  TRes call({
    List<Input$TerritoryRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
  });
  TRes and(
      Iterable<Input$TerritoryRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryRoleFilterInput<
                      Input$TerritoryRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$TerritoryRoleFilterInput>? Function(
              Iterable<
                  CopyWith$Input$TerritoryRoleFilterInput<
                      Input$TerritoryRoleFilterInput>>?)
          _fn);
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role;
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID;
  CopyWith$Input$TerritoryFilterInput<TRes> get territory;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
}

class _CopyWithImpl$Input$TerritoryRoleFilterInput<TRes>
    implements CopyWith$Input$TerritoryRoleFilterInput<TRes> {
  _CopyWithImpl$Input$TerritoryRoleFilterInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryRoleFilterInput _instance;

  final TRes Function(Input$TerritoryRoleFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? role = _undefined,
    Object? roleID = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$TerritoryRoleFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$TerritoryRoleFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$TerritoryRoleFilterInput>?),
        if (role != _undefined)
          'role': (role as Input$ApplicationRoleFilterInput?),
        if (roleID != _undefined)
          'roleID': (roleID as Input$StringOperationFilterInput?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritoryFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$TerritoryRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryRoleFilterInput<
                          Input$TerritoryRoleFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$TerritoryRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$TerritoryRoleFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$TerritoryRoleFilterInput<
                          Input$TerritoryRoleFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$TerritoryRoleFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ApplicationRoleFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleFilterInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get roleID {
    final local$roleID = _instance.roleID;
    return local$roleID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$roleID, (e) => call(roleID: e));
  }

  CopyWith$Input$TerritoryFilterInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryRoleFilterInput<TRes>
    implements CopyWith$Input$TerritoryRoleFilterInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryRoleFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TerritoryRoleFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$TerritoryRoleFilterInput>? or,
    Input$ApplicationRoleFilterInput? role,
    Input$StringOperationFilterInput? roleID,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ApplicationRoleFilterInput<TRes> get role =>
      CopyWith$Input$ApplicationRoleFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get roleID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$TerritoryFilterInput<TRes> get territory =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$TerritoryRoleSortInput {
  factory Input$TerritoryRoleSortInput({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
  }) =>
      Input$TerritoryRoleSortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (role != null) r'role': role,
        if (roleID != null) r'roleID': roleID,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
      });

  Input$TerritoryRoleSortInput._(this._$data);

  factory Input$TerritoryRoleSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ApplicationRoleSortInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleID')) {
      final l$roleID = data['roleID'];
      result$data['roleID'] = l$roleID == null
          ? null
          : fromJson$Enum$SortEnumType((l$roleID as String));
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritorySortInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : fromJson$Enum$SortEnumType((l$territoryID as String));
    }
    return Input$TerritoryRoleSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Input$ApplicationRoleSortInput? get role =>
      (_$data['role'] as Input$ApplicationRoleSortInput?);
  Enum$SortEnumType? get roleID => (_$data['roleID'] as Enum$SortEnumType?);
  Input$TerritorySortInput? get territory =>
      (_$data['territory'] as Input$TerritorySortInput?);
  Enum$SortEnumType? get territoryID =>
      (_$data['territoryID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleID')) {
      final l$roleID = roleID;
      result$data['roleID'] =
          l$roleID == null ? null : toJson$Enum$SortEnumType(l$roleID);
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID == null
          ? null
          : toJson$Enum$SortEnumType(l$territoryID);
    }
    return result$data;
  }

  CopyWith$Input$TerritoryRoleSortInput<Input$TerritoryRoleSortInput>
      get copyWith => CopyWith$Input$TerritoryRoleSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritoryRoleSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleID = roleID;
    final lOther$roleID = other.roleID;
    if (_$data.containsKey('roleID') != other._$data.containsKey('roleID')) {
      return false;
    }
    if (l$roleID != lOther$roleID) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$role = role;
    final l$roleID = roleID;
    final l$territory = territory;
    final l$territoryID = territoryID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleID') ? l$roleID : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritoryRoleSortInput<TRes> {
  factory CopyWith$Input$TerritoryRoleSortInput(
    Input$TerritoryRoleSortInput instance,
    TRes Function(Input$TerritoryRoleSortInput) then,
  ) = _CopyWithImpl$Input$TerritoryRoleSortInput;

  factory CopyWith$Input$TerritoryRoleSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritoryRoleSortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
  });
  CopyWith$Input$ApplicationRoleSortInput<TRes> get role;
  CopyWith$Input$TerritorySortInput<TRes> get territory;
}

class _CopyWithImpl$Input$TerritoryRoleSortInput<TRes>
    implements CopyWith$Input$TerritoryRoleSortInput<TRes> {
  _CopyWithImpl$Input$TerritoryRoleSortInput(
    this._instance,
    this._then,
  );

  final Input$TerritoryRoleSortInput _instance;

  final TRes Function(Input$TerritoryRoleSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? role = _undefined,
    Object? roleID = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$TerritoryRoleSortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (role != _undefined)
          'role': (role as Input$ApplicationRoleSortInput?),
        if (roleID != _undefined) 'roleID': (roleID as Enum$SortEnumType?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritorySortInput?),
        if (territoryID != _undefined)
          'territoryID': (territoryID as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationRoleSortInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ApplicationRoleSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationRoleSortInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$TerritorySortInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritorySortInput.stub(_then(_instance))
        : CopyWith$Input$TerritorySortInput(
            local$territory, (e) => call(territory: e));
  }
}

class _CopyWithStubImpl$Input$TerritoryRoleSortInput<TRes>
    implements CopyWith$Input$TerritoryRoleSortInput<TRes> {
  _CopyWithStubImpl$Input$TerritoryRoleSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$ApplicationRoleSortInput? role,
    Enum$SortEnumType? roleID,
    Input$TerritorySortInput? territory,
    Enum$SortEnumType? territoryID,
  }) =>
      _res;
  CopyWith$Input$ApplicationRoleSortInput<TRes> get role =>
      CopyWith$Input$ApplicationRoleSortInput.stub(_res);
  CopyWith$Input$TerritorySortInput<TRes> get territory =>
      CopyWith$Input$TerritorySortInput.stub(_res);
}

class Input$TerritorySortInput {
  factory Input$TerritorySortInput({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Input$SectionSortInput? section,
    Enum$SortEnumType? sectionID,
    Enum$SortEnumType? territoryID,
  }) =>
      Input$TerritorySortInput._({
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (section != null) r'section': section,
        if (sectionID != null) r'sectionID': sectionID,
        if (territoryID != null) r'territoryID': territoryID,
      });

  Input$TerritorySortInput._(this._$data);

  factory Input$TerritorySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('section')) {
      final l$section = data['section'];
      result$data['section'] = l$section == null
          ? null
          : Input$SectionSortInput.fromJson(
              (l$section as Map<String, dynamic>));
    }
    if (data.containsKey('sectionID')) {
      final l$sectionID = data['sectionID'];
      result$data['sectionID'] = l$sectionID == null
          ? null
          : fromJson$Enum$SortEnumType((l$sectionID as String));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : fromJson$Enum$SortEnumType((l$territoryID as String));
    }
    return Input$TerritorySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Input$SectionSortInput? get section =>
      (_$data['section'] as Input$SectionSortInput?);
  Enum$SortEnumType? get sectionID =>
      (_$data['sectionID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get territoryID =>
      (_$data['territoryID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('section')) {
      final l$section = section;
      result$data['section'] = l$section?.toJson();
    }
    if (_$data.containsKey('sectionID')) {
      final l$sectionID = sectionID;
      result$data['sectionID'] =
          l$sectionID == null ? null : toJson$Enum$SortEnumType(l$sectionID);
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID == null
          ? null
          : toJson$Enum$SortEnumType(l$territoryID);
    }
    return result$data;
  }

  CopyWith$Input$TerritorySortInput<Input$TerritorySortInput> get copyWith =>
      CopyWith$Input$TerritorySortInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerritorySortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$section = section;
    final lOther$section = other.section;
    if (_$data.containsKey('section') != other._$data.containsKey('section')) {
      return false;
    }
    if (l$section != lOther$section) {
      return false;
    }
    final l$sectionID = sectionID;
    final lOther$sectionID = other.sectionID;
    if (_$data.containsKey('sectionID') !=
        other._$data.containsKey('sectionID')) {
      return false;
    }
    if (l$sectionID != lOther$sectionID) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$section = section;
    final l$sectionID = sectionID;
    final l$territoryID = territoryID;
    return Object.hashAll([
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('section') ? l$section : const {},
      _$data.containsKey('sectionID') ? l$sectionID : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerritorySortInput<TRes> {
  factory CopyWith$Input$TerritorySortInput(
    Input$TerritorySortInput instance,
    TRes Function(Input$TerritorySortInput) then,
  ) = _CopyWithImpl$Input$TerritorySortInput;

  factory CopyWith$Input$TerritorySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerritorySortInput;

  TRes call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Input$SectionSortInput? section,
    Enum$SortEnumType? sectionID,
    Enum$SortEnumType? territoryID,
  });
  CopyWith$Input$SectionSortInput<TRes> get section;
}

class _CopyWithImpl$Input$TerritorySortInput<TRes>
    implements CopyWith$Input$TerritorySortInput<TRes> {
  _CopyWithImpl$Input$TerritorySortInput(
    this._instance,
    this._then,
  );

  final Input$TerritorySortInput _instance;

  final TRes Function(Input$TerritorySortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? section = _undefined,
    Object? sectionID = _undefined,
    Object? territoryID = _undefined,
  }) =>
      _then(Input$TerritorySortInput._({
        ..._instance._$data,
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (section != _undefined)
          'section': (section as Input$SectionSortInput?),
        if (sectionID != _undefined)
          'sectionID': (sectionID as Enum$SortEnumType?),
        if (territoryID != _undefined)
          'territoryID': (territoryID as Enum$SortEnumType?),
      }));
  CopyWith$Input$SectionSortInput<TRes> get section {
    final local$section = _instance.section;
    return local$section == null
        ? CopyWith$Input$SectionSortInput.stub(_then(_instance))
        : CopyWith$Input$SectionSortInput(
            local$section, (e) => call(section: e));
  }
}

class _CopyWithStubImpl$Input$TerritorySortInput<TRes>
    implements CopyWith$Input$TerritorySortInput<TRes> {
  _CopyWithStubImpl$Input$TerritorySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Input$SectionSortInput? section,
    Enum$SortEnumType? sectionID,
    Enum$SortEnumType? territoryID,
  }) =>
      _res;
  CopyWith$Input$SectionSortInput<TRes> get section =>
      CopyWith$Input$SectionSortInput.stub(_res);
}

class Input$UserPersonMarkerFilterInput {
  factory Input$UserPersonMarkerFilterInput({
    List<Input$UserPersonMarkerFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? endMarkerTime,
    Input$ApplicationUserFilterInput? endUser,
    Input$StringOperationFilterInput? endUserID,
    Input$MarkerTypeFilterInput? markerType,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$ComparableDateTimeOperationFilterInput? startMarkerTime,
    Input$ApplicationUserFilterInput? startUser,
    Input$StringOperationFilterInput? startUserID,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
  }) =>
      Input$UserPersonMarkerFilterInput._({
        if (and != null) r'and': and,
        if (application != null) r'application': application,
        if (applicationID != null) r'applicationID': applicationID,
        if (endMarkerTime != null) r'endMarkerTime': endMarkerTime,
        if (endUser != null) r'endUser': endUser,
        if (endUserID != null) r'endUserID': endUserID,
        if (markerType != null) r'markerType': markerType,
        if (markerTypeID != null) r'markerTypeID': markerTypeID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (person != null) r'person': person,
        if (personID != null) r'personID': personID,
        if (startMarkerTime != null) r'startMarkerTime': startMarkerTime,
        if (startUser != null) r'startUser': startUser,
        if (startUserID != null) r'startUserID': startUserID,
        if (userPersonMarkerID != null)
          r'userPersonMarkerID': userPersonMarkerID,
        if (userPersonMarkerPersonVariables != null)
          r'userPersonMarkerPersonVariables': userPersonMarkerPersonVariables,
      });

  Input$UserPersonMarkerFilterInput._(this._$data);

  factory Input$UserPersonMarkerFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserPersonMarkerFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$applicationID as Map<String, dynamic>));
    }
    if (data.containsKey('endMarkerTime')) {
      final l$endMarkerTime = data['endMarkerTime'];
      result$data['endMarkerTime'] = l$endMarkerTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$endMarkerTime as Map<String, dynamic>));
    }
    if (data.containsKey('endUser')) {
      final l$endUser = data['endUser'];
      result$data['endUser'] = l$endUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$endUser as Map<String, dynamic>));
    }
    if (data.containsKey('endUserID')) {
      final l$endUserID = data['endUserID'];
      result$data['endUserID'] = l$endUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$endUserID as Map<String, dynamic>));
    }
    if (data.containsKey('markerType')) {
      final l$markerType = data['markerType'];
      result$data['markerType'] = l$markerType == null
          ? null
          : Input$MarkerTypeFilterInput.fromJson(
              (l$markerType as Map<String, dynamic>));
    }
    if (data.containsKey('markerTypeID')) {
      final l$markerTypeID = data['markerTypeID'];
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$markerTypeID as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserPersonMarkerFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('person')) {
      final l$person = data['person'];
      result$data['person'] = l$person == null
          ? null
          : Input$PersonFilterInput.fromJson(
              (l$person as Map<String, dynamic>));
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$personID as Map<String, dynamic>));
    }
    if (data.containsKey('startMarkerTime')) {
      final l$startMarkerTime = data['startMarkerTime'];
      result$data['startMarkerTime'] = l$startMarkerTime == null
          ? null
          : Input$ComparableDateTimeOperationFilterInput.fromJson(
              (l$startMarkerTime as Map<String, dynamic>));
    }
    if (data.containsKey('startUser')) {
      final l$startUser = data['startUser'];
      result$data['startUser'] = l$startUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$startUser as Map<String, dynamic>));
    }
    if (data.containsKey('startUserID')) {
      final l$startUserID = data['startUserID'];
      result$data['startUserID'] = l$startUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$startUserID as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = data['userPersonMarkerID'];
      result$data['userPersonMarkerID'] = l$userPersonMarkerID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$userPersonMarkerID as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkerPersonVariables')) {
      final l$userPersonMarkerPersonVariables =
          data['userPersonMarkerPersonVariables'];
      result$data[
          'userPersonMarkerPersonVariables'] = l$userPersonMarkerPersonVariables ==
              null
          ? null
          : Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
              .fromJson(
                  (l$userPersonMarkerPersonVariables as Map<String, dynamic>));
    }
    return Input$UserPersonMarkerFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserPersonMarkerFilterInput>? get and =>
      (_$data['and'] as List<Input$UserPersonMarkerFilterInput>?);
  Input$ApplicationFilterInput? get application =>
      (_$data['application'] as Input$ApplicationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get applicationID =>
      (_$data['applicationID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput? get endMarkerTime =>
      (_$data['endMarkerTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get endUser =>
      (_$data['endUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get endUserID =>
      (_$data['endUserID'] as Input$StringOperationFilterInput?);
  Input$MarkerTypeFilterInput? get markerType =>
      (_$data['markerType'] as Input$MarkerTypeFilterInput?);
  Input$ComparableInt64OperationFilterInput? get markerTypeID =>
      (_$data['markerTypeID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$UserPersonMarkerFilterInput>? get or =>
      (_$data['or'] as List<Input$UserPersonMarkerFilterInput>?);
  Input$PersonFilterInput? get person =>
      (_$data['person'] as Input$PersonFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get personID =>
      (_$data['personID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$ComparableDateTimeOperationFilterInput? get startMarkerTime =>
      (_$data['startMarkerTime']
          as Input$ComparableDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get startUser =>
      (_$data['startUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get startUserID =>
      (_$data['startUserID'] as Input$StringOperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get userPersonMarkerID =>
      (_$data['userPersonMarkerID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
      get userPersonMarkerPersonVariables => (_$data[
              'userPersonMarkerPersonVariables']
          as Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID?.toJson();
    }
    if (_$data.containsKey('endMarkerTime')) {
      final l$endMarkerTime = endMarkerTime;
      result$data['endMarkerTime'] = l$endMarkerTime?.toJson();
    }
    if (_$data.containsKey('endUser')) {
      final l$endUser = endUser;
      result$data['endUser'] = l$endUser?.toJson();
    }
    if (_$data.containsKey('endUserID')) {
      final l$endUserID = endUserID;
      result$data['endUserID'] = l$endUserID?.toJson();
    }
    if (_$data.containsKey('markerType')) {
      final l$markerType = markerType;
      result$data['markerType'] = l$markerType?.toJson();
    }
    if (_$data.containsKey('markerTypeID')) {
      final l$markerTypeID = markerTypeID;
      result$data['markerTypeID'] = l$markerTypeID?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('person')) {
      final l$person = person;
      result$data['person'] = l$person?.toJson();
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] = l$personID?.toJson();
    }
    if (_$data.containsKey('startMarkerTime')) {
      final l$startMarkerTime = startMarkerTime;
      result$data['startMarkerTime'] = l$startMarkerTime?.toJson();
    }
    if (_$data.containsKey('startUser')) {
      final l$startUser = startUser;
      result$data['startUser'] = l$startUser?.toJson();
    }
    if (_$data.containsKey('startUserID')) {
      final l$startUserID = startUserID;
      result$data['startUserID'] = l$startUserID?.toJson();
    }
    if (_$data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = userPersonMarkerID;
      result$data['userPersonMarkerID'] = l$userPersonMarkerID?.toJson();
    }
    if (_$data.containsKey('userPersonMarkerPersonVariables')) {
      final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
      result$data['userPersonMarkerPersonVariables'] =
          l$userPersonMarkerPersonVariables?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserPersonMarkerFilterInput<Input$UserPersonMarkerFilterInput>
      get copyWith => CopyWith$Input$UserPersonMarkerFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonMarkerFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$endMarkerTime = endMarkerTime;
    final lOther$endMarkerTime = other.endMarkerTime;
    if (_$data.containsKey('endMarkerTime') !=
        other._$data.containsKey('endMarkerTime')) {
      return false;
    }
    if (l$endMarkerTime != lOther$endMarkerTime) {
      return false;
    }
    final l$endUser = endUser;
    final lOther$endUser = other.endUser;
    if (_$data.containsKey('endUser') != other._$data.containsKey('endUser')) {
      return false;
    }
    if (l$endUser != lOther$endUser) {
      return false;
    }
    final l$endUserID = endUserID;
    final lOther$endUserID = other.endUserID;
    if (_$data.containsKey('endUserID') !=
        other._$data.containsKey('endUserID')) {
      return false;
    }
    if (l$endUserID != lOther$endUserID) {
      return false;
    }
    final l$markerType = markerType;
    final lOther$markerType = other.markerType;
    if (_$data.containsKey('markerType') !=
        other._$data.containsKey('markerType')) {
      return false;
    }
    if (l$markerType != lOther$markerType) {
      return false;
    }
    final l$markerTypeID = markerTypeID;
    final lOther$markerTypeID = other.markerTypeID;
    if (_$data.containsKey('markerTypeID') !=
        other._$data.containsKey('markerTypeID')) {
      return false;
    }
    if (l$markerTypeID != lOther$markerTypeID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$person = person;
    final lOther$person = other.person;
    if (_$data.containsKey('person') != other._$data.containsKey('person')) {
      return false;
    }
    if (l$person != lOther$person) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$startMarkerTime = startMarkerTime;
    final lOther$startMarkerTime = other.startMarkerTime;
    if (_$data.containsKey('startMarkerTime') !=
        other._$data.containsKey('startMarkerTime')) {
      return false;
    }
    if (l$startMarkerTime != lOther$startMarkerTime) {
      return false;
    }
    final l$startUser = startUser;
    final lOther$startUser = other.startUser;
    if (_$data.containsKey('startUser') !=
        other._$data.containsKey('startUser')) {
      return false;
    }
    if (l$startUser != lOther$startUser) {
      return false;
    }
    final l$startUserID = startUserID;
    final lOther$startUserID = other.startUserID;
    if (_$data.containsKey('startUserID') !=
        other._$data.containsKey('startUserID')) {
      return false;
    }
    if (l$startUserID != lOther$startUserID) {
      return false;
    }
    final l$userPersonMarkerID = userPersonMarkerID;
    final lOther$userPersonMarkerID = other.userPersonMarkerID;
    if (_$data.containsKey('userPersonMarkerID') !=
        other._$data.containsKey('userPersonMarkerID')) {
      return false;
    }
    if (l$userPersonMarkerID != lOther$userPersonMarkerID) {
      return false;
    }
    final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
    final lOther$userPersonMarkerPersonVariables =
        other.userPersonMarkerPersonVariables;
    if (_$data.containsKey('userPersonMarkerPersonVariables') !=
        other._$data.containsKey('userPersonMarkerPersonVariables')) {
      return false;
    }
    if (l$userPersonMarkerPersonVariables !=
        lOther$userPersonMarkerPersonVariables) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$application = application;
    final l$applicationID = applicationID;
    final l$endMarkerTime = endMarkerTime;
    final l$endUser = endUser;
    final l$endUserID = endUserID;
    final l$markerType = markerType;
    final l$markerTypeID = markerTypeID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$person = person;
    final l$personID = personID;
    final l$startMarkerTime = startMarkerTime;
    final l$startUser = startUser;
    final l$startUserID = startUserID;
    final l$userPersonMarkerID = userPersonMarkerID;
    final l$userPersonMarkerPersonVariables = userPersonMarkerPersonVariables;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('endMarkerTime') ? l$endMarkerTime : const {},
      _$data.containsKey('endUser') ? l$endUser : const {},
      _$data.containsKey('endUserID') ? l$endUserID : const {},
      _$data.containsKey('markerType') ? l$markerType : const {},
      _$data.containsKey('markerTypeID') ? l$markerTypeID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('person') ? l$person : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('startMarkerTime') ? l$startMarkerTime : const {},
      _$data.containsKey('startUser') ? l$startUser : const {},
      _$data.containsKey('startUserID') ? l$startUserID : const {},
      _$data.containsKey('userPersonMarkerID')
          ? l$userPersonMarkerID
          : const {},
      _$data.containsKey('userPersonMarkerPersonVariables')
          ? l$userPersonMarkerPersonVariables
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonMarkerFilterInput<TRes> {
  factory CopyWith$Input$UserPersonMarkerFilterInput(
    Input$UserPersonMarkerFilterInput instance,
    TRes Function(Input$UserPersonMarkerFilterInput) then,
  ) = _CopyWithImpl$Input$UserPersonMarkerFilterInput;

  factory CopyWith$Input$UserPersonMarkerFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonMarkerFilterInput;

  TRes call({
    List<Input$UserPersonMarkerFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? endMarkerTime,
    Input$ApplicationUserFilterInput? endUser,
    Input$StringOperationFilterInput? endUserID,
    Input$MarkerTypeFilterInput? markerType,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$ComparableDateTimeOperationFilterInput? startMarkerTime,
    Input$ApplicationUserFilterInput? startUser,
    Input$StringOperationFilterInput? startUserID,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
  });
  TRes and(
      Iterable<Input$UserPersonMarkerFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserPersonMarkerFilterInput<
                      Input$UserPersonMarkerFilterInput>>?)
          _fn);
  CopyWith$Input$ApplicationFilterInput<TRes> get application;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get endMarkerTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get endUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get endUserID;
  CopyWith$Input$MarkerTypeFilterInput<TRes> get markerType;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$UserPersonMarkerFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserPersonMarkerFilterInput<
                      Input$UserPersonMarkerFilterInput>>?)
          _fn);
  CopyWith$Input$PersonFilterInput<TRes> get person;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID;
  CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes>
      get startMarkerTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get startUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get startUserID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID;
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
      TRes> get userPersonMarkerPersonVariables;
}

class _CopyWithImpl$Input$UserPersonMarkerFilterInput<TRes>
    implements CopyWith$Input$UserPersonMarkerFilterInput<TRes> {
  _CopyWithImpl$Input$UserPersonMarkerFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserPersonMarkerFilterInput _instance;

  final TRes Function(Input$UserPersonMarkerFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? application = _undefined,
    Object? applicationID = _undefined,
    Object? endMarkerTime = _undefined,
    Object? endUser = _undefined,
    Object? endUserID = _undefined,
    Object? markerType = _undefined,
    Object? markerTypeID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? person = _undefined,
    Object? personID = _undefined,
    Object? startMarkerTime = _undefined,
    Object? startUser = _undefined,
    Object? startUserID = _undefined,
    Object? userPersonMarkerID = _undefined,
    Object? userPersonMarkerPersonVariables = _undefined,
  }) =>
      _then(Input$UserPersonMarkerFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and': (and as List<Input$UserPersonMarkerFilterInput>?),
        if (application != _undefined)
          'application': (application as Input$ApplicationFilterInput?),
        if (applicationID != _undefined)
          'applicationID':
              (applicationID as Input$ComparableInt64OperationFilterInput?),
        if (endMarkerTime != _undefined)
          'endMarkerTime': (endMarkerTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (endUser != _undefined)
          'endUser': (endUser as Input$ApplicationUserFilterInput?),
        if (endUserID != _undefined)
          'endUserID': (endUserID as Input$StringOperationFilterInput?),
        if (markerType != _undefined)
          'markerType': (markerType as Input$MarkerTypeFilterInput?),
        if (markerTypeID != _undefined)
          'markerTypeID':
              (markerTypeID as Input$ComparableInt64OperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$UserPersonMarkerFilterInput>?),
        if (person != _undefined)
          'person': (person as Input$PersonFilterInput?),
        if (personID != _undefined)
          'personID': (personID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (startMarkerTime != _undefined)
          'startMarkerTime': (startMarkerTime
              as Input$ComparableDateTimeOperationFilterInput?),
        if (startUser != _undefined)
          'startUser': (startUser as Input$ApplicationUserFilterInput?),
        if (startUserID != _undefined)
          'startUserID': (startUserID as Input$StringOperationFilterInput?),
        if (userPersonMarkerID != _undefined)
          'userPersonMarkerID': (userPersonMarkerID
              as Input$ComparableInt64OperationFilterInput?),
        if (userPersonMarkerPersonVariables != _undefined)
          'userPersonMarkerPersonVariables': (userPersonMarkerPersonVariables
              as Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?),
      }));
  TRes and(
          Iterable<Input$UserPersonMarkerFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonMarkerFilterInput<
                          Input$UserPersonMarkerFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and
              ?.map((e) => CopyWith$Input$UserPersonMarkerFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ApplicationFilterInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID {
    final local$applicationID = _instance.applicationID;
    return local$applicationID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$applicationID, (e) => call(applicationID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get endMarkerTime {
    final local$endMarkerTime = _instance.endMarkerTime;
    return local$endMarkerTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$endMarkerTime, (e) => call(endMarkerTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get endUser {
    final local$endUser = _instance.endUser;
    return local$endUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$endUser, (e) => call(endUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get endUserID {
    final local$endUserID = _instance.endUserID;
    return local$endUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$endUserID, (e) => call(endUserID: e));
  }

  CopyWith$Input$MarkerTypeFilterInput<TRes> get markerType {
    final local$markerType = _instance.markerType;
    return local$markerType == null
        ? CopyWith$Input$MarkerTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$MarkerTypeFilterInput(
            local$markerType, (e) => call(markerType: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID {
    final local$markerTypeID = _instance.markerTypeID;
    return local$markerTypeID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$markerTypeID, (e) => call(markerTypeID: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$UserPersonMarkerFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonMarkerFilterInput<
                          Input$UserPersonMarkerFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or
              ?.map((e) => CopyWith$Input$UserPersonMarkerFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$PersonFilterInput<TRes> get person {
    final local$person = _instance.person;
    return local$person == null
        ? CopyWith$Input$PersonFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonFilterInput(
            local$person, (e) => call(person: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID {
    final local$personID = _instance.personID;
    return local$personID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$personID, (e) => call(personID: e));
  }

  CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes>
      get startMarkerTime {
    final local$startMarkerTime = _instance.startMarkerTime;
    return local$startMarkerTime == null
        ? CopyWith$Input$ComparableDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableDateTimeOperationFilterInput(
            local$startMarkerTime, (e) => call(startMarkerTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get startUser {
    final local$startUser = _instance.startUser;
    return local$startUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$startUser, (e) => call(startUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get startUserID {
    final local$startUserID = _instance.startUserID;
    return local$startUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$startUserID, (e) => call(startUserID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID {
    final local$userPersonMarkerID = _instance.userPersonMarkerID;
    return local$userPersonMarkerID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$userPersonMarkerID, (e) => call(userPersonMarkerID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
      TRes> get userPersonMarkerPersonVariables {
    final local$userPersonMarkerPersonVariables =
        _instance.userPersonMarkerPersonVariables;
    return local$userPersonMarkerPersonVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput(
            local$userPersonMarkerPersonVariables,
            (e) => call(userPersonMarkerPersonVariables: e));
  }
}

class _CopyWithStubImpl$Input$UserPersonMarkerFilterInput<TRes>
    implements CopyWith$Input$UserPersonMarkerFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserPersonMarkerFilterInput(this._res);

  TRes _res;

  call({
    List<Input$UserPersonMarkerFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? endMarkerTime,
    Input$ApplicationUserFilterInput? endUser,
    Input$StringOperationFilterInput? endUserID,
    Input$MarkerTypeFilterInput? markerType,
    Input$ComparableInt64OperationFilterInput? markerTypeID,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerFilterInput>? or,
    Input$PersonFilterInput? person,
    Input$ComparableNullableOfInt64OperationFilterInput? personID,
    Input$ComparableDateTimeOperationFilterInput? startMarkerTime,
    Input$ApplicationUserFilterInput? startUser,
    Input$StringOperationFilterInput? startUserID,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
    Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput?
        userPersonMarkerPersonVariables,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ApplicationFilterInput<TRes> get application =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get endMarkerTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get endUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get endUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$MarkerTypeFilterInput<TRes> get markerType =>
      CopyWith$Input$MarkerTypeFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get markerTypeID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$PersonFilterInput<TRes> get person =>
      CopyWith$Input$PersonFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get personID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$ComparableDateTimeOperationFilterInput<TRes>
      get startMarkerTime =>
          CopyWith$Input$ComparableDateTimeOperationFilterInput.stub(_res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get startUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get startUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput<
          TRes>
      get userPersonMarkerPersonVariables =>
          CopyWith$Input$ListFilterInputTypeOfUserPersonMarkerPersonVariableFilterInput
              .stub(_res);
}

class Input$UserPersonMarkerPersonVariableFilterInput {
  factory Input$UserPersonMarkerPersonVariableFilterInput({
    List<Input$UserPersonMarkerPersonVariableFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerPersonVariableFilterInput>? or,
    Input$PersonVariableFilterInput? personVariable,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$UserPersonMarkerFilterInput? userPersonMarker,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
  }) =>
      Input$UserPersonMarkerPersonVariableFilterInput._({
        if (and != null) r'and': and,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (personVariable != null) r'personVariable': personVariable,
        if (personVariableID != null) r'personVariableID': personVariableID,
        if (userPersonMarker != null) r'userPersonMarker': userPersonMarker,
        if (userPersonMarkerID != null)
          r'userPersonMarkerID': userPersonMarkerID,
      });

  Input$UserPersonMarkerPersonVariableFilterInput._(this._$data);

  factory Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserPersonMarkerPersonVariableFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('personVariable')) {
      final l$personVariable = data['personVariable'];
      result$data['personVariable'] = l$personVariable == null
          ? null
          : Input$PersonVariableFilterInput.fromJson(
              (l$personVariable as Map<String, dynamic>));
    }
    if (data.containsKey('personVariableID')) {
      final l$personVariableID = data['personVariableID'];
      result$data['personVariableID'] = l$personVariableID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$personVariableID as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarker')) {
      final l$userPersonMarker = data['userPersonMarker'];
      result$data['userPersonMarker'] = l$userPersonMarker == null
          ? null
          : Input$UserPersonMarkerFilterInput.fromJson(
              (l$userPersonMarker as Map<String, dynamic>));
    }
    if (data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = data['userPersonMarkerID'];
      result$data['userPersonMarkerID'] = l$userPersonMarkerID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$userPersonMarkerID as Map<String, dynamic>));
    }
    return Input$UserPersonMarkerPersonVariableFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserPersonMarkerPersonVariableFilterInput>? get and =>
      (_$data['and'] as List<Input$UserPersonMarkerPersonVariableFilterInput>?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$UserPersonMarkerPersonVariableFilterInput>? get or =>
      (_$data['or'] as List<Input$UserPersonMarkerPersonVariableFilterInput>?);
  Input$PersonVariableFilterInput? get personVariable =>
      (_$data['personVariable'] as Input$PersonVariableFilterInput?);
  Input$ComparableInt64OperationFilterInput? get personVariableID =>
      (_$data['personVariableID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$UserPersonMarkerFilterInput? get userPersonMarker =>
      (_$data['userPersonMarker'] as Input$UserPersonMarkerFilterInput?);
  Input$ComparableInt64OperationFilterInput? get userPersonMarkerID =>
      (_$data['userPersonMarkerID']
          as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('personVariable')) {
      final l$personVariable = personVariable;
      result$data['personVariable'] = l$personVariable?.toJson();
    }
    if (_$data.containsKey('personVariableID')) {
      final l$personVariableID = personVariableID;
      result$data['personVariableID'] = l$personVariableID?.toJson();
    }
    if (_$data.containsKey('userPersonMarker')) {
      final l$userPersonMarker = userPersonMarker;
      result$data['userPersonMarker'] = l$userPersonMarker?.toJson();
    }
    if (_$data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = userPersonMarkerID;
      result$data['userPersonMarkerID'] = l$userPersonMarkerID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<
          Input$UserPersonMarkerPersonVariableFilterInput>
      get copyWith => CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonMarkerPersonVariableFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$personVariable = personVariable;
    final lOther$personVariable = other.personVariable;
    if (_$data.containsKey('personVariable') !=
        other._$data.containsKey('personVariable')) {
      return false;
    }
    if (l$personVariable != lOther$personVariable) {
      return false;
    }
    final l$personVariableID = personVariableID;
    final lOther$personVariableID = other.personVariableID;
    if (_$data.containsKey('personVariableID') !=
        other._$data.containsKey('personVariableID')) {
      return false;
    }
    if (l$personVariableID != lOther$personVariableID) {
      return false;
    }
    final l$userPersonMarker = userPersonMarker;
    final lOther$userPersonMarker = other.userPersonMarker;
    if (_$data.containsKey('userPersonMarker') !=
        other._$data.containsKey('userPersonMarker')) {
      return false;
    }
    if (l$userPersonMarker != lOther$userPersonMarker) {
      return false;
    }
    final l$userPersonMarkerID = userPersonMarkerID;
    final lOther$userPersonMarkerID = other.userPersonMarkerID;
    if (_$data.containsKey('userPersonMarkerID') !=
        other._$data.containsKey('userPersonMarkerID')) {
      return false;
    }
    if (l$userPersonMarkerID != lOther$userPersonMarkerID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$personVariable = personVariable;
    final l$personVariableID = personVariableID;
    final l$userPersonMarker = userPersonMarker;
    final l$userPersonMarkerID = userPersonMarkerID;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('personVariable') ? l$personVariable : const {},
      _$data.containsKey('personVariableID') ? l$personVariableID : const {},
      _$data.containsKey('userPersonMarker') ? l$userPersonMarker : const {},
      _$data.containsKey('userPersonMarkerID')
          ? l$userPersonMarkerID
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> {
  factory CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
    Input$UserPersonMarkerPersonVariableFilterInput instance,
    TRes Function(Input$UserPersonMarkerPersonVariableFilterInput) then,
  ) = _CopyWithImpl$Input$UserPersonMarkerPersonVariableFilterInput;

  factory CopyWith$Input$UserPersonMarkerPersonVariableFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserPersonMarkerPersonVariableFilterInput;

  TRes call({
    List<Input$UserPersonMarkerPersonVariableFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerPersonVariableFilterInput>? or,
    Input$PersonVariableFilterInput? personVariable,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$UserPersonMarkerFilterInput? userPersonMarker,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
  });
  TRes and(
      Iterable<Input$UserPersonMarkerPersonVariableFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<
                      Input$UserPersonMarkerPersonVariableFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$UserPersonMarkerPersonVariableFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<
                      Input$UserPersonMarkerPersonVariableFilterInput>>?)
          _fn);
  CopyWith$Input$PersonVariableFilterInput<TRes> get personVariable;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get personVariableID;
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get userPersonMarker;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID;
}

class _CopyWithImpl$Input$UserPersonMarkerPersonVariableFilterInput<TRes>
    implements CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> {
  _CopyWithImpl$Input$UserPersonMarkerPersonVariableFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserPersonMarkerPersonVariableFilterInput _instance;

  final TRes Function(Input$UserPersonMarkerPersonVariableFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? personVariable = _undefined,
    Object? personVariableID = _undefined,
    Object? userPersonMarker = _undefined,
    Object? userPersonMarkerID = _undefined,
  }) =>
      _then(Input$UserPersonMarkerPersonVariableFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and':
              (and as List<Input$UserPersonMarkerPersonVariableFilterInput>?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$UserPersonMarkerPersonVariableFilterInput>?),
        if (personVariable != _undefined)
          'personVariable':
              (personVariable as Input$PersonVariableFilterInput?),
        if (personVariableID != _undefined)
          'personVariableID':
              (personVariableID as Input$ComparableInt64OperationFilterInput?),
        if (userPersonMarker != _undefined)
          'userPersonMarker':
              (userPersonMarker as Input$UserPersonMarkerFilterInput?),
        if (userPersonMarkerID != _undefined)
          'userPersonMarkerID': (userPersonMarkerID
              as Input$ComparableInt64OperationFilterInput?),
      }));
  TRes and(
          Iterable<Input$UserPersonMarkerPersonVariableFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<
                          Input$UserPersonMarkerPersonVariableFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map(
              (e) => CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$UserPersonMarkerPersonVariableFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<
                          Input$UserPersonMarkerPersonVariableFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map(
              (e) => CopyWith$Input$UserPersonMarkerPersonVariableFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$PersonVariableFilterInput<TRes> get personVariable {
    final local$personVariable = _instance.personVariable;
    return local$personVariable == null
        ? CopyWith$Input$PersonVariableFilterInput.stub(_then(_instance))
        : CopyWith$Input$PersonVariableFilterInput(
            local$personVariable, (e) => call(personVariable: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get personVariableID {
    final local$personVariableID = _instance.personVariableID;
    return local$personVariableID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$personVariableID, (e) => call(personVariableID: e));
  }

  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get userPersonMarker {
    final local$userPersonMarker = _instance.userPersonMarker;
    return local$userPersonMarker == null
        ? CopyWith$Input$UserPersonMarkerFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserPersonMarkerFilterInput(
            local$userPersonMarker, (e) => call(userPersonMarker: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID {
    final local$userPersonMarkerID = _instance.userPersonMarkerID;
    return local$userPersonMarkerID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$userPersonMarkerID, (e) => call(userPersonMarkerID: e));
  }
}

class _CopyWithStubImpl$Input$UserPersonMarkerPersonVariableFilterInput<TRes>
    implements CopyWith$Input$UserPersonMarkerPersonVariableFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserPersonMarkerPersonVariableFilterInput(this._res);

  TRes _res;

  call({
    List<Input$UserPersonMarkerPersonVariableFilterInput>? and,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserPersonMarkerPersonVariableFilterInput>? or,
    Input$PersonVariableFilterInput? personVariable,
    Input$ComparableInt64OperationFilterInput? personVariableID,
    Input$UserPersonMarkerFilterInput? userPersonMarker,
    Input$ComparableInt64OperationFilterInput? userPersonMarkerID,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$PersonVariableFilterInput<TRes> get personVariable =>
      CopyWith$Input$PersonVariableFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get personVariableID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$UserPersonMarkerFilterInput<TRes> get userPersonMarker =>
      CopyWith$Input$UserPersonMarkerFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get userPersonMarkerID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$UserPersonMarkerSortInput {
  factory Input$UserPersonMarkerSortInput({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? endMarkerTime,
    Input$ApplicationUserSortInput? endUser,
    Enum$SortEnumType? endUserID,
    Input$MarkerTypeSortInput? markerType,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Enum$SortEnumType? startMarkerTime,
    Input$ApplicationUserSortInput? startUser,
    Enum$SortEnumType? startUserID,
    Enum$SortEnumType? userPersonMarkerID,
  }) =>
      Input$UserPersonMarkerSortInput._({
        if (application != null) r'application': application,
        if (applicationID != null) r'applicationID': applicationID,
        if (endMarkerTime != null) r'endMarkerTime': endMarkerTime,
        if (endUser != null) r'endUser': endUser,
        if (endUserID != null) r'endUserID': endUserID,
        if (markerType != null) r'markerType': markerType,
        if (markerTypeID != null) r'markerTypeID': markerTypeID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (person != null) r'person': person,
        if (personID != null) r'personID': personID,
        if (startMarkerTime != null) r'startMarkerTime': startMarkerTime,
        if (startUser != null) r'startUser': startUser,
        if (startUserID != null) r'startUserID': startUserID,
        if (userPersonMarkerID != null)
          r'userPersonMarkerID': userPersonMarkerID,
      });

  Input$UserPersonMarkerSortInput._(this._$data);

  factory Input$UserPersonMarkerSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationSortInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : fromJson$Enum$SortEnumType((l$applicationID as String));
    }
    if (data.containsKey('endMarkerTime')) {
      final l$endMarkerTime = data['endMarkerTime'];
      result$data['endMarkerTime'] = l$endMarkerTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$endMarkerTime as String));
    }
    if (data.containsKey('endUser')) {
      final l$endUser = data['endUser'];
      result$data['endUser'] = l$endUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$endUser as Map<String, dynamic>));
    }
    if (data.containsKey('endUserID')) {
      final l$endUserID = data['endUserID'];
      result$data['endUserID'] = l$endUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$endUserID as String));
    }
    if (data.containsKey('markerType')) {
      final l$markerType = data['markerType'];
      result$data['markerType'] = l$markerType == null
          ? null
          : Input$MarkerTypeSortInput.fromJson(
              (l$markerType as Map<String, dynamic>));
    }
    if (data.containsKey('markerTypeID')) {
      final l$markerTypeID = data['markerTypeID'];
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : fromJson$Enum$SortEnumType((l$markerTypeID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('person')) {
      final l$person = data['person'];
      result$data['person'] = l$person == null
          ? null
          : Input$PersonSortInput.fromJson((l$person as Map<String, dynamic>));
    }
    if (data.containsKey('personID')) {
      final l$personID = data['personID'];
      result$data['personID'] = l$personID == null
          ? null
          : fromJson$Enum$SortEnumType((l$personID as String));
    }
    if (data.containsKey('startMarkerTime')) {
      final l$startMarkerTime = data['startMarkerTime'];
      result$data['startMarkerTime'] = l$startMarkerTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$startMarkerTime as String));
    }
    if (data.containsKey('startUser')) {
      final l$startUser = data['startUser'];
      result$data['startUser'] = l$startUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$startUser as Map<String, dynamic>));
    }
    if (data.containsKey('startUserID')) {
      final l$startUserID = data['startUserID'];
      result$data['startUserID'] = l$startUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$startUserID as String));
    }
    if (data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = data['userPersonMarkerID'];
      result$data['userPersonMarkerID'] = l$userPersonMarkerID == null
          ? null
          : fromJson$Enum$SortEnumType((l$userPersonMarkerID as String));
    }
    return Input$UserPersonMarkerSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ApplicationSortInput? get application =>
      (_$data['application'] as Input$ApplicationSortInput?);
  Enum$SortEnumType? get applicationID =>
      (_$data['applicationID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get endMarkerTime =>
      (_$data['endMarkerTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get endUser =>
      (_$data['endUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get endUserID =>
      (_$data['endUserID'] as Enum$SortEnumType?);
  Input$MarkerTypeSortInput? get markerType =>
      (_$data['markerType'] as Input$MarkerTypeSortInput?);
  Enum$SortEnumType? get markerTypeID =>
      (_$data['markerTypeID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Input$PersonSortInput? get person =>
      (_$data['person'] as Input$PersonSortInput?);
  Enum$SortEnumType? get personID => (_$data['personID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get startMarkerTime =>
      (_$data['startMarkerTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get startUser =>
      (_$data['startUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get startUserID =>
      (_$data['startUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get userPersonMarkerID =>
      (_$data['userPersonMarkerID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID == null
          ? null
          : toJson$Enum$SortEnumType(l$applicationID);
    }
    if (_$data.containsKey('endMarkerTime')) {
      final l$endMarkerTime = endMarkerTime;
      result$data['endMarkerTime'] = l$endMarkerTime == null
          ? null
          : toJson$Enum$SortEnumType(l$endMarkerTime);
    }
    if (_$data.containsKey('endUser')) {
      final l$endUser = endUser;
      result$data['endUser'] = l$endUser?.toJson();
    }
    if (_$data.containsKey('endUserID')) {
      final l$endUserID = endUserID;
      result$data['endUserID'] =
          l$endUserID == null ? null : toJson$Enum$SortEnumType(l$endUserID);
    }
    if (_$data.containsKey('markerType')) {
      final l$markerType = markerType;
      result$data['markerType'] = l$markerType?.toJson();
    }
    if (_$data.containsKey('markerTypeID')) {
      final l$markerTypeID = markerTypeID;
      result$data['markerTypeID'] = l$markerTypeID == null
          ? null
          : toJson$Enum$SortEnumType(l$markerTypeID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('person')) {
      final l$person = person;
      result$data['person'] = l$person?.toJson();
    }
    if (_$data.containsKey('personID')) {
      final l$personID = personID;
      result$data['personID'] =
          l$personID == null ? null : toJson$Enum$SortEnumType(l$personID);
    }
    if (_$data.containsKey('startMarkerTime')) {
      final l$startMarkerTime = startMarkerTime;
      result$data['startMarkerTime'] = l$startMarkerTime == null
          ? null
          : toJson$Enum$SortEnumType(l$startMarkerTime);
    }
    if (_$data.containsKey('startUser')) {
      final l$startUser = startUser;
      result$data['startUser'] = l$startUser?.toJson();
    }
    if (_$data.containsKey('startUserID')) {
      final l$startUserID = startUserID;
      result$data['startUserID'] = l$startUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$startUserID);
    }
    if (_$data.containsKey('userPersonMarkerID')) {
      final l$userPersonMarkerID = userPersonMarkerID;
      result$data['userPersonMarkerID'] = l$userPersonMarkerID == null
          ? null
          : toJson$Enum$SortEnumType(l$userPersonMarkerID);
    }
    return result$data;
  }

  CopyWith$Input$UserPersonMarkerSortInput<Input$UserPersonMarkerSortInput>
      get copyWith => CopyWith$Input$UserPersonMarkerSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPersonMarkerSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$endMarkerTime = endMarkerTime;
    final lOther$endMarkerTime = other.endMarkerTime;
    if (_$data.containsKey('endMarkerTime') !=
        other._$data.containsKey('endMarkerTime')) {
      return false;
    }
    if (l$endMarkerTime != lOther$endMarkerTime) {
      return false;
    }
    final l$endUser = endUser;
    final lOther$endUser = other.endUser;
    if (_$data.containsKey('endUser') != other._$data.containsKey('endUser')) {
      return false;
    }
    if (l$endUser != lOther$endUser) {
      return false;
    }
    final l$endUserID = endUserID;
    final lOther$endUserID = other.endUserID;
    if (_$data.containsKey('endUserID') !=
        other._$data.containsKey('endUserID')) {
      return false;
    }
    if (l$endUserID != lOther$endUserID) {
      return false;
    }
    final l$markerType = markerType;
    final lOther$markerType = other.markerType;
    if (_$data.containsKey('markerType') !=
        other._$data.containsKey('markerType')) {
      return false;
    }
    if (l$markerType != lOther$markerType) {
      return false;
    }
    final l$markerTypeID = markerTypeID;
    final lOther$markerTypeID = other.markerTypeID;
    if (_$data.containsKey('markerTypeID') !=
        other._$data.containsKey('markerTypeID')) {
      return false;
    }
    if (l$markerTypeID != lOther$markerTypeID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$person = person;
    final lOther$person = other.person;
    if (_$data.containsKey('person') != other._$data.containsKey('person')) {
      return false;
    }
    if (l$person != lOther$person) {
      return false;
    }
    final l$personID = personID;
    final lOther$personID = other.personID;
    if (_$data.containsKey('personID') !=
        other._$data.containsKey('personID')) {
      return false;
    }
    if (l$personID != lOther$personID) {
      return false;
    }
    final l$startMarkerTime = startMarkerTime;
    final lOther$startMarkerTime = other.startMarkerTime;
    if (_$data.containsKey('startMarkerTime') !=
        other._$data.containsKey('startMarkerTime')) {
      return false;
    }
    if (l$startMarkerTime != lOther$startMarkerTime) {
      return false;
    }
    final l$startUser = startUser;
    final lOther$startUser = other.startUser;
    if (_$data.containsKey('startUser') !=
        other._$data.containsKey('startUser')) {
      return false;
    }
    if (l$startUser != lOther$startUser) {
      return false;
    }
    final l$startUserID = startUserID;
    final lOther$startUserID = other.startUserID;
    if (_$data.containsKey('startUserID') !=
        other._$data.containsKey('startUserID')) {
      return false;
    }
    if (l$startUserID != lOther$startUserID) {
      return false;
    }
    final l$userPersonMarkerID = userPersonMarkerID;
    final lOther$userPersonMarkerID = other.userPersonMarkerID;
    if (_$data.containsKey('userPersonMarkerID') !=
        other._$data.containsKey('userPersonMarkerID')) {
      return false;
    }
    if (l$userPersonMarkerID != lOther$userPersonMarkerID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$application = application;
    final l$applicationID = applicationID;
    final l$endMarkerTime = endMarkerTime;
    final l$endUser = endUser;
    final l$endUserID = endUserID;
    final l$markerType = markerType;
    final l$markerTypeID = markerTypeID;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$person = person;
    final l$personID = personID;
    final l$startMarkerTime = startMarkerTime;
    final l$startUser = startUser;
    final l$startUserID = startUserID;
    final l$userPersonMarkerID = userPersonMarkerID;
    return Object.hashAll([
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('endMarkerTime') ? l$endMarkerTime : const {},
      _$data.containsKey('endUser') ? l$endUser : const {},
      _$data.containsKey('endUserID') ? l$endUserID : const {},
      _$data.containsKey('markerType') ? l$markerType : const {},
      _$data.containsKey('markerTypeID') ? l$markerTypeID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('person') ? l$person : const {},
      _$data.containsKey('personID') ? l$personID : const {},
      _$data.containsKey('startMarkerTime') ? l$startMarkerTime : const {},
      _$data.containsKey('startUser') ? l$startUser : const {},
      _$data.containsKey('startUserID') ? l$startUserID : const {},
      _$data.containsKey('userPersonMarkerID')
          ? l$userPersonMarkerID
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPersonMarkerSortInput<TRes> {
  factory CopyWith$Input$UserPersonMarkerSortInput(
    Input$UserPersonMarkerSortInput instance,
    TRes Function(Input$UserPersonMarkerSortInput) then,
  ) = _CopyWithImpl$Input$UserPersonMarkerSortInput;

  factory CopyWith$Input$UserPersonMarkerSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPersonMarkerSortInput;

  TRes call({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? endMarkerTime,
    Input$ApplicationUserSortInput? endUser,
    Enum$SortEnumType? endUserID,
    Input$MarkerTypeSortInput? markerType,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Enum$SortEnumType? startMarkerTime,
    Input$ApplicationUserSortInput? startUser,
    Enum$SortEnumType? startUserID,
    Enum$SortEnumType? userPersonMarkerID,
  });
  CopyWith$Input$ApplicationSortInput<TRes> get application;
  CopyWith$Input$ApplicationUserSortInput<TRes> get endUser;
  CopyWith$Input$MarkerTypeSortInput<TRes> get markerType;
  CopyWith$Input$PersonSortInput<TRes> get person;
  CopyWith$Input$ApplicationUserSortInput<TRes> get startUser;
}

class _CopyWithImpl$Input$UserPersonMarkerSortInput<TRes>
    implements CopyWith$Input$UserPersonMarkerSortInput<TRes> {
  _CopyWithImpl$Input$UserPersonMarkerSortInput(
    this._instance,
    this._then,
  );

  final Input$UserPersonMarkerSortInput _instance;

  final TRes Function(Input$UserPersonMarkerSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? application = _undefined,
    Object? applicationID = _undefined,
    Object? endMarkerTime = _undefined,
    Object? endUser = _undefined,
    Object? endUserID = _undefined,
    Object? markerType = _undefined,
    Object? markerTypeID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? person = _undefined,
    Object? personID = _undefined,
    Object? startMarkerTime = _undefined,
    Object? startUser = _undefined,
    Object? startUserID = _undefined,
    Object? userPersonMarkerID = _undefined,
  }) =>
      _then(Input$UserPersonMarkerSortInput._({
        ..._instance._$data,
        if (application != _undefined)
          'application': (application as Input$ApplicationSortInput?),
        if (applicationID != _undefined)
          'applicationID': (applicationID as Enum$SortEnumType?),
        if (endMarkerTime != _undefined)
          'endMarkerTime': (endMarkerTime as Enum$SortEnumType?),
        if (endUser != _undefined)
          'endUser': (endUser as Input$ApplicationUserSortInput?),
        if (endUserID != _undefined)
          'endUserID': (endUserID as Enum$SortEnumType?),
        if (markerType != _undefined)
          'markerType': (markerType as Input$MarkerTypeSortInput?),
        if (markerTypeID != _undefined)
          'markerTypeID': (markerTypeID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (person != _undefined) 'person': (person as Input$PersonSortInput?),
        if (personID != _undefined)
          'personID': (personID as Enum$SortEnumType?),
        if (startMarkerTime != _undefined)
          'startMarkerTime': (startMarkerTime as Enum$SortEnumType?),
        if (startUser != _undefined)
          'startUser': (startUser as Input$ApplicationUserSortInput?),
        if (startUserID != _undefined)
          'startUserID': (startUserID as Enum$SortEnumType?),
        if (userPersonMarkerID != _undefined)
          'userPersonMarkerID': (userPersonMarkerID as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationSortInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationSortInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$ApplicationUserSortInput<TRes> get endUser {
    final local$endUser = _instance.endUser;
    return local$endUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$endUser, (e) => call(endUser: e));
  }

  CopyWith$Input$MarkerTypeSortInput<TRes> get markerType {
    final local$markerType = _instance.markerType;
    return local$markerType == null
        ? CopyWith$Input$MarkerTypeSortInput.stub(_then(_instance))
        : CopyWith$Input$MarkerTypeSortInput(
            local$markerType, (e) => call(markerType: e));
  }

  CopyWith$Input$PersonSortInput<TRes> get person {
    final local$person = _instance.person;
    return local$person == null
        ? CopyWith$Input$PersonSortInput.stub(_then(_instance))
        : CopyWith$Input$PersonSortInput(local$person, (e) => call(person: e));
  }

  CopyWith$Input$ApplicationUserSortInput<TRes> get startUser {
    final local$startUser = _instance.startUser;
    return local$startUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$startUser, (e) => call(startUser: e));
  }
}

class _CopyWithStubImpl$Input$UserPersonMarkerSortInput<TRes>
    implements CopyWith$Input$UserPersonMarkerSortInput<TRes> {
  _CopyWithStubImpl$Input$UserPersonMarkerSortInput(this._res);

  TRes _res;

  call({
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? endMarkerTime,
    Input$ApplicationUserSortInput? endUser,
    Enum$SortEnumType? endUserID,
    Input$MarkerTypeSortInput? markerType,
    Enum$SortEnumType? markerTypeID,
    Enum$SortEnumType? modificationTime,
    Enum$SortEnumType? modifyingUserID,
    Input$PersonSortInput? person,
    Enum$SortEnumType? personID,
    Enum$SortEnumType? startMarkerTime,
    Input$ApplicationUserSortInput? startUser,
    Enum$SortEnumType? startUserID,
    Enum$SortEnumType? userPersonMarkerID,
  }) =>
      _res;
  CopyWith$Input$ApplicationSortInput<TRes> get application =>
      CopyWith$Input$ApplicationSortInput.stub(_res);
  CopyWith$Input$ApplicationUserSortInput<TRes> get endUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
  CopyWith$Input$MarkerTypeSortInput<TRes> get markerType =>
      CopyWith$Input$MarkerTypeSortInput.stub(_res);
  CopyWith$Input$PersonSortInput<TRes> get person =>
      CopyWith$Input$PersonSortInput.stub(_res);
  CopyWith$Input$ApplicationUserSortInput<TRes> get startUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
}

class Input$UserTerritoryFilterInput {
  factory Input$UserTerritoryFilterInput({
    Input$BooleanOperationFilterInput? active,
    List<Input$UserTerritoryFilterInput>? and,
    Input$StringOperationFilterInput? cargo,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ApplicationUserFilterInput? user,
    Input$StringOperationFilterInput? userID,
  }) =>
      Input$UserTerritoryFilterInput._({
        if (active != null) r'active': active,
        if (and != null) r'and': and,
        if (cargo != null) r'cargo': cargo,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (territory != null) r'territory': territory,
        if (territoryID != null) r'territoryID': territoryID,
        if (user != null) r'user': user,
        if (userID != null) r'userID': userID,
      });

  Input$UserTerritoryFilterInput._(this._$data);

  factory Input$UserTerritoryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = l$active == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$active as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$UserTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('cargo')) {
      final l$cargo = data['cargo'];
      result$data['cargo'] = l$cargo == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$cargo as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$UserTerritoryFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('territory')) {
      final l$territory = data['territory'];
      result$data['territory'] = l$territory == null
          ? null
          : Input$TerritoryFilterInput.fromJson(
              (l$territory as Map<String, dynamic>));
    }
    if (data.containsKey('territoryID')) {
      final l$territoryID = data['territoryID'];
      result$data['territoryID'] = l$territoryID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$territoryID as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userID')) {
      final l$userID = data['userID'];
      result$data['userID'] = l$userID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userID as Map<String, dynamic>));
    }
    return Input$UserTerritoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BooleanOperationFilterInput? get active =>
      (_$data['active'] as Input$BooleanOperationFilterInput?);
  List<Input$UserTerritoryFilterInput>? get and =>
      (_$data['and'] as List<Input$UserTerritoryFilterInput>?);
  Input$StringOperationFilterInput? get cargo =>
      (_$data['cargo'] as Input$StringOperationFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$UserTerritoryFilterInput>? get or =>
      (_$data['or'] as List<Input$UserTerritoryFilterInput>?);
  Input$TerritoryFilterInput? get territory =>
      (_$data['territory'] as Input$TerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get territoryID =>
      (_$data['territoryID'] as Input$ComparableInt64OperationFilterInput?);
  Input$ApplicationUserFilterInput? get user =>
      (_$data['user'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get userID =>
      (_$data['userID'] as Input$StringOperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('cargo')) {
      final l$cargo = cargo;
      result$data['cargo'] = l$cargo?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('territory')) {
      final l$territory = territory;
      result$data['territory'] = l$territory?.toJson();
    }
    if (_$data.containsKey('territoryID')) {
      final l$territoryID = territoryID;
      result$data['territoryID'] = l$territoryID?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userID')) {
      final l$userID = userID;
      result$data['userID'] = l$userID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserTerritoryFilterInput<Input$UserTerritoryFilterInput>
      get copyWith => CopyWith$Input$UserTerritoryFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserTerritoryFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$cargo = cargo;
    final lOther$cargo = other.cargo;
    if (_$data.containsKey('cargo') != other._$data.containsKey('cargo')) {
      return false;
    }
    if (l$cargo != lOther$cargo) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$territory = territory;
    final lOther$territory = other.territory;
    if (_$data.containsKey('territory') !=
        other._$data.containsKey('territory')) {
      return false;
    }
    if (l$territory != lOther$territory) {
      return false;
    }
    final l$territoryID = territoryID;
    final lOther$territoryID = other.territoryID;
    if (_$data.containsKey('territoryID') !=
        other._$data.containsKey('territoryID')) {
      return false;
    }
    if (l$territoryID != lOther$territoryID) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userID = userID;
    final lOther$userID = other.userID;
    if (_$data.containsKey('userID') != other._$data.containsKey('userID')) {
      return false;
    }
    if (l$userID != lOther$userID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$active = active;
    final l$and = and;
    final l$cargo = cargo;
    final l$modificationTime = modificationTime;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$territory = territory;
    final l$territoryID = territoryID;
    final l$user = user;
    final l$userID = userID;
    return Object.hashAll([
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('cargo') ? l$cargo : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('territory') ? l$territory : const {},
      _$data.containsKey('territoryID') ? l$territoryID : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userID') ? l$userID : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserTerritoryFilterInput<TRes> {
  factory CopyWith$Input$UserTerritoryFilterInput(
    Input$UserTerritoryFilterInput instance,
    TRes Function(Input$UserTerritoryFilterInput) then,
  ) = _CopyWithImpl$Input$UserTerritoryFilterInput;

  factory CopyWith$Input$UserTerritoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserTerritoryFilterInput;

  TRes call({
    Input$BooleanOperationFilterInput? active,
    List<Input$UserTerritoryFilterInput>? and,
    Input$StringOperationFilterInput? cargo,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ApplicationUserFilterInput? user,
    Input$StringOperationFilterInput? userID,
  });
  CopyWith$Input$BooleanOperationFilterInput<TRes> get active;
  TRes and(
      Iterable<Input$UserTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserTerritoryFilterInput<
                      Input$UserTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$StringOperationFilterInput<TRes> get cargo;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$UserTerritoryFilterInput>? Function(
              Iterable<
                  CopyWith$Input$UserTerritoryFilterInput<
                      Input$UserTerritoryFilterInput>>?)
          _fn);
  CopyWith$Input$TerritoryFilterInput<TRes> get territory;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get user;
  CopyWith$Input$StringOperationFilterInput<TRes> get userID;
}

class _CopyWithImpl$Input$UserTerritoryFilterInput<TRes>
    implements CopyWith$Input$UserTerritoryFilterInput<TRes> {
  _CopyWithImpl$Input$UserTerritoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserTerritoryFilterInput _instance;

  final TRes Function(Input$UserTerritoryFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? active = _undefined,
    Object? and = _undefined,
    Object? cargo = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? territory = _undefined,
    Object? territoryID = _undefined,
    Object? user = _undefined,
    Object? userID = _undefined,
  }) =>
      _then(Input$UserTerritoryFilterInput._({
        ..._instance._$data,
        if (active != _undefined)
          'active': (active as Input$BooleanOperationFilterInput?),
        if (and != _undefined)
          'and': (and as List<Input$UserTerritoryFilterInput>?),
        if (cargo != _undefined)
          'cargo': (cargo as Input$StringOperationFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$UserTerritoryFilterInput>?),
        if (territory != _undefined)
          'territory': (territory as Input$TerritoryFilterInput?),
        if (territoryID != _undefined)
          'territoryID':
              (territoryID as Input$ComparableInt64OperationFilterInput?),
        if (user != _undefined)
          'user': (user as Input$ApplicationUserFilterInput?),
        if (userID != _undefined)
          'userID': (userID as Input$StringOperationFilterInput?),
      }));
  CopyWith$Input$BooleanOperationFilterInput<TRes> get active {
    final local$active = _instance.active;
    return local$active == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$active, (e) => call(active: e));
  }

  TRes and(
          Iterable<Input$UserTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserTerritoryFilterInput<
                          Input$UserTerritoryFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$UserTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringOperationFilterInput<TRes> get cargo {
    final local$cargo = _instance.cargo;
    return local$cargo == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$cargo, (e) => call(cargo: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$UserTerritoryFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$UserTerritoryFilterInput<
                          Input$UserTerritoryFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$UserTerritoryFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$TerritoryFilterInput<TRes> get territory {
    final local$territory = _instance.territory;
    return local$territory == null
        ? CopyWith$Input$TerritoryFilterInput.stub(_then(_instance))
        : CopyWith$Input$TerritoryFilterInput(
            local$territory, (e) => call(territory: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID {
    final local$territoryID = _instance.territoryID;
    return local$territoryID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$territoryID, (e) => call(territoryID: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userID {
    final local$userID = _instance.userID;
    return local$userID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userID, (e) => call(userID: e));
  }
}

class _CopyWithStubImpl$Input$UserTerritoryFilterInput<TRes>
    implements CopyWith$Input$UserTerritoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserTerritoryFilterInput(this._res);

  TRes _res;

  call({
    Input$BooleanOperationFilterInput? active,
    List<Input$UserTerritoryFilterInput>? and,
    Input$StringOperationFilterInput? cargo,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$UserTerritoryFilterInput>? or,
    Input$TerritoryFilterInput? territory,
    Input$ComparableInt64OperationFilterInput? territoryID,
    Input$ApplicationUserFilterInput? user,
    Input$StringOperationFilterInput? userID,
  }) =>
      _res;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get active =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
  and(_fn) => _res;
  CopyWith$Input$StringOperationFilterInput<TRes> get cargo =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$TerritoryFilterInput<TRes> get territory =>
      CopyWith$Input$TerritoryFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get territoryID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get user =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get userID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$VariableTypeConditionDependencyFilterInput {
  factory Input$VariableTypeConditionDependencyFilterInput({
    List<Input$VariableTypeConditionDependencyFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? dependencyDestinationID,
    Input$ComparableInt64OperationFilterInput? dependencyOriginID,
    Input$VariableTypeFilterInput? destinationDependency,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$VariableTypeConditionDependencyFilterInput>? or,
    Input$VariableTypeFilterInput? originDependency,
  }) =>
      Input$VariableTypeConditionDependencyFilterInput._({
        if (and != null) r'and': and,
        if (dependencyDestinationID != null)
          r'dependencyDestinationID': dependencyDestinationID,
        if (dependencyOriginID != null)
          r'dependencyOriginID': dependencyOriginID,
        if (destinationDependency != null)
          r'destinationDependency': destinationDependency,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (or != null) r'or': or,
        if (originDependency != null) r'originDependency': originDependency,
      });

  Input$VariableTypeConditionDependencyFilterInput._(this._$data);

  factory Input$VariableTypeConditionDependencyFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) =>
              Input$VariableTypeConditionDependencyFilterInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('dependencyDestinationID')) {
      final l$dependencyDestinationID = data['dependencyDestinationID'];
      result$data['dependencyDestinationID'] = l$dependencyDestinationID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$dependencyDestinationID as Map<String, dynamic>));
    }
    if (data.containsKey('dependencyOriginID')) {
      final l$dependencyOriginID = data['dependencyOriginID'];
      result$data['dependencyOriginID'] = l$dependencyOriginID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$dependencyOriginID as Map<String, dynamic>));
    }
    if (data.containsKey('destinationDependency')) {
      final l$destinationDependency = data['destinationDependency'];
      result$data['destinationDependency'] = l$destinationDependency == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$destinationDependency as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) =>
              Input$VariableTypeConditionDependencyFilterInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('originDependency')) {
      final l$originDependency = data['originDependency'];
      result$data['originDependency'] = l$originDependency == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$originDependency as Map<String, dynamic>));
    }
    return Input$VariableTypeConditionDependencyFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$VariableTypeConditionDependencyFilterInput>? get and =>
      (_$data['and']
          as List<Input$VariableTypeConditionDependencyFilterInput>?);
  Input$ComparableInt64OperationFilterInput? get dependencyDestinationID =>
      (_$data['dependencyDestinationID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get dependencyOriginID =>
      (_$data['dependencyOriginID']
          as Input$ComparableInt64OperationFilterInput?);
  Input$VariableTypeFilterInput? get destinationDependency =>
      (_$data['destinationDependency'] as Input$VariableTypeFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  List<Input$VariableTypeConditionDependencyFilterInput>? get or =>
      (_$data['or'] as List<Input$VariableTypeConditionDependencyFilterInput>?);
  Input$VariableTypeFilterInput? get originDependency =>
      (_$data['originDependency'] as Input$VariableTypeFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('dependencyDestinationID')) {
      final l$dependencyDestinationID = dependencyDestinationID;
      result$data['dependencyDestinationID'] =
          l$dependencyDestinationID?.toJson();
    }
    if (_$data.containsKey('dependencyOriginID')) {
      final l$dependencyOriginID = dependencyOriginID;
      result$data['dependencyOriginID'] = l$dependencyOriginID?.toJson();
    }
    if (_$data.containsKey('destinationDependency')) {
      final l$destinationDependency = destinationDependency;
      result$data['destinationDependency'] = l$destinationDependency?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('originDependency')) {
      final l$originDependency = originDependency;
      result$data['originDependency'] = l$originDependency?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$VariableTypeConditionDependencyFilterInput<
          Input$VariableTypeConditionDependencyFilterInput>
      get copyWith => CopyWith$Input$VariableTypeConditionDependencyFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VariableTypeConditionDependencyFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$dependencyDestinationID = dependencyDestinationID;
    final lOther$dependencyDestinationID = other.dependencyDestinationID;
    if (_$data.containsKey('dependencyDestinationID') !=
        other._$data.containsKey('dependencyDestinationID')) {
      return false;
    }
    if (l$dependencyDestinationID != lOther$dependencyDestinationID) {
      return false;
    }
    final l$dependencyOriginID = dependencyOriginID;
    final lOther$dependencyOriginID = other.dependencyOriginID;
    if (_$data.containsKey('dependencyOriginID') !=
        other._$data.containsKey('dependencyOriginID')) {
      return false;
    }
    if (l$dependencyOriginID != lOther$dependencyOriginID) {
      return false;
    }
    final l$destinationDependency = destinationDependency;
    final lOther$destinationDependency = other.destinationDependency;
    if (_$data.containsKey('destinationDependency') !=
        other._$data.containsKey('destinationDependency')) {
      return false;
    }
    if (l$destinationDependency != lOther$destinationDependency) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$originDependency = originDependency;
    final lOther$originDependency = other.originDependency;
    if (_$data.containsKey('originDependency') !=
        other._$data.containsKey('originDependency')) {
      return false;
    }
    if (l$originDependency != lOther$originDependency) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$dependencyDestinationID = dependencyDestinationID;
    final l$dependencyOriginID = dependencyOriginID;
    final l$destinationDependency = destinationDependency;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$or = or;
    final l$originDependency = originDependency;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('dependencyDestinationID')
          ? l$dependencyDestinationID
          : const {},
      _$data.containsKey('dependencyOriginID')
          ? l$dependencyOriginID
          : const {},
      _$data.containsKey('destinationDependency')
          ? l$destinationDependency
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('originDependency') ? l$originDependency : const {},
    ]);
  }
}

abstract class CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> {
  factory CopyWith$Input$VariableTypeConditionDependencyFilterInput(
    Input$VariableTypeConditionDependencyFilterInput instance,
    TRes Function(Input$VariableTypeConditionDependencyFilterInput) then,
  ) = _CopyWithImpl$Input$VariableTypeConditionDependencyFilterInput;

  factory CopyWith$Input$VariableTypeConditionDependencyFilterInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$VariableTypeConditionDependencyFilterInput;

  TRes call({
    List<Input$VariableTypeConditionDependencyFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? dependencyDestinationID,
    Input$ComparableInt64OperationFilterInput? dependencyOriginID,
    Input$VariableTypeFilterInput? destinationDependency,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$VariableTypeConditionDependencyFilterInput>? or,
    Input$VariableTypeFilterInput? originDependency,
  });
  TRes and(
      Iterable<Input$VariableTypeConditionDependencyFilterInput>? Function(
              Iterable<
                  CopyWith$Input$VariableTypeConditionDependencyFilterInput<
                      Input$VariableTypeConditionDependencyFilterInput>>?)
          _fn);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyDestinationID;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyOriginID;
  CopyWith$Input$VariableTypeFilterInput<TRes> get destinationDependency;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  TRes or(
      Iterable<Input$VariableTypeConditionDependencyFilterInput>? Function(
              Iterable<
                  CopyWith$Input$VariableTypeConditionDependencyFilterInput<
                      Input$VariableTypeConditionDependencyFilterInput>>?)
          _fn);
  CopyWith$Input$VariableTypeFilterInput<TRes> get originDependency;
}

class _CopyWithImpl$Input$VariableTypeConditionDependencyFilterInput<TRes>
    implements CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> {
  _CopyWithImpl$Input$VariableTypeConditionDependencyFilterInput(
    this._instance,
    this._then,
  );

  final Input$VariableTypeConditionDependencyFilterInput _instance;

  final TRes Function(Input$VariableTypeConditionDependencyFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? and = _undefined,
    Object? dependencyDestinationID = _undefined,
    Object? dependencyOriginID = _undefined,
    Object? destinationDependency = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? or = _undefined,
    Object? originDependency = _undefined,
  }) =>
      _then(Input$VariableTypeConditionDependencyFilterInput._({
        ..._instance._$data,
        if (and != _undefined)
          'and':
              (and as List<Input$VariableTypeConditionDependencyFilterInput>?),
        if (dependencyDestinationID != _undefined)
          'dependencyDestinationID': (dependencyDestinationID
              as Input$ComparableInt64OperationFilterInput?),
        if (dependencyOriginID != _undefined)
          'dependencyOriginID': (dependencyOriginID
              as Input$ComparableInt64OperationFilterInput?),
        if (destinationDependency != _undefined)
          'destinationDependency':
              (destinationDependency as Input$VariableTypeFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$VariableTypeConditionDependencyFilterInput>?),
        if (originDependency != _undefined)
          'originDependency':
              (originDependency as Input$VariableTypeFilterInput?),
      }));
  TRes and(
          Iterable<Input$VariableTypeConditionDependencyFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$VariableTypeConditionDependencyFilterInput<
                          Input$VariableTypeConditionDependencyFilterInput>>?)
              _fn) =>
      call(
          and: _fn(_instance.and?.map(
              (e) => CopyWith$Input$VariableTypeConditionDependencyFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyDestinationID {
    final local$dependencyDestinationID = _instance.dependencyDestinationID;
    return local$dependencyDestinationID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$dependencyDestinationID,
            (e) => call(dependencyDestinationID: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyOriginID {
    final local$dependencyOriginID = _instance.dependencyOriginID;
    return local$dependencyOriginID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$dependencyOriginID, (e) => call(dependencyOriginID: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get destinationDependency {
    final local$destinationDependency = _instance.destinationDependency;
    return local$destinationDependency == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$destinationDependency, (e) => call(destinationDependency: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  TRes or(
          Iterable<Input$VariableTypeConditionDependencyFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$VariableTypeConditionDependencyFilterInput<
                          Input$VariableTypeConditionDependencyFilterInput>>?)
              _fn) =>
      call(
          or: _fn(_instance.or?.map(
              (e) => CopyWith$Input$VariableTypeConditionDependencyFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$VariableTypeFilterInput<TRes> get originDependency {
    final local$originDependency = _instance.originDependency;
    return local$originDependency == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$originDependency, (e) => call(originDependency: e));
  }
}

class _CopyWithStubImpl$Input$VariableTypeConditionDependencyFilterInput<TRes>
    implements CopyWith$Input$VariableTypeConditionDependencyFilterInput<TRes> {
  _CopyWithStubImpl$Input$VariableTypeConditionDependencyFilterInput(this._res);

  TRes _res;

  call({
    List<Input$VariableTypeConditionDependencyFilterInput>? and,
    Input$ComparableInt64OperationFilterInput? dependencyDestinationID,
    Input$ComparableInt64OperationFilterInput? dependencyOriginID,
    Input$VariableTypeFilterInput? destinationDependency,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    List<Input$VariableTypeConditionDependencyFilterInput>? or,
    Input$VariableTypeFilterInput? originDependency,
  }) =>
      _res;
  and(_fn) => _res;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyDestinationID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes>
      get dependencyOriginID =>
          CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get destinationDependency =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$VariableTypeFilterInput<TRes> get originDependency =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
}

class Input$VariableTypeFilterInput {
  factory Input$VariableTypeFilterInput({
    Input$AccessibilityOperationFilterInput? accessibility,
    List<Input$VariableTypeFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$StringOperationFilterInput? calculationCode,
    Input$StringOperationFilterInput? conditionCode,
    Input$DataTypeOperationFilterInput? dataType,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        destinationConditionDependencies,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$VariableTypeFilterInput? list,
    Input$ComparableNullableOfInt64OperationFilterInput? listID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? listedVariableTypes,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$VariableTypeFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        originConditionDependencies,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      Input$VariableTypeFilterInput._({
        if (accessibility != null) r'accessibility': accessibility,
        if (and != null) r'and': and,
        if (application != null) r'application': application,
        if (applicationID != null) r'applicationID': applicationID,
        if (calculationCode != null) r'calculationCode': calculationCode,
        if (conditionCode != null) r'conditionCode': conditionCode,
        if (dataType != null) r'dataType': dataType,
        if (description != null) r'description': description,
        if (destinationConditionDependencies != null)
          r'destinationConditionDependencies': destinationConditionDependencies,
        if (enumGroup != null) r'enumGroup': enumGroup,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (list != null) r'list': list,
        if (listID != null) r'listID': listID,
        if (listedVariableTypes != null)
          r'listedVariableTypes': listedVariableTypes,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (or != null) r'or': or,
        if (originConditionDependencies != null)
          r'originConditionDependencies': originConditionDependencies,
        if (personVariables != null) r'personVariables': personVariables,
        if (suscriptionTerritories != null)
          r'suscriptionTerritories': suscriptionTerritories,
        if (variableTypeID != null) r'variableTypeID': variableTypeID,
      });

  Input$VariableTypeFilterInput._(this._$data);

  factory Input$VariableTypeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessibility')) {
      final l$accessibility = data['accessibility'];
      result$data['accessibility'] = l$accessibility == null
          ? null
          : Input$AccessibilityOperationFilterInput.fromJson(
              (l$accessibility as Map<String, dynamic>));
    }
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map((e) => Input$VariableTypeFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationFilterInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$applicationID as Map<String, dynamic>));
    }
    if (data.containsKey('calculationCode')) {
      final l$calculationCode = data['calculationCode'];
      result$data['calculationCode'] = l$calculationCode == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$calculationCode as Map<String, dynamic>));
    }
    if (data.containsKey('conditionCode')) {
      final l$conditionCode = data['conditionCode'];
      result$data['conditionCode'] = l$conditionCode == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$conditionCode as Map<String, dynamic>));
    }
    if (data.containsKey('dataType')) {
      final l$dataType = data['dataType'];
      result$data['dataType'] = l$dataType == null
          ? null
          : Input$DataTypeOperationFilterInput.fromJson(
              (l$dataType as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('destinationConditionDependencies')) {
      final l$destinationConditionDependencies =
          data['destinationConditionDependencies'];
      result$data['destinationConditionDependencies'] =
          l$destinationConditionDependencies == null
              ? null
              : Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
                  .fromJson((l$destinationConditionDependencies
                      as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroup')) {
      final l$enumGroup = data['enumGroup'];
      result$data['enumGroup'] = l$enumGroup == null
          ? null
          : Input$EnumGroupFilterInput.fromJson(
              (l$enumGroup as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$enumGroupID as Map<String, dynamic>));
    }
    if (data.containsKey('list')) {
      final l$list = data['list'];
      result$data['list'] = l$list == null
          ? null
          : Input$VariableTypeFilterInput.fromJson(
              (l$list as Map<String, dynamic>));
    }
    if (data.containsKey('listID')) {
      final l$listID = data['listID'];
      result$data['listID'] = l$listID == null
          ? null
          : Input$ComparableNullableOfInt64OperationFilterInput.fromJson(
              (l$listID as Map<String, dynamic>));
    }
    if (data.containsKey('listedVariableTypes')) {
      final l$listedVariableTypes = data['listedVariableTypes'];
      result$data['listedVariableTypes'] = l$listedVariableTypes == null
          ? null
          : Input$ListFilterInputTypeOfVariableTypeFilterInput.fromJson(
              (l$listedVariableTypes as Map<String, dynamic>));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : Input$ComparableNullableOfDateTimeOperationFilterInput.fromJson(
              (l$modificationTime as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserFilterInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$modifyingUserID as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map((e) => Input$VariableTypeFilterInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('originConditionDependencies')) {
      final l$originConditionDependencies = data['originConditionDependencies'];
      result$data[
          'originConditionDependencies'] = l$originConditionDependencies ==
              null
          ? null
          : Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
              .fromJson(
                  (l$originConditionDependencies as Map<String, dynamic>));
    }
    if (data.containsKey('personVariables')) {
      final l$personVariables = data['personVariables'];
      result$data['personVariables'] = l$personVariables == null
          ? null
          : Input$ListFilterInputTypeOfPersonVariableFilterInput.fromJson(
              (l$personVariables as Map<String, dynamic>));
    }
    if (data.containsKey('suscriptionTerritories')) {
      final l$suscriptionTerritories = data['suscriptionTerritories'];
      result$data['suscriptionTerritories'] = l$suscriptionTerritories == null
          ? null
          : Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput.fromJson(
              (l$suscriptionTerritories as Map<String, dynamic>));
    }
    if (data.containsKey('variableTypeID')) {
      final l$variableTypeID = data['variableTypeID'];
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : Input$ComparableInt64OperationFilterInput.fromJson(
              (l$variableTypeID as Map<String, dynamic>));
    }
    return Input$VariableTypeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AccessibilityOperationFilterInput? get accessibility =>
      (_$data['accessibility'] as Input$AccessibilityOperationFilterInput?);
  List<Input$VariableTypeFilterInput>? get and =>
      (_$data['and'] as List<Input$VariableTypeFilterInput>?);
  Input$ApplicationFilterInput? get application =>
      (_$data['application'] as Input$ApplicationFilterInput?);
  Input$ComparableInt64OperationFilterInput? get applicationID =>
      (_$data['applicationID'] as Input$ComparableInt64OperationFilterInput?);
  Input$StringOperationFilterInput? get calculationCode =>
      (_$data['calculationCode'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get conditionCode =>
      (_$data['conditionCode'] as Input$StringOperationFilterInput?);
  Input$DataTypeOperationFilterInput? get dataType =>
      (_$data['dataType'] as Input$DataTypeOperationFilterInput?);
  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);
  Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
      get destinationConditionDependencies => (_$data[
              'destinationConditionDependencies']
          as Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?);
  Input$EnumGroupFilterInput? get enumGroup =>
      (_$data['enumGroup'] as Input$EnumGroupFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get enumGroupID =>
      (_$data['enumGroupID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$VariableTypeFilterInput? get list =>
      (_$data['list'] as Input$VariableTypeFilterInput?);
  Input$ComparableNullableOfInt64OperationFilterInput? get listID =>
      (_$data['listID']
          as Input$ComparableNullableOfInt64OperationFilterInput?);
  Input$ListFilterInputTypeOfVariableTypeFilterInput? get listedVariableTypes =>
      (_$data['listedVariableTypes']
          as Input$ListFilterInputTypeOfVariableTypeFilterInput?);
  Input$ComparableNullableOfDateTimeOperationFilterInput?
      get modificationTime => (_$data['modificationTime']
          as Input$ComparableNullableOfDateTimeOperationFilterInput?);
  Input$ApplicationUserFilterInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserFilterInput?);
  Input$StringOperationFilterInput? get modifyingUserID =>
      (_$data['modifyingUserID'] as Input$StringOperationFilterInput?);
  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);
  List<Input$VariableTypeFilterInput>? get or =>
      (_$data['or'] as List<Input$VariableTypeFilterInput>?);
  Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
      get originConditionDependencies => (_$data['originConditionDependencies']
          as Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?);
  Input$ListFilterInputTypeOfPersonVariableFilterInput? get personVariables =>
      (_$data['personVariables']
          as Input$ListFilterInputTypeOfPersonVariableFilterInput?);
  Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
      get suscriptionTerritories => (_$data['suscriptionTerritories']
          as Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?);
  Input$ComparableInt64OperationFilterInput? get variableTypeID =>
      (_$data['variableTypeID'] as Input$ComparableInt64OperationFilterInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessibility')) {
      final l$accessibility = accessibility;
      result$data['accessibility'] = l$accessibility?.toJson();
    }
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID?.toJson();
    }
    if (_$data.containsKey('calculationCode')) {
      final l$calculationCode = calculationCode;
      result$data['calculationCode'] = l$calculationCode?.toJson();
    }
    if (_$data.containsKey('conditionCode')) {
      final l$conditionCode = conditionCode;
      result$data['conditionCode'] = l$conditionCode?.toJson();
    }
    if (_$data.containsKey('dataType')) {
      final l$dataType = dataType;
      result$data['dataType'] = l$dataType?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('destinationConditionDependencies')) {
      final l$destinationConditionDependencies =
          destinationConditionDependencies;
      result$data['destinationConditionDependencies'] =
          l$destinationConditionDependencies?.toJson();
    }
    if (_$data.containsKey('enumGroup')) {
      final l$enumGroup = enumGroup;
      result$data['enumGroup'] = l$enumGroup?.toJson();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID?.toJson();
    }
    if (_$data.containsKey('list')) {
      final l$list = list;
      result$data['list'] = l$list?.toJson();
    }
    if (_$data.containsKey('listID')) {
      final l$listID = listID;
      result$data['listID'] = l$listID?.toJson();
    }
    if (_$data.containsKey('listedVariableTypes')) {
      final l$listedVariableTypes = listedVariableTypes;
      result$data['listedVariableTypes'] = l$listedVariableTypes?.toJson();
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime?.toJson();
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('originConditionDependencies')) {
      final l$originConditionDependencies = originConditionDependencies;
      result$data['originConditionDependencies'] =
          l$originConditionDependencies?.toJson();
    }
    if (_$data.containsKey('personVariables')) {
      final l$personVariables = personVariables;
      result$data['personVariables'] = l$personVariables?.toJson();
    }
    if (_$data.containsKey('suscriptionTerritories')) {
      final l$suscriptionTerritories = suscriptionTerritories;
      result$data['suscriptionTerritories'] =
          l$suscriptionTerritories?.toJson();
    }
    if (_$data.containsKey('variableTypeID')) {
      final l$variableTypeID = variableTypeID;
      result$data['variableTypeID'] = l$variableTypeID?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$VariableTypeFilterInput<Input$VariableTypeFilterInput>
      get copyWith => CopyWith$Input$VariableTypeFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VariableTypeFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessibility = accessibility;
    final lOther$accessibility = other.accessibility;
    if (_$data.containsKey('accessibility') !=
        other._$data.containsKey('accessibility')) {
      return false;
    }
    if (l$accessibility != lOther$accessibility) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$calculationCode = calculationCode;
    final lOther$calculationCode = other.calculationCode;
    if (_$data.containsKey('calculationCode') !=
        other._$data.containsKey('calculationCode')) {
      return false;
    }
    if (l$calculationCode != lOther$calculationCode) {
      return false;
    }
    final l$conditionCode = conditionCode;
    final lOther$conditionCode = other.conditionCode;
    if (_$data.containsKey('conditionCode') !=
        other._$data.containsKey('conditionCode')) {
      return false;
    }
    if (l$conditionCode != lOther$conditionCode) {
      return false;
    }
    final l$dataType = dataType;
    final lOther$dataType = other.dataType;
    if (_$data.containsKey('dataType') !=
        other._$data.containsKey('dataType')) {
      return false;
    }
    if (l$dataType != lOther$dataType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$destinationConditionDependencies = destinationConditionDependencies;
    final lOther$destinationConditionDependencies =
        other.destinationConditionDependencies;
    if (_$data.containsKey('destinationConditionDependencies') !=
        other._$data.containsKey('destinationConditionDependencies')) {
      return false;
    }
    if (l$destinationConditionDependencies !=
        lOther$destinationConditionDependencies) {
      return false;
    }
    final l$enumGroup = enumGroup;
    final lOther$enumGroup = other.enumGroup;
    if (_$data.containsKey('enumGroup') !=
        other._$data.containsKey('enumGroup')) {
      return false;
    }
    if (l$enumGroup != lOther$enumGroup) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$list = list;
    final lOther$list = other.list;
    if (_$data.containsKey('list') != other._$data.containsKey('list')) {
      return false;
    }
    if (l$list != lOther$list) {
      return false;
    }
    final l$listID = listID;
    final lOther$listID = other.listID;
    if (_$data.containsKey('listID') != other._$data.containsKey('listID')) {
      return false;
    }
    if (l$listID != lOther$listID) {
      return false;
    }
    final l$listedVariableTypes = listedVariableTypes;
    final lOther$listedVariableTypes = other.listedVariableTypes;
    if (_$data.containsKey('listedVariableTypes') !=
        other._$data.containsKey('listedVariableTypes')) {
      return false;
    }
    if (l$listedVariableTypes != lOther$listedVariableTypes) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$originConditionDependencies = originConditionDependencies;
    final lOther$originConditionDependencies =
        other.originConditionDependencies;
    if (_$data.containsKey('originConditionDependencies') !=
        other._$data.containsKey('originConditionDependencies')) {
      return false;
    }
    if (l$originConditionDependencies != lOther$originConditionDependencies) {
      return false;
    }
    final l$personVariables = personVariables;
    final lOther$personVariables = other.personVariables;
    if (_$data.containsKey('personVariables') !=
        other._$data.containsKey('personVariables')) {
      return false;
    }
    if (l$personVariables != lOther$personVariables) {
      return false;
    }
    final l$suscriptionTerritories = suscriptionTerritories;
    final lOther$suscriptionTerritories = other.suscriptionTerritories;
    if (_$data.containsKey('suscriptionTerritories') !=
        other._$data.containsKey('suscriptionTerritories')) {
      return false;
    }
    if (l$suscriptionTerritories != lOther$suscriptionTerritories) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (_$data.containsKey('variableTypeID') !=
        other._$data.containsKey('variableTypeID')) {
      return false;
    }
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessibility = accessibility;
    final l$and = and;
    final l$application = application;
    final l$applicationID = applicationID;
    final l$calculationCode = calculationCode;
    final l$conditionCode = conditionCode;
    final l$dataType = dataType;
    final l$description = description;
    final l$destinationConditionDependencies = destinationConditionDependencies;
    final l$enumGroup = enumGroup;
    final l$enumGroupID = enumGroupID;
    final l$list = list;
    final l$listID = listID;
    final l$listedVariableTypes = listedVariableTypes;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$or = or;
    final l$originConditionDependencies = originConditionDependencies;
    final l$personVariables = personVariables;
    final l$suscriptionTerritories = suscriptionTerritories;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('accessibility') ? l$accessibility : const {},
      _$data.containsKey('and')
          ? l$and == null
              ? null
              : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('calculationCode') ? l$calculationCode : const {},
      _$data.containsKey('conditionCode') ? l$conditionCode : const {},
      _$data.containsKey('dataType') ? l$dataType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('destinationConditionDependencies')
          ? l$destinationConditionDependencies
          : const {},
      _$data.containsKey('enumGroup') ? l$enumGroup : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('list') ? l$list : const {},
      _$data.containsKey('listID') ? l$listID : const {},
      _$data.containsKey('listedVariableTypes')
          ? l$listedVariableTypes
          : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('or')
          ? l$or == null
              ? null
              : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('originConditionDependencies')
          ? l$originConditionDependencies
          : const {},
      _$data.containsKey('personVariables') ? l$personVariables : const {},
      _$data.containsKey('suscriptionTerritories')
          ? l$suscriptionTerritories
          : const {},
      _$data.containsKey('variableTypeID') ? l$variableTypeID : const {},
    ]);
  }
}

abstract class CopyWith$Input$VariableTypeFilterInput<TRes> {
  factory CopyWith$Input$VariableTypeFilterInput(
    Input$VariableTypeFilterInput instance,
    TRes Function(Input$VariableTypeFilterInput) then,
  ) = _CopyWithImpl$Input$VariableTypeFilterInput;

  factory CopyWith$Input$VariableTypeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VariableTypeFilterInput;

  TRes call({
    Input$AccessibilityOperationFilterInput? accessibility,
    List<Input$VariableTypeFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$StringOperationFilterInput? calculationCode,
    Input$StringOperationFilterInput? conditionCode,
    Input$DataTypeOperationFilterInput? dataType,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        destinationConditionDependencies,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$VariableTypeFilterInput? list,
    Input$ComparableNullableOfInt64OperationFilterInput? listID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? listedVariableTypes,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$VariableTypeFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        originConditionDependencies,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  });
  CopyWith$Input$AccessibilityOperationFilterInput<TRes> get accessibility;
  TRes and(
      Iterable<Input$VariableTypeFilterInput>? Function(
              Iterable<
                  CopyWith$Input$VariableTypeFilterInput<
                      Input$VariableTypeFilterInput>>?)
          _fn);
  CopyWith$Input$ApplicationFilterInput<TRes> get application;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID;
  CopyWith$Input$StringOperationFilterInput<TRes> get calculationCode;
  CopyWith$Input$StringOperationFilterInput<TRes> get conditionCode;
  CopyWith$Input$DataTypeOperationFilterInput<TRes> get dataType;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
      TRes> get destinationConditionDependencies;
  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID;
  CopyWith$Input$VariableTypeFilterInput<TRes> get list;
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes> get listID;
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get listedVariableTypes;
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime;
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser;
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  TRes or(
      Iterable<Input$VariableTypeFilterInput>? Function(
              Iterable<
                  CopyWith$Input$VariableTypeFilterInput<
                      Input$VariableTypeFilterInput>>?)
          _fn);
  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
      TRes> get originConditionDependencies;
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables;
  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories;
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID;
}

class _CopyWithImpl$Input$VariableTypeFilterInput<TRes>
    implements CopyWith$Input$VariableTypeFilterInput<TRes> {
  _CopyWithImpl$Input$VariableTypeFilterInput(
    this._instance,
    this._then,
  );

  final Input$VariableTypeFilterInput _instance;

  final TRes Function(Input$VariableTypeFilterInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessibility = _undefined,
    Object? and = _undefined,
    Object? application = _undefined,
    Object? applicationID = _undefined,
    Object? calculationCode = _undefined,
    Object? conditionCode = _undefined,
    Object? dataType = _undefined,
    Object? description = _undefined,
    Object? destinationConditionDependencies = _undefined,
    Object? enumGroup = _undefined,
    Object? enumGroupID = _undefined,
    Object? list = _undefined,
    Object? listID = _undefined,
    Object? listedVariableTypes = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? or = _undefined,
    Object? originConditionDependencies = _undefined,
    Object? personVariables = _undefined,
    Object? suscriptionTerritories = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$VariableTypeFilterInput._({
        ..._instance._$data,
        if (accessibility != _undefined)
          'accessibility':
              (accessibility as Input$AccessibilityOperationFilterInput?),
        if (and != _undefined)
          'and': (and as List<Input$VariableTypeFilterInput>?),
        if (application != _undefined)
          'application': (application as Input$ApplicationFilterInput?),
        if (applicationID != _undefined)
          'applicationID':
              (applicationID as Input$ComparableInt64OperationFilterInput?),
        if (calculationCode != _undefined)
          'calculationCode':
              (calculationCode as Input$StringOperationFilterInput?),
        if (conditionCode != _undefined)
          'conditionCode': (conditionCode as Input$StringOperationFilterInput?),
        if (dataType != _undefined)
          'dataType': (dataType as Input$DataTypeOperationFilterInput?),
        if (description != _undefined)
          'description': (description as Input$StringOperationFilterInput?),
        if (destinationConditionDependencies != _undefined)
          'destinationConditionDependencies': (destinationConditionDependencies
              as Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?),
        if (enumGroup != _undefined)
          'enumGroup': (enumGroup as Input$EnumGroupFilterInput?),
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID
              as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (list != _undefined)
          'list': (list as Input$VariableTypeFilterInput?),
        if (listID != _undefined)
          'listID':
              (listID as Input$ComparableNullableOfInt64OperationFilterInput?),
        if (listedVariableTypes != _undefined)
          'listedVariableTypes': (listedVariableTypes
              as Input$ListFilterInputTypeOfVariableTypeFilterInput?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime
              as Input$ComparableNullableOfDateTimeOperationFilterInput?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserFilterInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID':
              (modifyingUserID as Input$StringOperationFilterInput?),
        if (name != _undefined)
          'name': (name as Input$StringOperationFilterInput?),
        if (or != _undefined)
          'or': (or as List<Input$VariableTypeFilterInput>?),
        if (originConditionDependencies != _undefined)
          'originConditionDependencies': (originConditionDependencies
              as Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?),
        if (personVariables != _undefined)
          'personVariables': (personVariables
              as Input$ListFilterInputTypeOfPersonVariableFilterInput?),
        if (suscriptionTerritories != _undefined)
          'suscriptionTerritories': (suscriptionTerritories
              as Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?),
        if (variableTypeID != _undefined)
          'variableTypeID':
              (variableTypeID as Input$ComparableInt64OperationFilterInput?),
      }));
  CopyWith$Input$AccessibilityOperationFilterInput<TRes> get accessibility {
    final local$accessibility = _instance.accessibility;
    return local$accessibility == null
        ? CopyWith$Input$AccessibilityOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$AccessibilityOperationFilterInput(
            local$accessibility, (e) => call(accessibility: e));
  }

  TRes and(
          Iterable<Input$VariableTypeFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$VariableTypeFilterInput<
                          Input$VariableTypeFilterInput>>?)
              _fn) =>
      call(
          and: _fn(
              _instance.and?.map((e) => CopyWith$Input$VariableTypeFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ApplicationFilterInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationFilterInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID {
    final local$applicationID = _instance.applicationID;
    return local$applicationID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$applicationID, (e) => call(applicationID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get calculationCode {
    final local$calculationCode = _instance.calculationCode;
    return local$calculationCode == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$calculationCode, (e) => call(calculationCode: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get conditionCode {
    final local$conditionCode = _instance.conditionCode;
    return local$conditionCode == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$conditionCode, (e) => call(conditionCode: e));
  }

  CopyWith$Input$DataTypeOperationFilterInput<TRes> get dataType {
    final local$dataType = _instance.dataType;
    return local$dataType == null
        ? CopyWith$Input$DataTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DataTypeOperationFilterInput(
            local$dataType, (e) => call(dataType: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
      TRes> get destinationConditionDependencies {
    final local$destinationConditionDependencies =
        _instance.destinationConditionDependencies;
    return local$destinationConditionDependencies == null
        ? CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
            local$destinationConditionDependencies,
            (e) => call(destinationConditionDependencies: e));
  }

  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup {
    final local$enumGroup = _instance.enumGroup;
    return local$enumGroup == null
        ? CopyWith$Input$EnumGroupFilterInput.stub(_then(_instance))
        : CopyWith$Input$EnumGroupFilterInput(
            local$enumGroup, (e) => call(enumGroup: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID {
    final local$enumGroupID = _instance.enumGroupID;
    return local$enumGroupID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$enumGroupID, (e) => call(enumGroupID: e));
  }

  CopyWith$Input$VariableTypeFilterInput<TRes> get list {
    final local$list = _instance.list;
    return local$list == null
        ? CopyWith$Input$VariableTypeFilterInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeFilterInput(
            local$list, (e) => call(list: e));
  }

  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get listID {
    final local$listID = _instance.listID;
    return local$listID == null
        ? CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfInt64OperationFilterInput(
            local$listID, (e) => call(listID: e));
  }

  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get listedVariableTypes {
    final local$listedVariableTypes = _instance.listedVariableTypes;
    return local$listedVariableTypes == null
        ? CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput(
            local$listedVariableTypes, (e) => call(listedVariableTypes: e));
  }

  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime {
    final local$modificationTime = _instance.modificationTime;
    return local$modificationTime == null
        ? CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput(
            local$modificationTime, (e) => call(modificationTime: e));
  }

  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserFilterInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID {
    final local$modifyingUserID = _instance.modifyingUserID;
    return local$modifyingUserID == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$modifyingUserID, (e) => call(modifyingUserID: e));
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name, (e) => call(name: e));
  }

  TRes or(
          Iterable<Input$VariableTypeFilterInput>? Function(
                  Iterable<
                      CopyWith$Input$VariableTypeFilterInput<
                          Input$VariableTypeFilterInput>>?)
              _fn) =>
      call(
          or: _fn(
              _instance.or?.map((e) => CopyWith$Input$VariableTypeFilterInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
      TRes> get originConditionDependencies {
    final local$originConditionDependencies =
        _instance.originConditionDependencies;
    return local$originConditionDependencies == null
        ? CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput(
            local$originConditionDependencies,
            (e) => call(originConditionDependencies: e));
  }

  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables {
    final local$personVariables = _instance.personVariables;
    return local$personVariables == null
        ? CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput(
            local$personVariables, (e) => call(personVariables: e));
  }

  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories {
    final local$suscriptionTerritories = _instance.suscriptionTerritories;
    return local$suscriptionTerritories == null
        ? CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput
            .stub(_then(_instance))
        : CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput(
            local$suscriptionTerritories,
            (e) => call(suscriptionTerritories: e));
  }

  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID {
    final local$variableTypeID = _instance.variableTypeID;
    return local$variableTypeID == null
        ? CopyWith$Input$ComparableInt64OperationFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$ComparableInt64OperationFilterInput(
            local$variableTypeID, (e) => call(variableTypeID: e));
  }
}

class _CopyWithStubImpl$Input$VariableTypeFilterInput<TRes>
    implements CopyWith$Input$VariableTypeFilterInput<TRes> {
  _CopyWithStubImpl$Input$VariableTypeFilterInput(this._res);

  TRes _res;

  call({
    Input$AccessibilityOperationFilterInput? accessibility,
    List<Input$VariableTypeFilterInput>? and,
    Input$ApplicationFilterInput? application,
    Input$ComparableInt64OperationFilterInput? applicationID,
    Input$StringOperationFilterInput? calculationCode,
    Input$StringOperationFilterInput? conditionCode,
    Input$DataTypeOperationFilterInput? dataType,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        destinationConditionDependencies,
    Input$EnumGroupFilterInput? enumGroup,
    Input$ComparableNullableOfInt64OperationFilterInput? enumGroupID,
    Input$VariableTypeFilterInput? list,
    Input$ComparableNullableOfInt64OperationFilterInput? listID,
    Input$ListFilterInputTypeOfVariableTypeFilterInput? listedVariableTypes,
    Input$ComparableNullableOfDateTimeOperationFilterInput? modificationTime,
    Input$ApplicationUserFilterInput? modifyingUser,
    Input$StringOperationFilterInput? modifyingUserID,
    Input$StringOperationFilterInput? name,
    List<Input$VariableTypeFilterInput>? or,
    Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput?
        originConditionDependencies,
    Input$ListFilterInputTypeOfPersonVariableFilterInput? personVariables,
    Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput?
        suscriptionTerritories,
    Input$ComparableInt64OperationFilterInput? variableTypeID,
  }) =>
      _res;
  CopyWith$Input$AccessibilityOperationFilterInput<TRes> get accessibility =>
      CopyWith$Input$AccessibilityOperationFilterInput.stub(_res);
  and(_fn) => _res;
  CopyWith$Input$ApplicationFilterInput<TRes> get application =>
      CopyWith$Input$ApplicationFilterInput.stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get applicationID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get calculationCode =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get conditionCode =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$DataTypeOperationFilterInput<TRes> get dataType =>
      CopyWith$Input$DataTypeOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
          TRes>
      get destinationConditionDependencies =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
              .stub(_res);
  CopyWith$Input$EnumGroupFilterInput<TRes> get enumGroup =>
      CopyWith$Input$EnumGroupFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get enumGroupID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$VariableTypeFilterInput<TRes> get list =>
      CopyWith$Input$VariableTypeFilterInput.stub(_res);
  CopyWith$Input$ComparableNullableOfInt64OperationFilterInput<TRes>
      get listID =>
          CopyWith$Input$ComparableNullableOfInt64OperationFilterInput.stub(
              _res);
  CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput<TRes>
      get listedVariableTypes =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeFilterInput.stub(
              _res);
  CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput<TRes>
      get modificationTime =>
          CopyWith$Input$ComparableNullableOfDateTimeOperationFilterInput.stub(
              _res);
  CopyWith$Input$ApplicationUserFilterInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get modifyingUserID =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
  or(_fn) => _res;
  CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput<
          TRes>
      get originConditionDependencies =>
          CopyWith$Input$ListFilterInputTypeOfVariableTypeConditionDependencyFilterInput
              .stub(_res);
  CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput<TRes>
      get personVariables =>
          CopyWith$Input$ListFilterInputTypeOfPersonVariableFilterInput.stub(
              _res);
  CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput<TRes>
      get suscriptionTerritories =>
          CopyWith$Input$ListFilterInputTypeOfSuscriptionTerritoryFilterInput
              .stub(_res);
  CopyWith$Input$ComparableInt64OperationFilterInput<TRes> get variableTypeID =>
      CopyWith$Input$ComparableInt64OperationFilterInput.stub(_res);
}

class Input$VariableTypeSortInput {
  factory Input$VariableTypeSortInput({
    Enum$SortEnumType? accessibility,
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? calculationCode,
    Enum$SortEnumType? conditionCode,
    Enum$SortEnumType? dataType,
    Enum$SortEnumType? description,
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Input$VariableTypeSortInput? list,
    Enum$SortEnumType? listID,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? variableTypeID,
  }) =>
      Input$VariableTypeSortInput._({
        if (accessibility != null) r'accessibility': accessibility,
        if (application != null) r'application': application,
        if (applicationID != null) r'applicationID': applicationID,
        if (calculationCode != null) r'calculationCode': calculationCode,
        if (conditionCode != null) r'conditionCode': conditionCode,
        if (dataType != null) r'dataType': dataType,
        if (description != null) r'description': description,
        if (enumGroup != null) r'enumGroup': enumGroup,
        if (enumGroupID != null) r'enumGroupID': enumGroupID,
        if (list != null) r'list': list,
        if (listID != null) r'listID': listID,
        if (modificationTime != null) r'modificationTime': modificationTime,
        if (modifyingUser != null) r'modifyingUser': modifyingUser,
        if (modifyingUserID != null) r'modifyingUserID': modifyingUserID,
        if (name != null) r'name': name,
        if (variableTypeID != null) r'variableTypeID': variableTypeID,
      });

  Input$VariableTypeSortInput._(this._$data);

  factory Input$VariableTypeSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessibility')) {
      final l$accessibility = data['accessibility'];
      result$data['accessibility'] = l$accessibility == null
          ? null
          : fromJson$Enum$SortEnumType((l$accessibility as String));
    }
    if (data.containsKey('application')) {
      final l$application = data['application'];
      result$data['application'] = l$application == null
          ? null
          : Input$ApplicationSortInput.fromJson(
              (l$application as Map<String, dynamic>));
    }
    if (data.containsKey('applicationID')) {
      final l$applicationID = data['applicationID'];
      result$data['applicationID'] = l$applicationID == null
          ? null
          : fromJson$Enum$SortEnumType((l$applicationID as String));
    }
    if (data.containsKey('calculationCode')) {
      final l$calculationCode = data['calculationCode'];
      result$data['calculationCode'] = l$calculationCode == null
          ? null
          : fromJson$Enum$SortEnumType((l$calculationCode as String));
    }
    if (data.containsKey('conditionCode')) {
      final l$conditionCode = data['conditionCode'];
      result$data['conditionCode'] = l$conditionCode == null
          ? null
          : fromJson$Enum$SortEnumType((l$conditionCode as String));
    }
    if (data.containsKey('dataType')) {
      final l$dataType = data['dataType'];
      result$data['dataType'] = l$dataType == null
          ? null
          : fromJson$Enum$SortEnumType((l$dataType as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('enumGroup')) {
      final l$enumGroup = data['enumGroup'];
      result$data['enumGroup'] = l$enumGroup == null
          ? null
          : Input$EnumGroupSortInput.fromJson(
              (l$enumGroup as Map<String, dynamic>));
    }
    if (data.containsKey('enumGroupID')) {
      final l$enumGroupID = data['enumGroupID'];
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : fromJson$Enum$SortEnumType((l$enumGroupID as String));
    }
    if (data.containsKey('list')) {
      final l$list = data['list'];
      result$data['list'] = l$list == null
          ? null
          : Input$VariableTypeSortInput.fromJson(
              (l$list as Map<String, dynamic>));
    }
    if (data.containsKey('listID')) {
      final l$listID = data['listID'];
      result$data['listID'] = l$listID == null
          ? null
          : fromJson$Enum$SortEnumType((l$listID as String));
    }
    if (data.containsKey('modificationTime')) {
      final l$modificationTime = data['modificationTime'];
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$modificationTime as String));
    }
    if (data.containsKey('modifyingUser')) {
      final l$modifyingUser = data['modifyingUser'];
      result$data['modifyingUser'] = l$modifyingUser == null
          ? null
          : Input$ApplicationUserSortInput.fromJson(
              (l$modifyingUser as Map<String, dynamic>));
    }
    if (data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = data['modifyingUserID'];
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : fromJson$Enum$SortEnumType((l$modifyingUserID as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('variableTypeID')) {
      final l$variableTypeID = data['variableTypeID'];
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : fromJson$Enum$SortEnumType((l$variableTypeID as String));
    }
    return Input$VariableTypeSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get accessibility =>
      (_$data['accessibility'] as Enum$SortEnumType?);
  Input$ApplicationSortInput? get application =>
      (_$data['application'] as Input$ApplicationSortInput?);
  Enum$SortEnumType? get applicationID =>
      (_$data['applicationID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get calculationCode =>
      (_$data['calculationCode'] as Enum$SortEnumType?);
  Enum$SortEnumType? get conditionCode =>
      (_$data['conditionCode'] as Enum$SortEnumType?);
  Enum$SortEnumType? get dataType => (_$data['dataType'] as Enum$SortEnumType?);
  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);
  Input$EnumGroupSortInput? get enumGroup =>
      (_$data['enumGroup'] as Input$EnumGroupSortInput?);
  Enum$SortEnumType? get enumGroupID =>
      (_$data['enumGroupID'] as Enum$SortEnumType?);
  Input$VariableTypeSortInput? get list =>
      (_$data['list'] as Input$VariableTypeSortInput?);
  Enum$SortEnumType? get listID => (_$data['listID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get modificationTime =>
      (_$data['modificationTime'] as Enum$SortEnumType?);
  Input$ApplicationUserSortInput? get modifyingUser =>
      (_$data['modifyingUser'] as Input$ApplicationUserSortInput?);
  Enum$SortEnumType? get modifyingUserID =>
      (_$data['modifyingUserID'] as Enum$SortEnumType?);
  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);
  Enum$SortEnumType? get variableTypeID =>
      (_$data['variableTypeID'] as Enum$SortEnumType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessibility')) {
      final l$accessibility = accessibility;
      result$data['accessibility'] = l$accessibility == null
          ? null
          : toJson$Enum$SortEnumType(l$accessibility);
    }
    if (_$data.containsKey('application')) {
      final l$application = application;
      result$data['application'] = l$application?.toJson();
    }
    if (_$data.containsKey('applicationID')) {
      final l$applicationID = applicationID;
      result$data['applicationID'] = l$applicationID == null
          ? null
          : toJson$Enum$SortEnumType(l$applicationID);
    }
    if (_$data.containsKey('calculationCode')) {
      final l$calculationCode = calculationCode;
      result$data['calculationCode'] = l$calculationCode == null
          ? null
          : toJson$Enum$SortEnumType(l$calculationCode);
    }
    if (_$data.containsKey('conditionCode')) {
      final l$conditionCode = conditionCode;
      result$data['conditionCode'] = l$conditionCode == null
          ? null
          : toJson$Enum$SortEnumType(l$conditionCode);
    }
    if (_$data.containsKey('dataType')) {
      final l$dataType = dataType;
      result$data['dataType'] =
          l$dataType == null ? null : toJson$Enum$SortEnumType(l$dataType);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('enumGroup')) {
      final l$enumGroup = enumGroup;
      result$data['enumGroup'] = l$enumGroup?.toJson();
    }
    if (_$data.containsKey('enumGroupID')) {
      final l$enumGroupID = enumGroupID;
      result$data['enumGroupID'] = l$enumGroupID == null
          ? null
          : toJson$Enum$SortEnumType(l$enumGroupID);
    }
    if (_$data.containsKey('list')) {
      final l$list = list;
      result$data['list'] = l$list?.toJson();
    }
    if (_$data.containsKey('listID')) {
      final l$listID = listID;
      result$data['listID'] =
          l$listID == null ? null : toJson$Enum$SortEnumType(l$listID);
    }
    if (_$data.containsKey('modificationTime')) {
      final l$modificationTime = modificationTime;
      result$data['modificationTime'] = l$modificationTime == null
          ? null
          : toJson$Enum$SortEnumType(l$modificationTime);
    }
    if (_$data.containsKey('modifyingUser')) {
      final l$modifyingUser = modifyingUser;
      result$data['modifyingUser'] = l$modifyingUser?.toJson();
    }
    if (_$data.containsKey('modifyingUserID')) {
      final l$modifyingUserID = modifyingUserID;
      result$data['modifyingUserID'] = l$modifyingUserID == null
          ? null
          : toJson$Enum$SortEnumType(l$modifyingUserID);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('variableTypeID')) {
      final l$variableTypeID = variableTypeID;
      result$data['variableTypeID'] = l$variableTypeID == null
          ? null
          : toJson$Enum$SortEnumType(l$variableTypeID);
    }
    return result$data;
  }

  CopyWith$Input$VariableTypeSortInput<Input$VariableTypeSortInput>
      get copyWith => CopyWith$Input$VariableTypeSortInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VariableTypeSortInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessibility = accessibility;
    final lOther$accessibility = other.accessibility;
    if (_$data.containsKey('accessibility') !=
        other._$data.containsKey('accessibility')) {
      return false;
    }
    if (l$accessibility != lOther$accessibility) {
      return false;
    }
    final l$application = application;
    final lOther$application = other.application;
    if (_$data.containsKey('application') !=
        other._$data.containsKey('application')) {
      return false;
    }
    if (l$application != lOther$application) {
      return false;
    }
    final l$applicationID = applicationID;
    final lOther$applicationID = other.applicationID;
    if (_$data.containsKey('applicationID') !=
        other._$data.containsKey('applicationID')) {
      return false;
    }
    if (l$applicationID != lOther$applicationID) {
      return false;
    }
    final l$calculationCode = calculationCode;
    final lOther$calculationCode = other.calculationCode;
    if (_$data.containsKey('calculationCode') !=
        other._$data.containsKey('calculationCode')) {
      return false;
    }
    if (l$calculationCode != lOther$calculationCode) {
      return false;
    }
    final l$conditionCode = conditionCode;
    final lOther$conditionCode = other.conditionCode;
    if (_$data.containsKey('conditionCode') !=
        other._$data.containsKey('conditionCode')) {
      return false;
    }
    if (l$conditionCode != lOther$conditionCode) {
      return false;
    }
    final l$dataType = dataType;
    final lOther$dataType = other.dataType;
    if (_$data.containsKey('dataType') !=
        other._$data.containsKey('dataType')) {
      return false;
    }
    if (l$dataType != lOther$dataType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$enumGroup = enumGroup;
    final lOther$enumGroup = other.enumGroup;
    if (_$data.containsKey('enumGroup') !=
        other._$data.containsKey('enumGroup')) {
      return false;
    }
    if (l$enumGroup != lOther$enumGroup) {
      return false;
    }
    final l$enumGroupID = enumGroupID;
    final lOther$enumGroupID = other.enumGroupID;
    if (_$data.containsKey('enumGroupID') !=
        other._$data.containsKey('enumGroupID')) {
      return false;
    }
    if (l$enumGroupID != lOther$enumGroupID) {
      return false;
    }
    final l$list = list;
    final lOther$list = other.list;
    if (_$data.containsKey('list') != other._$data.containsKey('list')) {
      return false;
    }
    if (l$list != lOther$list) {
      return false;
    }
    final l$listID = listID;
    final lOther$listID = other.listID;
    if (_$data.containsKey('listID') != other._$data.containsKey('listID')) {
      return false;
    }
    if (l$listID != lOther$listID) {
      return false;
    }
    final l$modificationTime = modificationTime;
    final lOther$modificationTime = other.modificationTime;
    if (_$data.containsKey('modificationTime') !=
        other._$data.containsKey('modificationTime')) {
      return false;
    }
    if (l$modificationTime != lOther$modificationTime) {
      return false;
    }
    final l$modifyingUser = modifyingUser;
    final lOther$modifyingUser = other.modifyingUser;
    if (_$data.containsKey('modifyingUser') !=
        other._$data.containsKey('modifyingUser')) {
      return false;
    }
    if (l$modifyingUser != lOther$modifyingUser) {
      return false;
    }
    final l$modifyingUserID = modifyingUserID;
    final lOther$modifyingUserID = other.modifyingUserID;
    if (_$data.containsKey('modifyingUserID') !=
        other._$data.containsKey('modifyingUserID')) {
      return false;
    }
    if (l$modifyingUserID != lOther$modifyingUserID) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$variableTypeID = variableTypeID;
    final lOther$variableTypeID = other.variableTypeID;
    if (_$data.containsKey('variableTypeID') !=
        other._$data.containsKey('variableTypeID')) {
      return false;
    }
    if (l$variableTypeID != lOther$variableTypeID) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessibility = accessibility;
    final l$application = application;
    final l$applicationID = applicationID;
    final l$calculationCode = calculationCode;
    final l$conditionCode = conditionCode;
    final l$dataType = dataType;
    final l$description = description;
    final l$enumGroup = enumGroup;
    final l$enumGroupID = enumGroupID;
    final l$list = list;
    final l$listID = listID;
    final l$modificationTime = modificationTime;
    final l$modifyingUser = modifyingUser;
    final l$modifyingUserID = modifyingUserID;
    final l$name = name;
    final l$variableTypeID = variableTypeID;
    return Object.hashAll([
      _$data.containsKey('accessibility') ? l$accessibility : const {},
      _$data.containsKey('application') ? l$application : const {},
      _$data.containsKey('applicationID') ? l$applicationID : const {},
      _$data.containsKey('calculationCode') ? l$calculationCode : const {},
      _$data.containsKey('conditionCode') ? l$conditionCode : const {},
      _$data.containsKey('dataType') ? l$dataType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('enumGroup') ? l$enumGroup : const {},
      _$data.containsKey('enumGroupID') ? l$enumGroupID : const {},
      _$data.containsKey('list') ? l$list : const {},
      _$data.containsKey('listID') ? l$listID : const {},
      _$data.containsKey('modificationTime') ? l$modificationTime : const {},
      _$data.containsKey('modifyingUser') ? l$modifyingUser : const {},
      _$data.containsKey('modifyingUserID') ? l$modifyingUserID : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('variableTypeID') ? l$variableTypeID : const {},
    ]);
  }
}

abstract class CopyWith$Input$VariableTypeSortInput<TRes> {
  factory CopyWith$Input$VariableTypeSortInput(
    Input$VariableTypeSortInput instance,
    TRes Function(Input$VariableTypeSortInput) then,
  ) = _CopyWithImpl$Input$VariableTypeSortInput;

  factory CopyWith$Input$VariableTypeSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VariableTypeSortInput;

  TRes call({
    Enum$SortEnumType? accessibility,
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? calculationCode,
    Enum$SortEnumType? conditionCode,
    Enum$SortEnumType? dataType,
    Enum$SortEnumType? description,
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Input$VariableTypeSortInput? list,
    Enum$SortEnumType? listID,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? variableTypeID,
  });
  CopyWith$Input$ApplicationSortInput<TRes> get application;
  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup;
  CopyWith$Input$VariableTypeSortInput<TRes> get list;
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser;
}

class _CopyWithImpl$Input$VariableTypeSortInput<TRes>
    implements CopyWith$Input$VariableTypeSortInput<TRes> {
  _CopyWithImpl$Input$VariableTypeSortInput(
    this._instance,
    this._then,
  );

  final Input$VariableTypeSortInput _instance;

  final TRes Function(Input$VariableTypeSortInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessibility = _undefined,
    Object? application = _undefined,
    Object? applicationID = _undefined,
    Object? calculationCode = _undefined,
    Object? conditionCode = _undefined,
    Object? dataType = _undefined,
    Object? description = _undefined,
    Object? enumGroup = _undefined,
    Object? enumGroupID = _undefined,
    Object? list = _undefined,
    Object? listID = _undefined,
    Object? modificationTime = _undefined,
    Object? modifyingUser = _undefined,
    Object? modifyingUserID = _undefined,
    Object? name = _undefined,
    Object? variableTypeID = _undefined,
  }) =>
      _then(Input$VariableTypeSortInput._({
        ..._instance._$data,
        if (accessibility != _undefined)
          'accessibility': (accessibility as Enum$SortEnumType?),
        if (application != _undefined)
          'application': (application as Input$ApplicationSortInput?),
        if (applicationID != _undefined)
          'applicationID': (applicationID as Enum$SortEnumType?),
        if (calculationCode != _undefined)
          'calculationCode': (calculationCode as Enum$SortEnumType?),
        if (conditionCode != _undefined)
          'conditionCode': (conditionCode as Enum$SortEnumType?),
        if (dataType != _undefined)
          'dataType': (dataType as Enum$SortEnumType?),
        if (description != _undefined)
          'description': (description as Enum$SortEnumType?),
        if (enumGroup != _undefined)
          'enumGroup': (enumGroup as Input$EnumGroupSortInput?),
        if (enumGroupID != _undefined)
          'enumGroupID': (enumGroupID as Enum$SortEnumType?),
        if (list != _undefined) 'list': (list as Input$VariableTypeSortInput?),
        if (listID != _undefined) 'listID': (listID as Enum$SortEnumType?),
        if (modificationTime != _undefined)
          'modificationTime': (modificationTime as Enum$SortEnumType?),
        if (modifyingUser != _undefined)
          'modifyingUser': (modifyingUser as Input$ApplicationUserSortInput?),
        if (modifyingUserID != _undefined)
          'modifyingUserID': (modifyingUserID as Enum$SortEnumType?),
        if (name != _undefined) 'name': (name as Enum$SortEnumType?),
        if (variableTypeID != _undefined)
          'variableTypeID': (variableTypeID as Enum$SortEnumType?),
      }));
  CopyWith$Input$ApplicationSortInput<TRes> get application {
    final local$application = _instance.application;
    return local$application == null
        ? CopyWith$Input$ApplicationSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationSortInput(
            local$application, (e) => call(application: e));
  }

  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup {
    final local$enumGroup = _instance.enumGroup;
    return local$enumGroup == null
        ? CopyWith$Input$EnumGroupSortInput.stub(_then(_instance))
        : CopyWith$Input$EnumGroupSortInput(
            local$enumGroup, (e) => call(enumGroup: e));
  }

  CopyWith$Input$VariableTypeSortInput<TRes> get list {
    final local$list = _instance.list;
    return local$list == null
        ? CopyWith$Input$VariableTypeSortInput.stub(_then(_instance))
        : CopyWith$Input$VariableTypeSortInput(
            local$list, (e) => call(list: e));
  }

  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser {
    final local$modifyingUser = _instance.modifyingUser;
    return local$modifyingUser == null
        ? CopyWith$Input$ApplicationUserSortInput.stub(_then(_instance))
        : CopyWith$Input$ApplicationUserSortInput(
            local$modifyingUser, (e) => call(modifyingUser: e));
  }
}

class _CopyWithStubImpl$Input$VariableTypeSortInput<TRes>
    implements CopyWith$Input$VariableTypeSortInput<TRes> {
  _CopyWithStubImpl$Input$VariableTypeSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? accessibility,
    Input$ApplicationSortInput? application,
    Enum$SortEnumType? applicationID,
    Enum$SortEnumType? calculationCode,
    Enum$SortEnumType? conditionCode,
    Enum$SortEnumType? dataType,
    Enum$SortEnumType? description,
    Input$EnumGroupSortInput? enumGroup,
    Enum$SortEnumType? enumGroupID,
    Input$VariableTypeSortInput? list,
    Enum$SortEnumType? listID,
    Enum$SortEnumType? modificationTime,
    Input$ApplicationUserSortInput? modifyingUser,
    Enum$SortEnumType? modifyingUserID,
    Enum$SortEnumType? name,
    Enum$SortEnumType? variableTypeID,
  }) =>
      _res;
  CopyWith$Input$ApplicationSortInput<TRes> get application =>
      CopyWith$Input$ApplicationSortInput.stub(_res);
  CopyWith$Input$EnumGroupSortInput<TRes> get enumGroup =>
      CopyWith$Input$EnumGroupSortInput.stub(_res);
  CopyWith$Input$VariableTypeSortInput<TRes> get list =>
      CopyWith$Input$VariableTypeSortInput.stub(_res);
  CopyWith$Input$ApplicationUserSortInput<TRes> get modifyingUser =>
      CopyWith$Input$ApplicationUserSortInput.stub(_res);
}

enum Enum$Accessibility { PRIVATE, PUBLIC, SUPERVISOR, $unknown }

String toJson$Enum$Accessibility(Enum$Accessibility e) {
  switch (e) {
    case Enum$Accessibility.PRIVATE:
      return r'PRIVATE';
    case Enum$Accessibility.PUBLIC:
      return r'PUBLIC';
    case Enum$Accessibility.SUPERVISOR:
      return r'SUPERVISOR';
    case Enum$Accessibility.$unknown:
      return r'$unknown';
  }
}

Enum$Accessibility fromJson$Enum$Accessibility(String value) {
  switch (value) {
    case r'PRIVATE':
      return Enum$Accessibility.PRIVATE;
    case r'PUBLIC':
      return Enum$Accessibility.PUBLIC;
    case r'SUPERVISOR':
      return Enum$Accessibility.SUPERVISOR;
    default:
      return Enum$Accessibility.$unknown;
  }
}

enum Enum$CohabitantType { BIOLOGICAL, NON_BIOLOGICAL, $unknown }

String toJson$Enum$CohabitantType(Enum$CohabitantType e) {
  switch (e) {
    case Enum$CohabitantType.BIOLOGICAL:
      return r'BIOLOGICAL';
    case Enum$CohabitantType.NON_BIOLOGICAL:
      return r'NON_BIOLOGICAL';
    case Enum$CohabitantType.$unknown:
      return r'$unknown';
  }
}

Enum$CohabitantType fromJson$Enum$CohabitantType(String value) {
  switch (value) {
    case r'BIOLOGICAL':
      return Enum$CohabitantType.BIOLOGICAL;
    case r'NON_BIOLOGICAL':
      return Enum$CohabitantType.NON_BIOLOGICAL;
    default:
      return Enum$CohabitantType.$unknown;
  }
}

enum Enum$DataType {
  BOOL,
  CALCULATED,
  DATE_TIME,
  DECIMAL,
  DOUBLE,
  ENUM,
  FILE,
  LIST,
  LONG,
  NONE,
  PERSON,
  RELATIVE_LOCATION,
  STRING,
  SUSCRIPTION,
  $unknown
}

String toJson$Enum$DataType(Enum$DataType e) {
  switch (e) {
    case Enum$DataType.BOOL:
      return r'BOOL';
    case Enum$DataType.CALCULATED:
      return r'CALCULATED';
    case Enum$DataType.DATE_TIME:
      return r'DATE_TIME';
    case Enum$DataType.DECIMAL:
      return r'DECIMAL';
    case Enum$DataType.DOUBLE:
      return r'DOUBLE';
    case Enum$DataType.ENUM:
      return r'ENUM';
    case Enum$DataType.FILE:
      return r'FILE';
    case Enum$DataType.LIST:
      return r'LIST';
    case Enum$DataType.LONG:
      return r'LONG';
    case Enum$DataType.NONE:
      return r'NONE';
    case Enum$DataType.PERSON:
      return r'PERSON';
    case Enum$DataType.RELATIVE_LOCATION:
      return r'RELATIVE_LOCATION';
    case Enum$DataType.STRING:
      return r'STRING';
    case Enum$DataType.SUSCRIPTION:
      return r'SUSCRIPTION';
    case Enum$DataType.$unknown:
      return r'$unknown';
  }
}

Enum$DataType fromJson$Enum$DataType(String value) {
  switch (value) {
    case r'BOOL':
      return Enum$DataType.BOOL;
    case r'CALCULATED':
      return Enum$DataType.CALCULATED;
    case r'DATE_TIME':
      return Enum$DataType.DATE_TIME;
    case r'DECIMAL':
      return Enum$DataType.DECIMAL;
    case r'DOUBLE':
      return Enum$DataType.DOUBLE;
    case r'ENUM':
      return Enum$DataType.ENUM;
    case r'FILE':
      return Enum$DataType.FILE;
    case r'LIST':
      return Enum$DataType.LIST;
    case r'LONG':
      return Enum$DataType.LONG;
    case r'NONE':
      return Enum$DataType.NONE;
    case r'PERSON':
      return Enum$DataType.PERSON;
    case r'RELATIVE_LOCATION':
      return Enum$DataType.RELATIVE_LOCATION;
    case r'STRING':
      return Enum$DataType.STRING;
    case r'SUSCRIPTION':
      return Enum$DataType.SUSCRIPTION;
    default:
      return Enum$DataType.$unknown;
  }
}

enum Enum$MarkerMode { APP_CENTRIC, ATTENTION, GENERAL, USER_CENTRIC, $unknown }

String toJson$Enum$MarkerMode(Enum$MarkerMode e) {
  switch (e) {
    case Enum$MarkerMode.APP_CENTRIC:
      return r'APP_CENTRIC';
    case Enum$MarkerMode.ATTENTION:
      return r'ATTENTION';
    case Enum$MarkerMode.GENERAL:
      return r'GENERAL';
    case Enum$MarkerMode.USER_CENTRIC:
      return r'USER_CENTRIC';
    case Enum$MarkerMode.$unknown:
      return r'$unknown';
  }
}

Enum$MarkerMode fromJson$Enum$MarkerMode(String value) {
  switch (value) {
    case r'APP_CENTRIC':
      return Enum$MarkerMode.APP_CENTRIC;
    case r'ATTENTION':
      return Enum$MarkerMode.ATTENTION;
    case r'GENERAL':
      return Enum$MarkerMode.GENERAL;
    case r'USER_CENTRIC':
      return Enum$MarkerMode.USER_CENTRIC;
    default:
      return Enum$MarkerMode.$unknown;
  }
}

enum Enum$Permission {
  APPLICATION_CREATION,
  APPLICATION_DELETION,
  APPLICATION_MODIFICATION,
  AREA_CREATION,
  AREA_DELETION,
  AREA_MODIFICATION,
  BRANCH_CREATION,
  BRANCH_DELETION,
  BRANCH_GROUP_REQUEST,
  BRANCH_MODIFICATION,
  BRANCH_TERRITORY_CREATION,
  BRANCH_TERRITORY_DELETION,
  BRANCH_TERRITORY_MODIFICATION,
  COHABITANT_CREATION,
  COHABITANT_DELETION,
  COHABITANT_MODIFICATION,
  FULL_GROUP_QUERY,
  FULL_INDIVIDUAL_REQUEST,
  FULL_USER_MANAGEMENT,
  INDIVIDUAL_REQUEST,
  MUNICIPALITY_CREATION,
  MUNICIPALITY_DELETION,
  MUNICIPALITY_MODIFICATION,
  NO_EVALUATION,
  NO_SESSION,
  PERSON_CREATION,
  PERSON_DELETION,
  PERSON_MODIFICATION,
  PERSON_STATUS_CREATION,
  PERSON_STATUS_DELETION,
  PERSON_STATUS_MODIFICATION,
  PERSON_VARIABLE_CREATION,
  PERSON_VARIABLE_DELETION,
  PERSON_VARIABLE_FULL_INDIVIDUAL_CREATION,
  PERSON_VARIABLE_FULL_INDIVIDUAL_DELETION,
  PERSON_VARIABLE_FULL_INDIVIDUAL_MODIFICATION,
  PERSON_VARIABLE_INDIVIDUAL_CREATION,
  PERSON_VARIABLE_INDIVIDUAL_DELETION,
  PERSON_VARIABLE_INDIVIDUAL_MODIFICATION,
  PERSON_VARIABLE_MODIFICATION,
  PROVINCE_CREATION,
  PROVINCE_DELETION,
  PROVINCE_MODIFICATION,
  QUERY_APROVAL,
  QUERY_INDEX,
  RECORD_CREATION,
  ROLE_CREATION,
  ROLE_DELETION,
  ROLE_MODIFICATION,
  ROLE_PERMISSION_CREATION,
  ROLE_PERMISSION_DELETION,
  ROLE_PERMISSION_MODIFICATION,
  SUBSCRIPTION_DELETION,
  SUBSCRIPTION_MODIFICATION,
  SUBSCRIPTION_READ,
  SUBSCRIPTION_TERRITORY_DELETION,
  SUBSCRIPTION_TERRITORY_MODIFICATION,
  SUBSRIPTION_CREATION,
  SUBSRIPTION_TERRITORY_CREATION,
  TERRITORY_CREATION,
  TERRITORY_DELETION,
  TERRITORY_MEMBER_SUPERVISION,
  TERRITORY_MODIFICATION,
  TERRITORY_ROLE_CREATION,
  TERRITORY_ROLE_DELETION,
  TERRITORY_ROLE_MODIFICATION,
  USER_MANAGEMENT,
  USER_TERRITORY_CREATION,
  USER_TERRITORY_DELETION,
  USER_TERRITORY_MODIFICATION,
  VARIABLE_TYPE_CREATION,
  VARIABLE_TYPE_DELETION,
  VARIABLE_TYPE_MODIFICATION,
  $unknown
}

String toJson$Enum$Permission(Enum$Permission e) {
  switch (e) {
    case Enum$Permission.APPLICATION_CREATION:
      return r'APPLICATION_CREATION';
    case Enum$Permission.APPLICATION_DELETION:
      return r'APPLICATION_DELETION';
    case Enum$Permission.APPLICATION_MODIFICATION:
      return r'APPLICATION_MODIFICATION';
    case Enum$Permission.AREA_CREATION:
      return r'AREA_CREATION';
    case Enum$Permission.AREA_DELETION:
      return r'AREA_DELETION';
    case Enum$Permission.AREA_MODIFICATION:
      return r'AREA_MODIFICATION';
    case Enum$Permission.BRANCH_CREATION:
      return r'BRANCH_CREATION';
    case Enum$Permission.BRANCH_DELETION:
      return r'BRANCH_DELETION';
    case Enum$Permission.BRANCH_GROUP_REQUEST:
      return r'BRANCH_GROUP_REQUEST';
    case Enum$Permission.BRANCH_MODIFICATION:
      return r'BRANCH_MODIFICATION';
    case Enum$Permission.BRANCH_TERRITORY_CREATION:
      return r'BRANCH_TERRITORY_CREATION';
    case Enum$Permission.BRANCH_TERRITORY_DELETION:
      return r'BRANCH_TERRITORY_DELETION';
    case Enum$Permission.BRANCH_TERRITORY_MODIFICATION:
      return r'BRANCH_TERRITORY_MODIFICATION';
    case Enum$Permission.COHABITANT_CREATION:
      return r'COHABITANT_CREATION';
    case Enum$Permission.COHABITANT_DELETION:
      return r'COHABITANT_DELETION';
    case Enum$Permission.COHABITANT_MODIFICATION:
      return r'COHABITANT_MODIFICATION';
    case Enum$Permission.FULL_GROUP_QUERY:
      return r'FULL_GROUP_QUERY';
    case Enum$Permission.FULL_INDIVIDUAL_REQUEST:
      return r'FULL_INDIVIDUAL_REQUEST';
    case Enum$Permission.FULL_USER_MANAGEMENT:
      return r'FULL_USER_MANAGEMENT';
    case Enum$Permission.INDIVIDUAL_REQUEST:
      return r'INDIVIDUAL_REQUEST';
    case Enum$Permission.MUNICIPALITY_CREATION:
      return r'MUNICIPALITY_CREATION';
    case Enum$Permission.MUNICIPALITY_DELETION:
      return r'MUNICIPALITY_DELETION';
    case Enum$Permission.MUNICIPALITY_MODIFICATION:
      return r'MUNICIPALITY_MODIFICATION';
    case Enum$Permission.NO_EVALUATION:
      return r'NO_EVALUATION';
    case Enum$Permission.NO_SESSION:
      return r'NO_SESSION';
    case Enum$Permission.PERSON_CREATION:
      return r'PERSON_CREATION';
    case Enum$Permission.PERSON_DELETION:
      return r'PERSON_DELETION';
    case Enum$Permission.PERSON_MODIFICATION:
      return r'PERSON_MODIFICATION';
    case Enum$Permission.PERSON_STATUS_CREATION:
      return r'PERSON_STATUS_CREATION';
    case Enum$Permission.PERSON_STATUS_DELETION:
      return r'PERSON_STATUS_DELETION';
    case Enum$Permission.PERSON_STATUS_MODIFICATION:
      return r'PERSON_STATUS_MODIFICATION';
    case Enum$Permission.PERSON_VARIABLE_CREATION:
      return r'PERSON_VARIABLE_CREATION';
    case Enum$Permission.PERSON_VARIABLE_DELETION:
      return r'PERSON_VARIABLE_DELETION';
    case Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_CREATION:
      return r'PERSON_VARIABLE_FULL_INDIVIDUAL_CREATION';
    case Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_DELETION:
      return r'PERSON_VARIABLE_FULL_INDIVIDUAL_DELETION';
    case Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_MODIFICATION:
      return r'PERSON_VARIABLE_FULL_INDIVIDUAL_MODIFICATION';
    case Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_CREATION:
      return r'PERSON_VARIABLE_INDIVIDUAL_CREATION';
    case Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_DELETION:
      return r'PERSON_VARIABLE_INDIVIDUAL_DELETION';
    case Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_MODIFICATION:
      return r'PERSON_VARIABLE_INDIVIDUAL_MODIFICATION';
    case Enum$Permission.PERSON_VARIABLE_MODIFICATION:
      return r'PERSON_VARIABLE_MODIFICATION';
    case Enum$Permission.PROVINCE_CREATION:
      return r'PROVINCE_CREATION';
    case Enum$Permission.PROVINCE_DELETION:
      return r'PROVINCE_DELETION';
    case Enum$Permission.PROVINCE_MODIFICATION:
      return r'PROVINCE_MODIFICATION';
    case Enum$Permission.QUERY_APROVAL:
      return r'QUERY_APROVAL';
    case Enum$Permission.QUERY_INDEX:
      return r'QUERY_INDEX';
    case Enum$Permission.RECORD_CREATION:
      return r'RECORD_CREATION';
    case Enum$Permission.ROLE_CREATION:
      return r'ROLE_CREATION';
    case Enum$Permission.ROLE_DELETION:
      return r'ROLE_DELETION';
    case Enum$Permission.ROLE_MODIFICATION:
      return r'ROLE_MODIFICATION';
    case Enum$Permission.ROLE_PERMISSION_CREATION:
      return r'ROLE_PERMISSION_CREATION';
    case Enum$Permission.ROLE_PERMISSION_DELETION:
      return r'ROLE_PERMISSION_DELETION';
    case Enum$Permission.ROLE_PERMISSION_MODIFICATION:
      return r'ROLE_PERMISSION_MODIFICATION';
    case Enum$Permission.SUBSCRIPTION_DELETION:
      return r'SUBSCRIPTION_DELETION';
    case Enum$Permission.SUBSCRIPTION_MODIFICATION:
      return r'SUBSCRIPTION_MODIFICATION';
    case Enum$Permission.SUBSCRIPTION_READ:
      return r'SUBSCRIPTION_READ';
    case Enum$Permission.SUBSCRIPTION_TERRITORY_DELETION:
      return r'SUBSCRIPTION_TERRITORY_DELETION';
    case Enum$Permission.SUBSCRIPTION_TERRITORY_MODIFICATION:
      return r'SUBSCRIPTION_TERRITORY_MODIFICATION';
    case Enum$Permission.SUBSRIPTION_CREATION:
      return r'SUBSRIPTION_CREATION';
    case Enum$Permission.SUBSRIPTION_TERRITORY_CREATION:
      return r'SUBSRIPTION_TERRITORY_CREATION';
    case Enum$Permission.TERRITORY_CREATION:
      return r'TERRITORY_CREATION';
    case Enum$Permission.TERRITORY_DELETION:
      return r'TERRITORY_DELETION';
    case Enum$Permission.TERRITORY_MEMBER_SUPERVISION:
      return r'TERRITORY_MEMBER_SUPERVISION';
    case Enum$Permission.TERRITORY_MODIFICATION:
      return r'TERRITORY_MODIFICATION';
    case Enum$Permission.TERRITORY_ROLE_CREATION:
      return r'TERRITORY_ROLE_CREATION';
    case Enum$Permission.TERRITORY_ROLE_DELETION:
      return r'TERRITORY_ROLE_DELETION';
    case Enum$Permission.TERRITORY_ROLE_MODIFICATION:
      return r'TERRITORY_ROLE_MODIFICATION';
    case Enum$Permission.USER_MANAGEMENT:
      return r'USER_MANAGEMENT';
    case Enum$Permission.USER_TERRITORY_CREATION:
      return r'USER_TERRITORY_CREATION';
    case Enum$Permission.USER_TERRITORY_DELETION:
      return r'USER_TERRITORY_DELETION';
    case Enum$Permission.USER_TERRITORY_MODIFICATION:
      return r'USER_TERRITORY_MODIFICATION';
    case Enum$Permission.VARIABLE_TYPE_CREATION:
      return r'VARIABLE_TYPE_CREATION';
    case Enum$Permission.VARIABLE_TYPE_DELETION:
      return r'VARIABLE_TYPE_DELETION';
    case Enum$Permission.VARIABLE_TYPE_MODIFICATION:
      return r'VARIABLE_TYPE_MODIFICATION';
    case Enum$Permission.$unknown:
      return r'$unknown';
  }
}

Enum$Permission fromJson$Enum$Permission(String value) {
  switch (value) {
    case r'APPLICATION_CREATION':
      return Enum$Permission.APPLICATION_CREATION;
    case r'APPLICATION_DELETION':
      return Enum$Permission.APPLICATION_DELETION;
    case r'APPLICATION_MODIFICATION':
      return Enum$Permission.APPLICATION_MODIFICATION;
    case r'AREA_CREATION':
      return Enum$Permission.AREA_CREATION;
    case r'AREA_DELETION':
      return Enum$Permission.AREA_DELETION;
    case r'AREA_MODIFICATION':
      return Enum$Permission.AREA_MODIFICATION;
    case r'BRANCH_CREATION':
      return Enum$Permission.BRANCH_CREATION;
    case r'BRANCH_DELETION':
      return Enum$Permission.BRANCH_DELETION;
    case r'BRANCH_GROUP_REQUEST':
      return Enum$Permission.BRANCH_GROUP_REQUEST;
    case r'BRANCH_MODIFICATION':
      return Enum$Permission.BRANCH_MODIFICATION;
    case r'BRANCH_TERRITORY_CREATION':
      return Enum$Permission.BRANCH_TERRITORY_CREATION;
    case r'BRANCH_TERRITORY_DELETION':
      return Enum$Permission.BRANCH_TERRITORY_DELETION;
    case r'BRANCH_TERRITORY_MODIFICATION':
      return Enum$Permission.BRANCH_TERRITORY_MODIFICATION;
    case r'COHABITANT_CREATION':
      return Enum$Permission.COHABITANT_CREATION;
    case r'COHABITANT_DELETION':
      return Enum$Permission.COHABITANT_DELETION;
    case r'COHABITANT_MODIFICATION':
      return Enum$Permission.COHABITANT_MODIFICATION;
    case r'FULL_GROUP_QUERY':
      return Enum$Permission.FULL_GROUP_QUERY;
    case r'FULL_INDIVIDUAL_REQUEST':
      return Enum$Permission.FULL_INDIVIDUAL_REQUEST;
    case r'FULL_USER_MANAGEMENT':
      return Enum$Permission.FULL_USER_MANAGEMENT;
    case r'INDIVIDUAL_REQUEST':
      return Enum$Permission.INDIVIDUAL_REQUEST;
    case r'MUNICIPALITY_CREATION':
      return Enum$Permission.MUNICIPALITY_CREATION;
    case r'MUNICIPALITY_DELETION':
      return Enum$Permission.MUNICIPALITY_DELETION;
    case r'MUNICIPALITY_MODIFICATION':
      return Enum$Permission.MUNICIPALITY_MODIFICATION;
    case r'NO_EVALUATION':
      return Enum$Permission.NO_EVALUATION;
    case r'NO_SESSION':
      return Enum$Permission.NO_SESSION;
    case r'PERSON_CREATION':
      return Enum$Permission.PERSON_CREATION;
    case r'PERSON_DELETION':
      return Enum$Permission.PERSON_DELETION;
    case r'PERSON_MODIFICATION':
      return Enum$Permission.PERSON_MODIFICATION;
    case r'PERSON_STATUS_CREATION':
      return Enum$Permission.PERSON_STATUS_CREATION;
    case r'PERSON_STATUS_DELETION':
      return Enum$Permission.PERSON_STATUS_DELETION;
    case r'PERSON_STATUS_MODIFICATION':
      return Enum$Permission.PERSON_STATUS_MODIFICATION;
    case r'PERSON_VARIABLE_CREATION':
      return Enum$Permission.PERSON_VARIABLE_CREATION;
    case r'PERSON_VARIABLE_DELETION':
      return Enum$Permission.PERSON_VARIABLE_DELETION;
    case r'PERSON_VARIABLE_FULL_INDIVIDUAL_CREATION':
      return Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_CREATION;
    case r'PERSON_VARIABLE_FULL_INDIVIDUAL_DELETION':
      return Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_DELETION;
    case r'PERSON_VARIABLE_FULL_INDIVIDUAL_MODIFICATION':
      return Enum$Permission.PERSON_VARIABLE_FULL_INDIVIDUAL_MODIFICATION;
    case r'PERSON_VARIABLE_INDIVIDUAL_CREATION':
      return Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_CREATION;
    case r'PERSON_VARIABLE_INDIVIDUAL_DELETION':
      return Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_DELETION;
    case r'PERSON_VARIABLE_INDIVIDUAL_MODIFICATION':
      return Enum$Permission.PERSON_VARIABLE_INDIVIDUAL_MODIFICATION;
    case r'PERSON_VARIABLE_MODIFICATION':
      return Enum$Permission.PERSON_VARIABLE_MODIFICATION;
    case r'PROVINCE_CREATION':
      return Enum$Permission.PROVINCE_CREATION;
    case r'PROVINCE_DELETION':
      return Enum$Permission.PROVINCE_DELETION;
    case r'PROVINCE_MODIFICATION':
      return Enum$Permission.PROVINCE_MODIFICATION;
    case r'QUERY_APROVAL':
      return Enum$Permission.QUERY_APROVAL;
    case r'QUERY_INDEX':
      return Enum$Permission.QUERY_INDEX;
    case r'RECORD_CREATION':
      return Enum$Permission.RECORD_CREATION;
    case r'ROLE_CREATION':
      return Enum$Permission.ROLE_CREATION;
    case r'ROLE_DELETION':
      return Enum$Permission.ROLE_DELETION;
    case r'ROLE_MODIFICATION':
      return Enum$Permission.ROLE_MODIFICATION;
    case r'ROLE_PERMISSION_CREATION':
      return Enum$Permission.ROLE_PERMISSION_CREATION;
    case r'ROLE_PERMISSION_DELETION':
      return Enum$Permission.ROLE_PERMISSION_DELETION;
    case r'ROLE_PERMISSION_MODIFICATION':
      return Enum$Permission.ROLE_PERMISSION_MODIFICATION;
    case r'SUBSCRIPTION_DELETION':
      return Enum$Permission.SUBSCRIPTION_DELETION;
    case r'SUBSCRIPTION_MODIFICATION':
      return Enum$Permission.SUBSCRIPTION_MODIFICATION;
    case r'SUBSCRIPTION_READ':
      return Enum$Permission.SUBSCRIPTION_READ;
    case r'SUBSCRIPTION_TERRITORY_DELETION':
      return Enum$Permission.SUBSCRIPTION_TERRITORY_DELETION;
    case r'SUBSCRIPTION_TERRITORY_MODIFICATION':
      return Enum$Permission.SUBSCRIPTION_TERRITORY_MODIFICATION;
    case r'SUBSRIPTION_CREATION':
      return Enum$Permission.SUBSRIPTION_CREATION;
    case r'SUBSRIPTION_TERRITORY_CREATION':
      return Enum$Permission.SUBSRIPTION_TERRITORY_CREATION;
    case r'TERRITORY_CREATION':
      return Enum$Permission.TERRITORY_CREATION;
    case r'TERRITORY_DELETION':
      return Enum$Permission.TERRITORY_DELETION;
    case r'TERRITORY_MEMBER_SUPERVISION':
      return Enum$Permission.TERRITORY_MEMBER_SUPERVISION;
    case r'TERRITORY_MODIFICATION':
      return Enum$Permission.TERRITORY_MODIFICATION;
    case r'TERRITORY_ROLE_CREATION':
      return Enum$Permission.TERRITORY_ROLE_CREATION;
    case r'TERRITORY_ROLE_DELETION':
      return Enum$Permission.TERRITORY_ROLE_DELETION;
    case r'TERRITORY_ROLE_MODIFICATION':
      return Enum$Permission.TERRITORY_ROLE_MODIFICATION;
    case r'USER_MANAGEMENT':
      return Enum$Permission.USER_MANAGEMENT;
    case r'USER_TERRITORY_CREATION':
      return Enum$Permission.USER_TERRITORY_CREATION;
    case r'USER_TERRITORY_DELETION':
      return Enum$Permission.USER_TERRITORY_DELETION;
    case r'USER_TERRITORY_MODIFICATION':
      return Enum$Permission.USER_TERRITORY_MODIFICATION;
    case r'VARIABLE_TYPE_CREATION':
      return Enum$Permission.VARIABLE_TYPE_CREATION;
    case r'VARIABLE_TYPE_DELETION':
      return Enum$Permission.VARIABLE_TYPE_DELETION;
    case r'VARIABLE_TYPE_MODIFICATION':
      return Enum$Permission.VARIABLE_TYPE_MODIFICATION;
    default:
      return Enum$Permission.$unknown;
  }
}

enum Enum$SortEnumType { ASC, DESC, $unknown }

String toJson$Enum$SortEnumType(Enum$SortEnumType e) {
  switch (e) {
    case Enum$SortEnumType.ASC:
      return r'ASC';
    case Enum$SortEnumType.DESC:
      return r'DESC';
    case Enum$SortEnumType.$unknown:
      return r'$unknown';
  }
}

Enum$SortEnumType fromJson$Enum$SortEnumType(String value) {
  switch (value) {
    case r'ASC':
      return Enum$SortEnumType.ASC;
    case r'DESC':
      return Enum$SortEnumType.DESC;
    default:
      return Enum$SortEnumType.$unknown;
  }
}

const possibleTypesMap = {};
